{"version":3,"sources":["../../config-wrap-start-default.js","inverter/invert-url.js","inverter/orig-bg-info.js","inverter/img-classifier.js","inverter/bg-image-classifier.js","inverter/inverter.js","../../../../../../module-create.js"],"names":["sitecues","define","urls","Promise","invertImageData","ctx","width","height","imageData","getImageData","data","dataLength","length","index","putImageData","createTempImage","url","img","document","createElement","src","getInvertedDataUrl","optionalOrigImage","getLoadedImage","doUseOrigImage","localName","complete","resolve","addEventListener","then","canvas","naturalWidth","naturalHeight","getContext","drawImage","toDataURL","getInvertUrl","origElem","indexOf","newUrl","getProxyApiUrl","colorUtil","styleService","DARK_HINTS_ID","FLAG_BG_DARK","FLAG_BG_LIGHT","getSanitizedSelector","selector","allowSelector","subSelector","lastIndexOf","subSelectors","split","allowedSubSelectors","filter","join","createDarkHintRule","themeStyle","rgba","DARK_BG_THRESHOLD","isDark","getFastLuminance","important","value","contentFlag","createDarkHintCss","styleInfo","darkHintSheetCss","forEach","prop","parsedVal","rule","selectorText","a","init","$sheet","updateSheet","text","getDOMStylesheet","wasOnDarkBackground","current","currentRect","origElement","origRect","getBoundingClientRect","right","left","bottom","top","bgHint","window","getComputedStyle","content","parentElement","$","site","invertUrl","origBgInfo","nativeGlobal","REVERSIBLE_ATTR","customSelectors","get","SVG_SCORE","JPG_SCORE","isDebuggingOn","CLASS_INVERT","CLASS_NORMAL","MAX_SCORE_CHECK_PIXELS","imageScores",".png",".jpg",".jpeg",".gif",".svg","isImageExtension","ext","imgExts","Object","keys","isSVGSource","extname","getReadableImage","onReadableImageAvailable","onReadableImageError","safeUrl","getAttribute","isSafeRequest","isSameOrigin","returnImageWhenComplete","loadableImg","isInverted","on","createSafeImage","$safeImg","attr","rect","processImageData","readableImg","ex","onImageError","getPixelInfo","processPixelInfo","getPixelInfoImpl","grayscaleVal","hueIndex","numWithSameGrayscale","histogramIndex","grayscaleHistogram","GRAYSCALE_HISTOGRAM_SIZE","hueHistogram","HUE_HISTOGRAM_SIZE","byteIndex","hasTransparentPixels","DWORD_SIZE","numBytes","numDifferentGrayscaleVals","numMultiUseGrayscaleVals","numDifferentHues","maxSameGrayscale","MAX_PIXELS_TO_TEST","area","stepSize","Math","floor","min","MIN_TRANSPARENCY_FOR_VALID_PIXEL","numPixelsToCheck","numSameBeforeConsideredMultiUse","max","ceil","numPixelsChecked","luminanceTotal","maxLuminance","r","g","b","isSemiTransparent","rgbToHsl","h","percentWithSameGrayscale","averageLuminance","getImageSize","getSizeScore","score","aspectRatio","getExtensionScore","imageExt","defaultValue","getPixelInfoScore","onPixelScoreAvailable","pixelInfo","SC_DEV","BASE_SCORE","DARK_LUMINANCE_THRESHOLD","DARK_LUMINANCE_MAX_THRESHOLD","BRIGHT_LUMINANCE_THRESHOLD","analysis","manyValuesScore","manyReusedValuesScore","oneValueReusedOftenScore","numHuesScore","transparentPixelsScore","darkNonTransparencyScore","brightWithTransparencyScore","pow","JSON","stringify","getElementTypeScore","BUTTON_BONUS","getStorageKey","STORAGE_PREFIX","getHashCode","s","reduce","charCodeAt","toString","classifyLoadableImage","onShouldReverseImage","storageKey","cachedResult","sessionStorage","getItem","classifyLoadedImage","shouldInvertElement","isReversible","didAnalyzePixels","imageClass","setItem","onImageClassified","imageLoadError","setTimeout","classifyImage","$img","is","reversible","nonReversible","setAttribute","getSource","srcSet","onInversionDecision","size","sizeScore","elementTypeScore","extensionScore","finalScore","pixelInfoScore","classify","root","NOT_CLASSIFIED","$root","find","each","this","debugImageClassifier","readyState","imgClassifier","BG_IMAGE_BONUS","shouldInvertBackgroundImage","getSampleElement","elem","REMOVE_PSEUDO_CLASSES_AND_ELEMENTS","elems","DEFAULT_RECT","x","y","querySelectorAll","replace","css","isPlacedBeforeText","cssStyleDecl","sampleElementCss","paddingLeft","parseFloat","containsHiddenText","textIndent","parseInt","fontSize","hasRepeat","cssDeclRepeat","backgroundRepeat","computedRepeat","classifyBackgroundImage","bgStyle","callbackFn","sampleElement","bgInfo","imageUrl","onImageProcessed","doReverse","backgroundPosition","platform","bgImgClassifier","inlineStyle","mutationObserver","filterProperty","SHOULD_USE_PROXY","inverseSpriteSheet","$allReversibleElems","INVERSE_SPRITE_STYLESHEET_ID","isCurrentlyInverting","toggle","doInversions","start","stop","toggleSheet","reverseElems","disconnect","refresh","body","MutationObserver","onMutation","observe","childList","subtree","mutationRecords","mutationRecord","addedNodes","onClassifiedAsReversible","add","classifyIframes","reverseElemCss","savedFilter","styles","override","reverseElemProxy","currentSrc","savedSrc","$elems","isSVG","reverseElem","reverseCallbackFn","$iframes","REVERSIBLE_FRAME_REGEX","isReversibleFilter","match","isReversibleBg","style","getCssForOneSprite","getFilterProperty","div","divStyle","cssPrefix","sheet","isDisabled","disabled","themeStyles","browser","isIE","isSafari","classifyBgImages","bgImageStyles","isBgImageStyle","numImagesRemainingToClassify","info","nextImage","bgImageInfo","getReverseSpriteCssText","reversibleBgStyles","all","map","allCss","inverseSpriteCss","domStyleSheet"],"mappings":"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","file":"inverter.js.map","sourcesContent":["\"use strict\";\n","/**\n *  Get an image url that is the inverted version of the image url passed-in\n */\n\nsitecues.define('inverter/invert-url',[\n  'run/conf/urls',\n  'Promise'\n],\n  function(urls,\n           Promise) {\n\n    // Helper to invert image data, pixel by pixel\n    function invertImageData(ctx, width, height) {\n      var imageData = ctx.getImageData(0, 0, width, height),\n        data = imageData.data,\n        dataLength = data.length,\n        index = 0;\n\n      for (; index < dataLength; index += 4) {\n        // red\n        data[index] = 255 - data[index];\n        // green\n        data[index + 1] = 255 - data[index + 1];\n        // blue\n        data[index + 2] = 255 - data[index + 2];\n      }\n\n      ctx.putImageData(imageData, 0, 0);\n    }\n\n    // Temporary image, created so we can find the width/height\n    function createTempImage(url) {\n      // Create temporary image\n      var img = document.createElement('img');\n      img.src = url;\n      return img;\n    }\n\n    // Create an inverted version of a data: image, pixel by pixel\n    // Pass in original image if available, otherwise it will create a temporary image\n    function getInvertedDataUrl(url, optionalOrigImage) {\n      function getLoadedImage() {\n        var\n        // Use temp image if orig <img> not available (will have naturalHeight and naturalWidth set)\n          doUseOrigImage = optionalOrigImage && optionalOrigImage.localName === 'img',\n          img = doUseOrigImage ? optionalOrigImage : createTempImage(url);\n\n        if (img.complete) {\n          return Promise.resolve(img);\n        }\n\n        return new Promise(function(resolve) {\n          img.addEventListener('load', function () {\n            resolve(img);\n          });\n        });\n      }\n\n      return getLoadedImage()\n        .then(function(img) {\n          var\n            canvas = document.createElement('canvas'),\n            width = canvas.width = img.naturalWidth,\n            height = canvas.height = img.naturalHeight,\n            ctx = canvas.getContext('2d');\n\n          // Draw the image\n          ctx.drawImage(img, 0, 0, width, height);\n\n          // Invert it\n          invertImageData(ctx, width, height);\n\n          // Return new data url\n          return canvas.toDataURL();\n        });\n    }\n\n    function getInvertUrl(url, origElem) {\n\n      // Data url\n      if (url.indexOf('data:') === 0) {\n        // The image service can't invert this url, but we can do it in JS.\n        // Very useful for example on http://www.gatfl.gatech.edu/tflwiki/index.php?title=Team\n        return getInvertedDataUrl(url, origElem);\n      }\n\n      var newUrl = urls.getProxyApiUrl('image/invert', url);\n\n      return Promise.resolve(newUrl);\n    }\n    return {\n      getInvertUrl: getInvertUrl\n    };\n  });\n\n","/*  Create a style sheet that provides info about the original background colors of the page.\n *  We still need to know the original colors for processing images and background-images.\n *\n *  The hints are as follows:\n *  content: \"d\"   --> originally dark background\n *  content: \"l\"   --> originally light background\n *\n *  Q. Why in a hacky stylesheet instead of data tied to specific elements?\n *  A. Because this hack allows us to understand newly-added content without doing anything.\n *     The browser automatically ties the metadata from 'content' rules to any new content\n *\n *  Q. Why not track selectors with bg color rules and determine applicability of those style rules ourselves?\n *  A. Because understanding CSS precedence in browsers is tres hard.\n *\n *  Q. Why doesn't this damage the page view?\n *  A. CSS content rules do not affect normal elements, they only actually get used for ::before and ::after\n *     We automatically filter out those selectors when we create the style sheet with our hint rules.\n *\n *  We only create this sheet once.\n */\n\nsitecues.define('inverter/orig-bg-info',[\n  'Promise',\n  'page/util/color',\n  'page/style-service/style-service'\n],\nfunction(Promise,\n         colorUtil,\n         styleService) {\n\n  var DARK_HINTS_ID = 'sitecues-js-orig-info',\n    FLAG_BG_DARK = '\"D\"',\n    FLAG_BG_LIGHT = '\"L\"';\n\n  function getSanitizedSelector(selector) {\n    function allowSelector(subSelector) {\n      return subSelector.lastIndexOf(':before') <0 && subSelector.lastIndexOf(':after') < 0;\n    }\n    // Remove :before, ::before, :after, ::after rules\n    var subSelectors = selector.split(','),\n      allowedSubSelectors = subSelectors.filter(allowSelector);\n\n    return allowedSubSelectors.join(',');\n  }\n\n  function createDarkHintRule(selector, themeStyle, rgba) {\n    var DARK_BG_THRESHOLD = 0.6,\n      isDark = colorUtil.getFastLuminance(rgba) < DARK_BG_THRESHOLD,\n      important = themeStyle.value.important,\n      contentFlag = isDark ? FLAG_BG_DARK : FLAG_BG_LIGHT;  // D = dark, L = light\n\n    return selector +\n      '{ content: ' + contentFlag + (important ? ' !important; ' : '; ') + '}\\n';\n  }\n\n  function createDarkHintCss(styleInfo) {\n    var darkHintSheetCss = '';\n\n    styleInfo.forEach(function (themeStyle) {\n      if (themeStyle.value.prop !== 'background-color') {\n        return;\n      }\n      var rgba = themeStyle.value.parsedVal,\n        selector = getSanitizedSelector(themeStyle.rule.selectorText);\n\n      if (rgba.a > 0.5 && selector) {\n        // Don't bother if mostly transparent\n        // Only use selectors without :before and :after\n        darkHintSheetCss += createDarkHintRule(selector, themeStyle, rgba);\n      }\n    });\n\n    return darkHintSheetCss;\n  }\n\n  // Return a promise to the bg hints style sheet\n  function init(styleInfo) {\n    return new Promise(function (resolve) {\n      var darkHintSheetCss = createDarkHintCss(styleInfo),\n        $sheet = styleService.updateSheet(DARK_HINTS_ID, {text: darkHintSheetCss});\n      styleService.getDOMStylesheet($sheet, resolve);\n    });\n  }\n\n  function wasOnDarkBackground(current) {\n    var origElement = current,\n      currentRect,\n      origRect = origElement.getBoundingClientRect();\n\n    while (current) {\n      currentRect = current.getBoundingClientRect();\n\n      // Only care about backgrounds where the original element is inside of the background rect\n      if (currentRect.right > origRect.left && currentRect.left < origRect.right &&\n        currentRect.bottom > origRect.top && currentRect.top < origRect.bottom) {\n        var bgHint = window.getComputedStyle(current).content;\n        if (bgHint === FLAG_BG_DARK) {\n          return true;\n        }\n        else if (bgHint === FLAG_BG_LIGHT) {\n          return false;\n        }\n      }\n\n      current = current.parentElement;\n    }\n    return false;\n  }\n\n\n  return {\n    init: init,\n    wasOnDarkBackground: wasOnDarkBackground\n  };\n\n});\n\n","/**\n *  Mark images as needing inversion for a dark theme\n *  Web page can override either via:\n *    data-sc-reversible=\"true\" or \"false\"\n *    config.themes = {\n *      reversible: [selector],\n *      nonReversible: [selector]\n *    }\n */\n\nsitecues.define(\n  'inverter/img-classifier',[\n    '$',\n    'page/util/color',\n    'run/conf/site',\n    'run/conf/urls',\n    'inverter/invert-url',\n    'inverter/orig-bg-info',\n    'mini-core/native-global'\n  ],\n  function (\n    $,\n    colorUtil,\n    site,\n    urls,\n    invertUrl,\n    origBgInfo,\n    nativeGlobal\n  ) {\n  'use strict';\n\n  var\n    REVERSIBLE_ATTR = 'data-sc-reversible',\n    customSelectors = site.get('themes') || {},\n    SVG_SCORE       = 999,\n    JPG_SCORE       = -50,\n    isDebuggingOn   = true,\n    CLASS_INVERT    = 'i',\n    CLASS_NORMAL    = 'n',\n    MAX_SCORE_CHECK_PIXELS = 200,\n    imageScores     = {\n      '.png'  : 50,\n      '.jpg'  : JPG_SCORE,\n      '.jpeg' : JPG_SCORE,\n      '.gif'  : -35,\n      '.svg'  : SVG_SCORE\n    };\n\n  function isImageExtension(ext) {\n    var imgExts = Object.keys(imageScores);\n    return imgExts.indexOf(ext) !== -1;\n  }\n\n  function isSVGSource(src) {\n    var ext = urls.extname(src);\n    return ext === '.svg';\n  }\n\n  // Get <img> that can have its pixel data read --\n  // 1. Must be completely loaded\n  // 2. We have permission (either we're in the extension, the img is not cross-origin, or we can load it through the proxy)\n  // Either pass img or src, but not both\n  function getReadableImage(img, src, onReadableImageAvailable, onReadableImageError) {\n    // Unsafe cross-origin request\n    // - Will run into cross-origin restrictions because URL is from different origin\n    // This is not an issue with the extension, because the content script doesn't have cross-origin restrictions\n    var url = src || img.getAttribute('src'),\n      isSafeRequest = urls.isSameOrigin(url),\n      safeUrl;\n\n    function returnImageWhenComplete(loadableImg, isInverted) {\n      if (loadableImg.complete) {\n        onReadableImageAvailable(loadableImg, isInverted); // Already loaded\n      }\n      else {\n        $(loadableImg)\n          .on('load', function() {\n            onReadableImageAvailable(loadableImg, isInverted);\n          })\n          .on('error', onReadableImageError);\n      }\n    }\n\n    if (isSafeRequest) {\n      if (img && img.localName === 'img') {\n        returnImageWhenComplete(img); // The <img> in the DOM can have its pixels queried\n        return;\n      }\n      // Element we want to read is not an <img> -- for example, <input type=\"image\">\n      // Create an <img> with the same url so we can apply it to the canvas\n      safeUrl = url;\n      returnImageWhenComplete(createSafeImage(safeUrl));\n    }\n\n    // Uses inverted image for analysis so that if we need to display it, it's already in users cache.\n    // The inverted image will show the same number of brightness values in the histogram so this won't effect classification\n    invertUrl.getInvertUrl(url, img)\n      .then(function(newUrl) {\n        returnImageWhenComplete(createSafeImage(newUrl, true));\n      });\n  }\n\n  function createSafeImage(url) {\n    var $safeImg = $('<img>')\n      // Allows use of cross-origin image data\n      .attr('crossorigin', 'anonymous')\n      // Set after crossorigin is set! The order matters.\n      // See http://stackoverflow.com/questions/23123237/drawing-images-to-canvas-with-img-crossorigin-anonymous-doesnt-work\n      .attr('src', url);\n\n    return $safeImg[0];\n  }\n\n  // Either pass img or src, but not both\n  function getImageData(img, src, rect, processImageData) {\n    var canvas = document.createElement('canvas'),\n      ctx,\n      top = rect.top || 0,\n      left = rect.left || 0,\n      width = rect.width,\n      height = rect.height,\n      imageData;\n    canvas.width = width;\n    canvas.height = height;\n\n    function onReadableImageAvailable(readableImg, isInverted) {\n      ctx = canvas.getContext('2d');\n      try {\n        ctx.drawImage(readableImg, top, left, width, height);\n      }\n      catch(ex) {\n        processImageData(); // No data -- probably a broken image\n        return;\n      }\n      imageData = ctx.getImageData(0, 0, width, height).data;\n      processImageData(imageData, isInverted);\n    }\n\n    function onImageError() {\n      processImageData(); // No data\n    }\n\n    getReadableImage(img, src, onReadableImageAvailable, onImageError);\n  }\n\n  // Either pass img or src, but not both\n  function getPixelInfo(img, src, rect, processPixelInfo) {\n    getImageData(img, src, rect, function(data, isInverted) {\n      processPixelInfo(data && getPixelInfoImpl(data, rect.width, rect.height, isInverted));\n    });\n  }\n\n  function getPixelInfoImpl(data, width, height, isInverted) {\n    //\n    // Compute Image Features (if we can...)\n    // We may not be able to if the image is not from the same origin.\n    //\n    var grayscaleHistogram = [],\n      GRAYSCALE_HISTOGRAM_SIZE = 500,\n      grayscaleVal,\n      hueHistogram = [],\n      HUE_HISTOGRAM_SIZE = 100,\n      hueIndex,\n      byteIndex = 0,\n      hasTransparentPixels = false,\n      DWORD_SIZE = 4,\n      numBytes = width * height * DWORD_SIZE,\n      numDifferentGrayscaleVals = 0,\n      numMultiUseGrayscaleVals = 0,\n      numWithSameGrayscale,\n      numDifferentHues = 0,\n      maxSameGrayscale = 0,\n      MAX_PIXELS_TO_TEST = 523,\n      area = height * width,\n      stepSize = Math.floor(area / Math.min(area, MAX_PIXELS_TO_TEST)),\n      MIN_TRANSPARENCY_FOR_VALID_PIXEL = 0.3,\n      numPixelsToCheck = Math.floor(area / stepSize),\n      // Greater of: 6 pixels or 5% of total pixels checked\n      numSameBeforeConsideredMultiUse = Math.max(Math.ceil(numPixelsToCheck * 0.05), 6),\n      numPixelsChecked = 0,\n      histogramIndex,\n      luminanceTotal = 0,\n      maxLuminance = 0;\n\n    for(; byteIndex < numBytes; byteIndex += DWORD_SIZE * stepSize) {\n      var\n        rgba = {\n          r: data[byteIndex],\n          g: data[byteIndex + 1],\n          b: data[byteIndex + 2],\n          a: data[byteIndex + 3]\n        },\n        isSemiTransparent = rgba.a < 255;\n\n      if (isSemiTransparent) {  // Alpha channel\n        hasTransparentPixels = true;\n        if (rgba.a < MIN_TRANSPARENCY_FOR_VALID_PIXEL) {\n          continue;  // Don't use pixels that are mostly transparent for histogram or brighness measurements\n        }\n      }\n\n      ++ numPixelsChecked;\n\n      if (isInverted) {\n        // Used inverted image to get around cross-origin issues\n        // We use this instead of passthrough option because it puts the image into the cache in case we need it\n        // However, we need to evaluate the brightness as if it's not inverted\n        rgba.r = 255 - rgba.r;\n        rgba.g = 255 - rgba.g;\n        rgba.b = 255 - rgba.b;\n      }\n\n      grayscaleVal = colorUtil.getFastLuminance(rgba);\n      luminanceTotal += grayscaleVal;\n      if (grayscaleVal > maxLuminance) {\n        maxLuminance = grayscaleVal;\n      }\n      histogramIndex = Math.floor(grayscaleVal * GRAYSCALE_HISTOGRAM_SIZE);\n\n      if (grayscaleHistogram[histogramIndex] > 0)  {\n        numWithSameGrayscale = ++ grayscaleHistogram[histogramIndex];\n        if (numWithSameGrayscale === numSameBeforeConsideredMultiUse) {\n          ++numMultiUseGrayscaleVals;\n        }\n        if (numWithSameGrayscale > maxSameGrayscale) {\n          maxSameGrayscale = numWithSameGrayscale;\n        }\n      }\n      else {\n        grayscaleHistogram[histogramIndex] = 1;\n        ++ numDifferentGrayscaleVals;\n      }\n\n      hueIndex = Math.floor(colorUtil.rgbToHsl(rgba.r, rgba.g, rgba.b).h * HUE_HISTOGRAM_SIZE);\n      if (hueHistogram[hueIndex] > 0) {\n        ++ hueHistogram[hueIndex];\n      }\n      else {\n        hueHistogram[hueIndex] = 1;\n        ++ numDifferentHues;\n      }\n    }\n\n    return {\n      hasTransparentPixels: hasTransparentPixels,\n      numDifferentGrayscaleVals: numDifferentGrayscaleVals,\n      numMultiUseGrayscaleVals: numMultiUseGrayscaleVals,\n      percentWithSameGrayscale: numPixelsChecked ? maxSameGrayscale / numPixelsChecked : 0.5,\n      numDifferentHues: numDifferentHues,\n      averageLuminance: numPixelsChecked ? luminanceTotal / numPixelsChecked : 0.5,\n      maxLuminance: maxLuminance\n    };\n  }\n\n  function getImageSize(img) {\n    return {\n      // Sometimes naturalWidth, naturalHeight are not available, especially in the case of <input type=\"image\">\n      width: img.naturalWidth || img.width,\n      height: img.naturalHeight || img.height\n    };\n  }\n\n  // These come from the original machine-learned algorithms\n  function getSizeScore(height, width) {\n    if (width <= 1 || height <= 1) {\n      return 0; // It's possible that image simply isn't loaded yet, scroll down in brewhoop.com\n    }\n\n    var score = 0,\n      aspectRatio = width / height;\n\n    // No color information\n    if (height < 26) {\n      score += 100;\n    }\n    else if (height < 37) {\n      score += 50;\n    }\n\n    if (height > 180) {\n      score += 180 - height;\n    }\n    else if (aspectRatio === 1) {\n      score *= 2;\n    }\n    else if (aspectRatio > 4) {\n      score += 100;\n    }\n    else if (aspectRatio > 3) {\n      score += 50;\n    }\n    if (height < 400) {\n      if (aspectRatio < 0.7) {\n        score -= 50;\n      }\n      else if (aspectRatio > 1.4 && aspectRatio < 1.9) {\n        score -= 70; // Typical photo\n        if (aspectRatio > 1.49 && aspectRatio < 1.51) {\n          score -= 30;  // 1.5:1 even more typical photo\n        }\n        if (height > 130) {\n          score += 130 - height;\n        }\n      }\n    }\n\n    return Math.max(score, -150);\n  }\n\n  function getExtensionScore(imageExt) {\n    var defaultValue = -70;\n    return typeof imageScores[imageExt] === 'number' ? imageScores[imageExt] : defaultValue;\n  }\n\n  // Either pass img or src, but not both\n  function getPixelInfoScore(img, src, rect, onPixelScoreAvailable) {\n\n    if (rect.width <= 1 || rect.height <= 1) {\n      onPixelScoreAvailable(0); // It's possible that image simply isn't loaded yet, scroll down in brewhoop.com\n      return;\n    }\n\n    // The magic values in here are taken from the original machine-learned algorithms\n    // from Jeff Bigham's work, and have been tweaked a bit.\n    getPixelInfo(img, src, rect, function(pixelInfo) {\n      if (!pixelInfo) {\n        if (SC_DEV && isDebuggingOn && img) {\n          $(img).attr('data-sc-pixel-score', 'invalid');\n        }\n        onPixelScoreAvailable(0, true);  // true -> this was an expensive operation so we should cache the result\n        return;\n      }\n\n      var score,\n        BASE_SCORE = 130,\n        DARK_LUMINANCE_THRESHOLD = 0.40,\n        DARK_LUMINANCE_MAX_THRESHOLD = 0.35,\n        BRIGHT_LUMINANCE_THRESHOLD = 0.60,\n        analysis = {\n          manyValuesScore: 0,\n          manyReusedValuesScore: 0,\n          oneValueReusedOftenScore: 0,\n          numHuesScore: 0,\n          transparentPixelsScore: 0,\n          darkNonTransparencyScore: 0,\n          brightWithTransparencyScore: 0\n        };\n\n      // Low score -> NO invert (probably photo)\n      // High score -> YES invert (probably logo, icon or image of text)\n\n      // Transparent pixels -> more likely icon that needs inversion\n      // No transparent pixels -> rectangular shape that usually won't be problematic over any background\n      analysis.transparentPixelsScore = pixelInfo.hasTransparentPixels * 100;\n\n      // More values -> more likely to be photo\n      analysis.manyValuesScore = -1.5 * Math.min(200, pixelInfo.numDifferentGrayscaleVals);\n\n      // Values reused -> less likely to be a photo\n      analysis.manyReusedValuesScore = 15 * Math.min(20, pixelInfo.numMultiUseGrayscaleVals);\n\n      // One large swath of color -> less likely to be a photo. For example 30% -> +60 points\n      analysis.oneValueReusedOftenScore = Math.min(50, pixelInfo.percentWithSameGrayscale * 200);\n\n      if (pixelInfo.hasTransparentPixels) {\n        if (pixelInfo.averageLuminance > BRIGHT_LUMINANCE_THRESHOLD) {\n          // This is already looks like bright text or a bright icon\n          // Don't revert, because it will most likely end up as dark on dark\n          analysis.brightWithTransparencyScore = -1500 * (pixelInfo.averageLuminance - BRIGHT_LUMINANCE_THRESHOLD);\n        }\n      }\n      else if (pixelInfo.averageLuminance < DARK_LUMINANCE_THRESHOLD) {\n        // This is already a very dark image, so inverting it will make it bright -- unlikely the right thing to do\n        // We don't do this for images with transparent pixels, because it is likely a dark drawing on a light background,\n        // which needs to be inverted\n        analysis.darkNonTransparencyScore = -1000 * (DARK_LUMINANCE_THRESHOLD - pixelInfo.averageLuminance) - 50;\n        if (pixelInfo.maxLuminance < DARK_LUMINANCE_MAX_THRESHOLD) {\n          analysis.darkNonTransparencyScore *= 2; // Really dark -- there is nothing bright in this image at all\n        }\n      }\n\n      // Many hues -> more likely to be a photo -- experimentation showed that 8 hues seemed to work as a threshold\n      if (pixelInfo.numDifferentHues < 8) {\n        // Few hues: probably not a photo -- YES invert\n        analysis.numHuesScore =  Math.pow(pixelInfo.numDifferentHues - 8, 2) * 1.5;\n      }\n      else if (pixelInfo.numDifferentHues > 35) {\n        // Many hues: probably a photo -- NO invert\n        analysis.numHuesScore =  pixelInfo.numDifferentHues * -2;\n      }\n\n      score = BASE_SCORE +\n        analysis.transparentPixelsScore +\n        analysis.manyValuesScore +\n        analysis.manyReusedValuesScore +\n        analysis.oneValueReusedOftenScore +\n        analysis.brightWithTransparencyScore +\n        analysis.darkNonTransparencyScore +\n        analysis.numHuesScore;\n\n      // Image has full color information\n      if (SC_DEV && isDebuggingOn && img) {\n        $(img).attr('data-sc-pixel-info', nativeGlobal.JSON.stringify(pixelInfo));\n        $(img).attr('data-sc-pixel-score-breakdown', nativeGlobal.JSON.stringify(analysis));\n        $(img).attr('data-sc-pixel-score', score);\n      }\n\n      onPixelScoreAvailable(score, true);  // true -> this was an expensive operation so we should cache the result\n    });\n  }\n\n  function getElementTypeScore(img) {\n    var BUTTON_BONUS = 50;\n    switch (img.localName) {\n      case 'input':\n        return BUTTON_BONUS;\n      case 'svg':\n        return SVG_SCORE;\n      default:\n        return 0;\n    }\n  }\n\n  // Uses a sitecues prefix to avoid namespace conflicts with underlying page\n  // Uses a hash function on the url to reduce the amount of storage required to save results for each url\n  function getStorageKey(img) {\n    var STORAGE_PREFIX = '-sc-img-';\n\n    // jshint -W016\n    function getHashCode(s) {\n      // From http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n      // but modified to reduce the number of collisions (by not confining the values to 32 bit)\n      // For 294 images on a site, the normal 32 bit hash algorithm has a 1/100,000 chance of collision, and we are better than that.\n      // For more info on hash collisions, see http://preshing.com/20110504/hash-collision-probabilities/\n      return s.split('').reduce(function (a, b) {\n        return ((a << 5) - a) + b.charCodeAt(0);\n      }, 0).toString(36);\n    }\n\n    return STORAGE_PREFIX + getHashCode(img.getAttribute('src'));\n  }\n\n  // Classify an image that is loaded/loading from a src\n  function classifyLoadableImage(img, onShouldReverseImage) {\n\n    var\n      storageKey = getStorageKey(img),\n      cachedResult = sessionStorage.getItem(storageKey);\n\n    function classifyLoadedImage() {\n      shouldInvertElement(img, function(isReversible, didAnalyzePixels) {\n\n        if (didAnalyzePixels) {\n          // Only cache for expensive operations, in order to save on storage space\n          var imageClass = isReversible ? CLASS_INVERT : CLASS_NORMAL;\n          // Use session storage instead of local storage so that we don't pollute too much\n          try {\n            sessionStorage.setItem(storageKey, imageClass);\n          }\n          catch(ex) {}\n        }\n\n        onImageClassified(img, isReversible, onShouldReverseImage);\n      });\n    }\n\n    function imageLoadError() {\n      onImageClassified(img, false);\n    }\n\n    if (!SC_DEV && cachedResult) {\n      // Use cached result if available\n      onImageClassified(img, cachedResult === CLASS_INVERT, onShouldReverseImage);\n    }\n    else if (img.complete) {\n      //Image is loaded and ready for processing -- after slight delay\n      nativeGlobal.setTimeout(classifyLoadedImage, 0);\n    }\n    else {\n      // Too early to tell anything\n      // Wait until image loaded\n      $(img)\n        .on('load', classifyLoadedImage)\n        .on('error', imageLoadError);\n    }\n  }\n\n  /**\n   * Classifier function for images without missing features.\n   * This formula came from a machine learning algorithm with the help of Jeffrey Bigham\n   * @param img\n   * @returns {*}\n   */\n  function classifyImage(img, onShouldReverseImage) {\n    var isReversible,\n      $img = $(img);\n\n    if ($img.is(customSelectors.reversible)) {\n      isReversible = true;\n    }\n    else if ($img.is(customSelectors.nonReversible)) {\n      isReversible = false;\n    }\n    else if (origBgInfo.wasOnDarkBackground(img)) {\n      isReversible = false;\n    }\n    else if (img.localName === 'svg') {\n      isReversible = true;\n    }\n    else if (!img.src) {\n      isReversible = false;\n    }\n    else {\n      classifyLoadableImage(img, onShouldReverseImage);\n      return;\n    }\n\n    onImageClassified(img, isReversible, onShouldReverseImage);\n  }\n\n  function onImageClassified(img, isReversible, onShouldReverseImage) {\n    img.setAttribute(REVERSIBLE_ATTR, isReversible);\n    if (isReversible) {\n      onShouldReverseImage(img);\n    }\n  }\n\n  function getSource(img) {\n    var src = img.getAttribute('src'),\n      srcSet;\n    if (!src) {\n      srcSet = img.getAttribute('srcset');\n      if (srcSet) {\n        src = srcSet.split('/, /')[0]; // Get first URL\n      }\n    }\n    return src;\n  }\n\n  function shouldInvertElement(img, onInversionDecision) {\n    var src = getSource(img);\n\n    if (!src) {\n      return false; // Image has no source -- don't invert\n    }\n\n    var imageExt = urls.extname(src);\n\n    if (!isImageExtension(imageExt)) {\n      return false;  // Not a normal image extension -- don't invert\n    }\n\n    var size = getImageSize(img),\n      sizeScore = getSizeScore(size.height, size.width),\n      elementTypeScore = getElementTypeScore(img),\n      extensionScore = getExtensionScore(imageExt),\n      finalScore = sizeScore + elementTypeScore + extensionScore;\n\n    if (finalScore < -MAX_SCORE_CHECK_PIXELS || finalScore > MAX_SCORE_CHECK_PIXELS) {\n      // Early return\n      onInversionDecision(finalScore > 0);\n      return;\n    }\n\n    // Pixel info takes longer to get: only do it if necessary\n    getPixelInfoScore(img, null, size, function (pixelInfoScore, didAnalyzePixels) {\n\n      finalScore += pixelInfoScore;\n\n      if (SC_DEV && isDebuggingOn) {\n        $(img).attr(\n          'score',\n          sizeScore + ' (size) + ' +\n          (\n            elementTypeScore ?\n            elementTypeScore + ' (button) + ' :\n              ''\n          ) +\n          extensionScore + ' (ext) + ' +\n          pixelInfoScore + ' (pixels) = ' + finalScore\n        );\n      }\n\n      onInversionDecision(finalScore > 0, didAnalyzePixels);\n    });\n  }\n\n  function classify(root, onShouldReverseImage) {\n    var NOT_CLASSIFIED = ':not([' + REVERSIBLE_ATTR + '])',\n      selector = 'img[src]' + NOT_CLASSIFIED +\n                 ',picture[srcset]' + NOT_CLASSIFIED +\n                 ',input[type=\"image\"]' + NOT_CLASSIFIED +\n                 ',svg' + NOT_CLASSIFIED,\n      $root = $(root);\n\n    if ($root.is(selector)) {  // Single image\n      classifyImage(root, onShouldReverseImage);\n    }\n    else {  // Subtree of potential images\n      $(root).find(selector).each(function() {\n        classifyImage(this, onShouldReverseImage);\n      });\n    }\n  }\n\n  if (SC_DEV) {\n    sitecues.debugImageClassifier = function() {\n      isDebuggingOn = true;\n      if (document.readyState === 'complete') {\n        classify();\n      }\n      else {\n        $(window).on('load', classify);\n      }\n    };\n//      sitecues.debugImageClassifier();\n  }\n\n  return {\n    classify: classify,\n    getSizeScore: getSizeScore,\n    getExtensionScore: getExtensionScore,\n    getPixelInfoScore: getPixelInfoScore,\n    isImageExtension: isImageExtension,\n    isSVGSource: isSVGSource\n  };\n});\n\n","sitecues.define(\n  'inverter/bg-image-classifier',[\n    'run/conf/urls',\n    'inverter/orig-bg-info',\n    'inverter/img-classifier'\n  ],\n  function(\n    urls,\n    origBgInfo,\n    imgClassifier\n  ) {\n  'use strict';\n\n  var\n    BG_IMAGE_BONUS = 40,\n    MAX_SCORE_CHECK_PIXELS = 200;\n\n  function shouldInvertBackgroundImage(src, size, onInversionDecision) {\n    var imageExt = urls.extname(src);\n\n    if (!imgClassifier.isImageExtension(imageExt)) {\n      onInversionDecision(false);  // Not a normal image extension -- don't invert\n      return;\n    }\n\n    var sizeScore = imgClassifier.getSizeScore(size.height, size.width),\n      extensionScore = imgClassifier.getExtensionScore(imageExt),\n      finalScore = BG_IMAGE_BONUS + sizeScore + extensionScore;\n\n    if (finalScore < -MAX_SCORE_CHECK_PIXELS || finalScore > MAX_SCORE_CHECK_PIXELS) {\n      onInversionDecision(finalScore > 0);\n      return;\n    }\n\n    // Pixel info takes longer to get: only do it if necessary\n    imgClassifier.getPixelInfoScore(null, src, size, function (pixelInfoScore) {\n      finalScore += pixelInfoScore;\n      onInversionDecision(finalScore > 0);\n    });\n  }\n\n  function getSampleElement(selector) {\n    var REMOVE_PSEUDO_CLASSES_AND_ELEMENTS = /::?[^ ,:.]+/g,\n      elems = [], elem, rect, index,\n      DEFAULT_RECT = { x: 0, y: 0, width: 20, height: 20 };\n\n    try {\n      elems = document.querySelectorAll(selector.replace(REMOVE_PSEUDO_CLASSES_AND_ELEMENTS, ''));\n    }\n    catch(ex) {}\n\n    // Get first visible sample element if available\n    index = elems.length;\n    while (index -- ) {\n      elem = elems[index];\n      rect = elem.getBoundingClientRect();\n      if (index === 0 || (rect.width && rect.height)) {\n        return {\n          elem: elem,\n          rect: { x: 0, y: 0, width: rect.width, height: rect.height },\n          css: getComputedStyle(elem)\n        };\n      }\n    }\n    return {\n      css: {},\n      rect: DEFAULT_RECT\n    };\n  }\n\n  function isPlacedBeforeText(cssStyleDecl, sampleElementCss) {\n    // Content with text-indent is using inner text as alternative text but placing it offscreen\n    var paddingLeft = cssStyleDecl.paddingLeft || sampleElementCss.paddingLeft;\n    return parseFloat(paddingLeft) > 0;\n  }\n\n  // Does it appear that the background element has hidden text?\n  // If so, this is usually a technique to give a sprite alternative text\n  function containsHiddenText(cssStyleDecl, sampleElementCss) {\n    return cssStyleDecl.textIndent || parseInt(sampleElementCss.textIndent) < 0 ||\n      parseInt(cssStyleDecl.fontSize) === 0 || parseInt(sampleElementCss.fontSize) === 0;\n  }\n\n  // Check for CSS repeat rules which usually indicate the image is a texture/pattern\n  function hasRepeat(cssStyleDecl, sampleElementCss) {\n\n    // Look for repeat rule on the style declaration itself\n    var cssDeclRepeat = cssStyleDecl.backgroundRepeat;\n    if (cssDeclRepeat && cssDeclRepeat.indexOf('no-repeat') < 0) {\n      return true; // This means it's repeat, repeat-x or repeat-y\n    }\n\n    // Look for repeat rule on the computed style, but don't trust 'repeat' -- it's the default\n    var computedRepeat = sampleElementCss.backgroundRepeat;\n    if (computedRepeat === 'repeat-x' || computedRepeat === 'repeat-y') {\n      return true;\n    }\n  }\n\n  function classifyBackgroundImage(bgStyle, callbackFn) {\n    var\n      bgInfo = bgStyle.value,\n      imageUrl = bgInfo.imageUrl,\n      cssStyleDecl = bgStyle.rule,\n      selector = bgStyle.rule.selectorText,\n      sampleElement;\n\n    function onImageProcessed(doReverse) {\n      bgInfo.doReverse = doReverse;\n      callbackFn();\n    }\n\n    sampleElement = getSampleElement(selector);\n\n    if (hasRepeat(cssStyleDecl, sampleElement.css)) {\n      // Repeating pattern such as a texture or line\n      onImageProcessed(true);\n      return;\n    }\n\n    if (cssStyleDecl.width !== '100%') {\n      // Spread across the page -- could be photo-like, so it's not safe to reverse unless we check the pixels\n      // Make sure it's dark so that text can be visible on top of it\n      // TODO should we check for visible text on top?\n      if (containsHiddenText(cssStyleDecl, sampleElement.css) || isPlacedBeforeText(cssStyleDecl, sampleElement.css) ||\n        (cssStyleDecl.backgroundPosition && cssStyleDecl.backgroundPosition.indexOf('%') < 0)) {\n        // Clearly a sprite -- reverse it so that it shows on the newly reversed background\n        onImageProcessed(true);\n        return;\n      }\n\n      if (sampleElement.elem) {\n        if (origBgInfo.wasOnDarkBackground(sampleElement.elem)) {\n          // Already designed to show on a dark background\n          onImageProcessed(false);\n          return;\n        }\n      }\n    }\n\n    shouldInvertBackgroundImage(imageUrl, sampleElement.rect, onImageProcessed);\n  }\n\n  return {\n    classifyBackgroundImage: classifyBackgroundImage\n  };\n});\n","/*  Support color inversion of elements that are not text.\n *  Used for dark themes.\n */\n\nsitecues.define(\n  'inverter/inverter',[\n    '$',\n    'Promise',\n    'run/platform',\n    'page/style-service/style-service',\n    'inverter/invert-url',\n    'inverter/bg-image-classifier',\n    'inverter/img-classifier',\n    'inverter/orig-bg-info',\n    'run/inline-style/inline-style'\n  ],\n  function (\n    $,\n    Promise,\n    platform,\n    styleService,\n    invertUrl,\n    bgImgClassifier,\n    imgClassifier,\n    origBgInfo,\n    inlineStyle\n  ) {\n  'use strict';\n\n  var mutationObserver,\n    $allReversibleElems = $(),\n    filterProperty,\n    // Use proxy in IE and Safari, because: no css invert in IE, and it's extremely slow in Safari\n    SHOULD_USE_PROXY,\n    inverseSpriteSheet,\n    INVERSE_SPRITE_STYLESHEET_ID = 'sitecues-js-invert-sprites',\n    isCurrentlyInverting         = false;\n\n  // This method is called when the site goes from dark to light or light to dark. When it goes to dark,\n  // it will analyze images if they haven't been analyzed before, and start a mutation observer so that\n  // new incoming images are also analyzed.\n  function toggle(doInversions) {\n    if (isCurrentlyInverting === doInversions) {\n      return; // Already working on inversions\n    }\n\n    isCurrentlyInverting = doInversions;\n\n    if (doInversions) {\n      start();\n    }\n    else {\n      stop();\n    }\n\n    toggleSheet(inverseSpriteSheet, !doInversions);\n  }\n\n  function stop() {\n    reverseElems($allReversibleElems, false);\n    $allReversibleElems = $();\n    if (mutationObserver) {\n      mutationObserver.disconnect();\n      mutationObserver = null;\n    }\n  }\n\n  function start() {\n    refresh(document.body);\n\n    if (!mutationObserver) {\n      mutationObserver = new MutationObserver(onMutation);\n      mutationObserver.observe(document.body, { childList: true, subtree: true });\n    }\n  }\n\n  function onMutation(mutationRecords) {\n    mutationRecords.forEach(function(mutationRecord) {\n      var addedNodes = mutationRecord.addedNodes,\n        index = addedNodes.length;\n\n      while (index--) {\n        refresh(addedNodes[index]);\n      }\n    });\n  }\n\n  function refresh(root) {\n\n    function onClassifiedAsReversible(elem) {\n      $allReversibleElems.add(elem);\n      reverseElems($(elem), true);\n    }\n\n    classifyIframes(root, onClassifiedAsReversible);\n    imgClassifier.classify(root, onClassifiedAsReversible);\n  }\n\n  // Invert image or element via CSS filter: invert(1)\n  function reverseElemCss($img, doReverse) {\n    var savedFilter = $img.attr('data-sc-filter'),\n        styles      = {};\n    if (doReverse) {\n      // Add filter\n      if (savedFilter === null) {\n        $img.attr('data-sc-filter', $img.css(filterProperty));\n      }\n      styles[filterProperty] = 'invert(1)';\n    }\n    else {\n      // Clear filter\n      styles[filterProperty] = savedFilter || '';\n    }\n    inlineStyle.override($img.get(), styles);\n  }\n\n  // Invert image via our reversal proxy web service\n  function reverseElemProxy($img, doReverse, currentSrc) {\n    var savedSrc = $img.attr('data-sc-src');\n    if (doReverse) {\n      // Add proxied src\n      if (!savedSrc) {\n        // First time\n        currentSrc = $img.attr('src');\n        $img.attr('data-sc-src', currentSrc);\n        savedSrc = currentSrc;\n      }\n\n      invertUrl.getInvertUrl(savedSrc)\n        .then(function(newUrl) {\n          $img.attr('src', newUrl);\n        });\n    }\n    else {\n      // Clear proxied src\n      $img.attr('src', savedSrc || '');\n    }\n  }\n\n  function reverseElems($elems, doReverse) {\n    $elems.each(function () {\n      var\n        src = this.getAttribute('src') || '',\n        // The image proxy can't handle svg images\n        isSVG = imgClassifier.isSVGSource(src),\n        reverseElem = (src && !isSVG && SHOULD_USE_PROXY) ? reverseElemProxy : reverseElemCss;\n      reverseElem($(this), doReverse, src);\n    });\n  }\n\n  function classifyIframes(root, reverseCallbackFn) {\n    var $root = $(root),\n    //NOT_REVERSIBLE_FRAME_REGEX = /.*youtube|.*\\.vine\\.|\\.eplayer/,\n      REVERSIBLE_FRAME_REGEX = /twitter/,\n      $iframes;\n\n    function isReversibleFilter(index, elem) {\n      return elem.getAttribute('data-sc-reversible') === 'true' ||\n        elem.getAttribute('allowtransparency') === 'true' ||\n        (elem.src && elem.src.match(REVERSIBLE_FRAME_REGEX));\n    }\n\n    $iframes = $root.find('iframe').filter(isReversibleFilter);\n\n    if (root.localName === 'iframe' && isReversibleFilter(0, root)) {\n      $iframes.add(root);\n    }\n\n    $iframes.each(function() {\n      reverseCallbackFn(this);\n    });\n  }\n\n  function isReversibleBg(style) {\n    // Return a promise to a CSS text for reversed sprites\n    return style.value.doReverse;\n  }\n\n  // Reverse background images\n  function getCssForOneSprite(style) {\n    var imageUrl = style.value.imageUrl,\n      selector = style.rule.selectorText;\n    return invertUrl.getInvertUrl(imageUrl)\n      .then(function(newUrl) {\n        return selector + '{\\n' +\n          'background-image: url(' + newUrl + ') !important;\\n' +\n          '}\\n';\n      });\n  }\n\n  // No longer needed once we kill off Chrome <= 52 and Safari <= 9.2\n  // At that point it will only be 'filter'\n  function getFilterProperty() {\n    var\n      div = document.createElement('div'),\n      divStyle = inlineStyle(div);\n    divStyle.filter = 'invert(1)';\n    return divStyle.filter ? 'filter' : platform.cssPrefix + 'filter';\n  }\n\n  function toggleSheet(sheet, isDisabled) {\n    sheet.disabled = isDisabled;\n  }\n\n  // Return a promise that inversions are ready to use\n  function init(themeStyles) {\n    // Already initialized?\n    if (inverseSpriteSheet) {\n      return Promise.resolve();\n    }\n\n    // Not initialized yet\n\n    // The filter value doesn't work in IE, and is *extremely* slow in Safari\n    // It does work well in Edge, Chrome and Firefox\n    SHOULD_USE_PROXY = platform.browser.isIE || platform.browser.isSafari;\n    filterProperty = getFilterProperty();\n\n    function classifyBgImages() {\n      return new Promise(function(resolve) {\n        // Update theme styles with bg info\n        var bgImageStyles = themeStyles.filter(isBgImageStyle),\n          numImagesRemainingToClassify = bgImageStyles.length;\n\n        function isBgImageStyle(info) {\n          return info.value.prop === 'background-image';\n        }\n\n        function nextImage() {\n          if (numImagesRemainingToClassify-- === 0) {\n            resolve();\n          }\n        }\n\n        nextImage();  // In case we started with zero images\n\n        bgImageStyles.forEach(function (bgImageInfo) {\n          bgImgClassifier.classifyBackgroundImage(bgImageInfo, nextImage);\n        });\n      });\n    }\n\n    function getReverseSpriteCssText() {\n      var reversibleBgStyles = themeStyles.filter(isReversibleBg);\n\n      return Promise.all(reversibleBgStyles.map(getCssForOneSprite))\n        .then(function(allCss) {\n          return allCss.join('\\n');\n        });\n    }\n\n    // Create inverseSpriteSheet only once\n    return origBgInfo.init(themeStyles)\n      .then(classifyBgImages)\n      .then(getReverseSpriteCssText)\n      .then(function(inverseSpriteCss) {\n        inverseSpriteCss = '@media screen {\\n' + inverseSpriteCss + '\\n}'; // Do not use in print!\n        var $sheet = styleService.updateSheet(INVERSE_SPRITE_STYLESHEET_ID, { text : inverseSpriteCss } );\n        return new Promise(function(resolve) {\n          styleService.getDOMStylesheet($sheet, resolve);\n        });\n      })\n      .then(function(domStyleSheet) {\n        inverseSpriteSheet = domStyleSheet;\n      });\n  }\n\n  return {\n    init: init,\n    toggle: toggle\n  };\n});\n\n","\nsitecues.define(\"inverter\", function(){});\n"]}