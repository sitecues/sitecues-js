{"version":3,"sources":["../../config-wrap-start-default.js","audio/constant.js","audio/speech-builder.js","audio/text-select.js","audio/local-player.js","audio/network-player.js","audio/audio.js","../../../../../../module-create.js"],"names":["sitecues","define","TRIGGER_TYPES","LENS","HIGHLIGHT","SELECTION","speechStrategy","AUTO","LOCAL","NETWORK","PREFER_LOCAL","PREFER_NETWORK","REROUTE_NETWORK_SPEECH_KEY","AVAILABLE_CUES","ar","de","en","es","fr","pl","sv","autoStrategy","SC_AUTO_SPEECH","$","urls","textBuffer","TEXT_NODE","ELEMENT_NODE","getText","selector","each","appendBlockSeparator","appendAccessibleTextFromSubtree","this","replace","trim","appendText","text","findElement","id","isMap","document","querySelector","appendFromIdListAttribute","$node","attrName","ids","idCount","target","idList","attr","split","length","lastChar","slice","IS_LETTER_REGEX","match","appendWithWordSeparation","IS_WHITESPACE_REGEX","isSelectedOption","index","option","selected","hasMatchingTag","tags","element","hasOwnProperty","localName","VISUAL_MEDIA_ELEMENTS","img","picture","canvas","video","embed","object","iframe","frame","audio","isVisualMedia","getImageText","node","getAttribute","isImage","is","appendNonLabelText","styles","display","doWalkChildren","isHidden","visibility","children","getInputLabelAttributeText","appendTextEquivAndValue","value","ariaLabel","textEquiv","filter","isLabel","hasNewline","hasExtraSpace","nodeType","nodeValue","window","getComputedStyle","parseFloat","paddingRight","marginRight","src","isCrossOrigin","contents","events","constant","nativeGlobal","wasOn","speakSelectedTextOnDelay","event","isInPanel","setTimeout","speakSelectedText","closest","selection","getSelection","selectedText","toString","focusNode","require","speakText","refresh","isOn","addEventListener","removeEventListener","init","on","Promise","speechSynthesis","SpeechSynthesisUtterance","getVoices","errMessage","NO_VOICES","TIMEOUT","waitForVoices","resolve","reject","onTimeout","Error","voicesTimeout","onVoicesChanged","clearTimeout","currentTarget","type","voices","getBestVoice","locale","lang","acceptableVoices","voice","voiceLocale","startsWith","SC_BROWSER_NETWORK_SPEECH","localService","sort","compareVoices","a","b","aLocale","bLocale","default","stop","cancel","speak","prom","then","bestVoice","polite","speech","onStart","removeListeners","onSpeechEnd","onSpeechError","SC_DEV","console","log","elapsedTime","error","speakPolitely","Object","create","isBusy","pending","speaking","site","audioElementsToPlay","ERR_NO_NETWORK_TTS","play","url","audioElement","Audio","isSpeech","push","beginRequest","getNetworkSpeechConfig","speechConfig","ttsAvailable","releaseAudioElement","one","onCanPlay","onEnded","indexOf","splice","$audioElement","off","forEach","pause","callbackFn","cached","isRetrieving","fetchNetworkSpeechConfig","xhr","getJSON","getApiUrl","getSiteId","success","data","currentSetting","origSettings","settings","i","key","pref","builder","metric","textSelect","dataMap","localPlayer","networkPlayer","lastPlayer","isInitialized","ttsOn","AUDIO_BUSY_EVENT","onLensOpened","lensContent","fromHighlight","speakContentImpl","picked","speakContent","content","doAvoidInterruptions","$content","triggerType","stopAudio","rootNode","startRequestTime","Date","now","textLocale","getAudioLocale","addStopAudioHandlers","onSpeechPlaying","isLocal","timeElapsed","TtsRequest","requestTime","audioFormat","getMediaTypeForNetworkAudio","charCount","trigger","isLocalTTS","send","speakLocally","onUnavailable","onUnavailableFn","fireNotBusyEvent","isLocalSpeechAllowed","fireBusyEvent","catch","speakViaNetwork","isNetworkSpeechAllowed","ttsUrl","getTTSUrl","rerouteNetworkSpeechLang","speakViaNetworkFn","SC_LOCAL","isLocalSpeechPreferred","removeBlurHandler","emit","optionalStartNode","toPreferredRegion","contentLocale","swapToPreferredRegion","translationLocale","getTranslationLocale","body","parentElement","nodeLocale","isValidLocale","getPageLocale","getAudioCueTextAsync","cueName","cueTextLocale","callback","AUDIO_CUE_DATA_PREFIX","cueModuleName","get","toCueTextLocale","cueAudioLocale","toLowerCase","useIfAvailable","tryLocale","getLocaleParameter","getCueUrl","name","restOfUrl","encodeURIComponent","setSpeechState","doSuppressAudioCue","set","audioCues","playSpeechCue","toggleSpeech","speakCueByName","cueText","playEarcon","earconName","resolveResourceUrl","getBrowserSupportedTypeFromList","listOfAvailableExtensions","audioApi","MEDIA_TYPES","ogg","mp3","e","extension","canPlayType","isSpeechEnabled","getClientSpeechStrategy","strategy","clientSpeechStrategy","getRerouteNetworkSpeechLangKey","sessionStorage","getItem","setItem","ex","SPEECH_BEGIN_EVENT","setSpeechStrategy","newStrategy"],"mappings":"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","file":"audio.js.map","sourcesContent":["\"use strict\";\n","sitecues.define(\n  'audio/constant',[],\n  function () {\n    // TODO add more trigger types, e.g. shift+arrow, shift+space\n    var TRIGGER_TYPES = {\n      LENS: 'space',\n      HIGHLIGHT: 'shift',\n      SELECTION: 'selection'\n    },\n    speechStrategy = {\n      AUTO    : 'auto', // Currently same as PREFER_NETWORK\n      LOCAL   : 'local',\n      NETWORK : 'network',\n      PREFER_LOCAL : 'preferLocal',\n      PREFER_NETWORK : 'preferNetwork'\n    };\n\n    return {\n      TRIGGER_TYPES: TRIGGER_TYPES,\n      REROUTE_NETWORK_SPEECH_KEY : '-sc-reroute-network-tts-',\n      AVAILABLE_CUES : { 'ar': 1, 'de': 1, 'en': 1, 'es': 1, 'fr': 1, 'pl': 1, 'sv': 1 },\n      speechStrategy : speechStrategy,\n      // jshint -W117\n      autoStrategy : SC_AUTO_SPEECH || speechStrategy.PREFER_NETWORK\n    };\n  }\n);\n\n","/**\n * Given a DOM node to speak, this builds a string for speech output.\n * It handles accessibility concerns such as alternative text.\n * Currently the speech dictionary resides here until we can move it to the server.\n */\n\nsitecues.define(\n  'audio/speech-builder',[\n    '$',\n    'run/conf/urls'\n  ],\n  function (\n    $,\n    urls\n  ) {\n  'use strict';\n\n  var textBuffer = '',\n    TEXT_NODE = 3,\n    ELEMENT_NODE = 1;\n\n\n  /**\n   * Get all the text to be spoken for a given selector, taking into account line breaks, form values and alternative text\n   * @access public\n   * @param selector Element or jQuery object with nodes to get speakable text for\n   * @returns {*}\n   */\n  function getText(selector) {\n    textBuffer = '';\n    $(selector).each(function() {\n      if (textBuffer) {\n        appendBlockSeparator();\n      }\n      appendAccessibleTextFromSubtree(this);\n    });\n\n    // Replace multiple whitespace chars with a single space so that GET request is not too large\n    textBuffer = textBuffer.replace( /\\s\\s+/g, ' ');\n    // Remove any space at beginning or end of string\n    return textBuffer.trim();\n  }\n\n  function appendText(text) {\n    textBuffer = textBuffer + text;\n  }\n\n  function findElement(id, isMap) {\n    return document.querySelector(isMap? 'map[name=\"' + id.replace('#','') + '\"]' : '#' + id);\n  }\n\n  function appendFromIdListAttribute($node, attrName) {\n    var idList = $node.attr(attrName), ids, id, idCount, target, isMap = attrName === 'usemap';\n    if (idList) {\n      ids = idList.split(' ');\n      for (idCount = 0; idCount < ids.length; idCount ++) {\n        id = ids[idCount];\n        target = findElement(id, isMap);\n        if (target) {\n          appendText(' ');\n          appendAccessibleTextFromSubtree(target, true);\n          appendText(' ');\n        }\n      }\n    }\n  }\n\n  /**\n   * Add \" . \" between blocks if the previous block did not end the sentence, to avoid combining 2 sentences into 1.\n   * Or, if the sentence already ended, add \" \" between blocks to ensure words are not jammed together into one word.\n   * This string is magical, at least in Ivona.\n   * We tried '. ' but it caused abbreviations to be expanded (e.g. \"No.\" is spoken as \"Number\").\n   * Also tried \"; \" and \"! \" but these caused the block of text to be read with a slightly rising pitch at the end.\n   * The ' . ' seems to do a good job of ending the sentence without causing abbreviation expansion or pitch changes.\n   * (If this ends up causing 'dot' to be spoken we can try ';. ' which also seemed to work but was weirder).\n   * @param {string} original text\n   */\n  function appendBlockSeparator() {\n    if (!textBuffer) {\n      return;\n    }\n    var lastChar = textBuffer.slice(-1),\n      IS_LETTER_REGEX = /[\\w\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]/; // Shortest way to test if char is a letter\n    if (lastChar.match(IS_LETTER_REGEX)) {\n      appendText(' . ');  // Ended in a letter, so add sentence marker so that TTS engine can treat it as a sentence\n    }\n    else {\n      appendText(' ');  // Did not end in a letter, but add space so that text from the two blocks not jammed together\n    }\n  }\n\n  /**\n   * Append text and additional spaces, if necessary, to separate it from other text\n   * @param text  The new text that will be appended\n   */\n  function appendWithWordSeparation(text) {\n    var lastChar = textBuffer.slice(-1),\n      IS_WHITESPACE_REGEX = /[ \\r\\n\\t]/;\n    if (lastChar && text && !lastChar.match(IS_WHITESPACE_REGEX)) {\n      appendText(' ');\n    }\n    appendText(text.trim() + ' ');\n  }\n\n  function isSelectedOption(index, option) {\n    return option.selected;\n  }\n\n  function hasMatchingTag(tags, element) {\n    return tags.hasOwnProperty(element.localName);\n  }\n\n  /**\n   * Checks if the element has media contents which can be rendered.\n   * TODO Use element-classifier.isVisualMedia()\n   */\n  var VISUAL_MEDIA_ELEMENTS = { img:1, picture:1, canvas:1, video:1, embed:1, object:1, iframe:1, frame:1, audio:1 };\n  function isVisualMedia(element) {\n    return hasMatchingTag(VISUAL_MEDIA_ELEMENTS, element);\n  }\n\n  function getImageText(node) {\n    return node.getAttribute('alt') || node.getAttribute('title') || '';\n  }\n\n  function isImage($node) {\n    return isVisualMedia($node[0]) || $node.is('input[type=\"image\"]');\n  }\n\n  function appendNonLabelText($node, styles) {\n    // CSS display: none -- hides entire subtree\n    if (styles.display === 'none') {\n      return; // Don't walk subtree, the entire thing is hidden\n    }\n\n    // CSS visibility -- child elements might still be visible, need to check each one\n    var isHidden = styles.visibility !== 'visible',\n      doWalkChildren;\n    if (isHidden) {\n      $node.children().each(function() {\n        appendAccessibleTextFromSubtree(this);\n      });\n      return;\n    }\n\n    doWalkChildren = true;\n\n    if ($node.attr('aria-labelledby')) {\n      // Check for label pointed to but only if not already in the middle of doing that\n      appendFromIdListAttribute($node, 'aria-labelledby');\n      doWalkChildren = false; // ARIA markup overrides the accessible name. We use that instead of creating the name via descendants.\n    }\n    else if ($node.is('img')) {\n      // If it has @usemap, add any alternative text from within the map\n      appendFromIdListAttribute($node, 'usemap');\n    }\n\n    // Append description\n    appendFromIdListAttribute($node, 'aria-describedby');\n\n    return doWalkChildren;\n  }\n\n  function getInputLabelAttributeText(node) {\n    return node.getAttribute('placeholder') || node.getAttribute('title') || '';\n  }\n\n  function appendTextEquivAndValue(node, $node, doWalkChildren) {\n    // Process 'text equivalents' which are attributes that contain additional descriptive text\n    // Note: unlike most text equivalent attributes, aria-label is supported on any element. It is different from\n    // aria-labelledby in that it directly contains the necessary text rather than point to an element by id.\n    var ariaLabel = node.getAttribute('aria-label'),\n      textEquiv = ariaLabel,\n      value;\n\n    // alt or title on any image or visual media\n    if (isImage($node)) {\n      textEquiv = textEquiv || getImageText(node);\n    }\n    else if ($node.is('select')) {\n      textEquiv = node.getAttribute('title') || '';\n      value = $node.children().filter(isSelectedOption).text();\n      doWalkChildren = false; // Otherwise will read all the <option> elements\n    }\n\n    else if ($node.is('input[type=radio],input[type=checkbox],button')) {\n      // value, and title on these form controls\n      textEquiv = textEquiv || node.getAttribute('title') || '';\n    }\n\n    else if ($node.is('input:not([type=\"password\"]),textarea')) {\n      // value, placeholder and title on these form controls\n      textEquiv = textEquiv || getInputLabelAttributeText(node);\n      value = node.value;\n    }\n\n    if (ariaLabel) {\n      // ARIA markup defined an accessible name, which overrides other labels.\n      // No need to keep adding to the accessible name via descendants or other attributes\n      textEquiv = ariaLabel;\n      doWalkChildren = false;\n    }\n\n    if (textEquiv !== null) {\n      appendWithWordSeparation(textEquiv);\n    }\n    if (value) {\n      appendWithWordSeparation(value);\n    }\n\n    return doWalkChildren;\n  }\n\n  // Add all the accessible text from the pointed-to subtree of elements\n  // isLabel prevents infinite recursion when getting label from elsewhere in document, potentially overlapping\n  function appendAccessibleTextFromSubtree(node, isLabel) {\n    var styles,\n      $node = $(node),\n      doWalkChildren = true,\n      hasNewline,\n      hasExtraSpace;\n\n    node = $node[0];\n\n    if (node.nodeType === TEXT_NODE) {\n      // Text node: we append the text contents\n      appendText(node.nodeValue);\n      return;\n    }\n\n    if (node.nodeType !== ELEMENT_NODE) {\n      return; // Not text or an element, we don't care about it\n    }\n\n    // Element -- check for special requirements based on element markup\n    styles = window.getComputedStyle(node);\n\n    // Non-label processing:\n    // 1) Visibility checks -- we don't do this for labels because even invisible labels should be spoken, it's a\n    //    common technique to hide labels but have useful text for screen readers\n    // 2) ARIA labels and descriptions: don't use if already inside a label, in order to avoid infinite recursion\n    //    since labels could ultimately point in a circle.\n    if (!isLabel && !appendNonLabelText($node, styles)) {\n      return;\n    }\n\n    // Add characters to break up paragraphs (before block)\n\n    hasNewline = styles.display !== 'inline';\n    if (hasNewline) {\n      textBuffer = textBuffer.trim();\n      appendBlockSeparator();\n    }\n    else {\n      hasExtraSpace = parseFloat(styles.paddingRight) || parseFloat(styles.marginRight);\n    }\n\n    doWalkChildren = appendTextEquivAndValue(node, $node, doWalkChildren);\n\n    if (node.localName === 'iframe' && node.src && urls.isCrossOrigin(node.src)) {\n      // Don't try to access the nested document of cross origin iframes\n      return;\n    }\n\n    if (doWalkChildren) {\n      // Recursively add text from children (both elements and text nodes)\n      $node.contents().each(function () {\n        appendAccessibleTextFromSubtree(this, isLabel);\n      });\n    }\n\n    if (hasNewline) {\n      textBuffer = textBuffer.trim();\n      appendBlockSeparator(); // Add characters to break up paragraphs (after block)\n    }\n    else if (hasExtraSpace) {\n      appendText(' ');\n    }\n  }\n\n  return {\n    getText : getText\n  };\n\n\n});\n\n","/**\n * If speech is on, automatically speak newly selected regions in document.\n * Created by akhabibullina on 8/3/2015.\n */\nsitecues.define(\n  'audio/text-select',[\n    '$',\n    'run/events',\n    'audio/constant',\n    'mini-core/native-global'\n  ],\n  function (\n    $,\n    events,\n    constant,\n    nativeGlobal\n  ) {\n  'use strict';\n\n  var wasOn = false;\n\n  // Speaking on a delay after mouseup avoids speaking the same thing twice\n  function speakSelectedTextOnDelay(event) {\n    if (!isInPanel(event.target)) {\n      nativeGlobal.setTimeout(speakSelectedText, 0);\n    }\n  }\n\n  function isInPanel(element) {\n    return $(element).closest('#sitecues-badge,#scp-bp-container').length > 0;\n  }\n\n  function speakSelectedText() {\n    // TODO get the selected nodes and concat all the text ourselves, so that we speak markup correctly, switch locales, etc.\n    // TODO this would also allow us to speak whole words (SC-3192)\n    var selection = window.getSelection(),\n      selectedText = selection.toString(),\n      focusNode = selection.focusNode;\n    // Listeners: speech.js\n    require(['audio/audio'], function(audio) {\n      // No need to init audio, because we're a dependency of it -- it inits us\n      // Anything currently being spoken will be interrupted and the new text will be spoken instead.\n      // This means that if an empty string is sent, speech will simply shut up.\n      // As a result, clicking somewhere new in the page will quiet the current speech.\n      audio.speakText(selectedText || '', focusNode, constant.TRIGGER_TYPES.SELECTION);\n    });\n  }\n\n  function refresh(isOn) {\n    if (wasOn === isOn) {\n      return;  // Has not changed\n    }\n\n    wasOn = isOn;\n\n    if (isOn) {\n      document.addEventListener('mouseup', speakSelectedTextOnDelay);\n    }\n    else {\n      document.removeEventListener('mouseup', speakSelectedTextOnDelay);\n    }\n  }\n\n  function init() {\n    refresh(true);  // We only get init'd if TTS is turned on, so assume it's on\n    events.on('speech/did-change', refresh);\n  }\n\n  return {\n    init: init\n  };\n});\n\n","// This module is responsible for creating audio snippets of synthetic speech,\n// natively in the browser, completely offline.\nsitecues.define(\n  'audio/local-player',[\n    'Promise',\n    'mini-core/native-global'\n  ],\n  function (\n    Promise,\n    nativeGlobal\n  ) {\n  'use strict';\n\n    var\n      speechSynthesis = window.speechSynthesis,\n      SpeechSynthesisUtterance = window.SpeechSynthesisUtterance;\n\n    function getVoices() {\n\n      var\n        errMessage = {\n          NO_VOICES : 'Sitecues cannot find voices to speak with.',\n          TIMEOUT   : 'Timed out getting voices. The system may not have any.'\n        };\n\n      // Promise handler for when loading voices is asynchronous.\n      function waitForVoices(resolve, reject) {\n        // Handle timeouts so we don't wait forever in any case where\n        // the voiceschanged event never fires.\n        function onTimeout() {\n          reject(new Error(errMessage.TIMEOUT));\n        }\n\n        // Don't wait forever for a voice.\n        var voicesTimeout = nativeGlobal.setTimeout(onTimeout, 3000);\n\n        // At least one voice has loaded asynchronously. We don't know if/when\n        // any more will come in, so it is best to consider the job done here.\n        function onVoicesChanged(event) {\n          clearTimeout(voicesTimeout);\n          // Give the available voices as the result.\n          resolve(speechSynthesis.getVoices());\n          // Remove thyself.\n          event.currentTarget.removeEventListener(event.type, onVoicesChanged, true);\n        }\n\n        speechSynthesis.addEventListener('voiceschanged', onVoicesChanged, true);\n      }\n\n      // Tickle the browser with a feather to get it to actually load voices.\n      // In some environments this happens synchronously and we can use the\n      // result right away. In others, it returns an empty array and we will\n      // take care of that during the voiceschanged event.\n      var voices = speechSynthesis.getVoices();\n\n      // If the browser has voices available right now, return those.\n      // Safari gets voices synchronously, so will be true there.\n      if (voices.length > 0) {\n        return Promise.resolve(voices);\n      }\n\n      // If the browser gave us an empty voice list, it may mean that an async\n      // load of voices is not yet complete. At least Chrome 44 does this in a\n      // very annoying way: we must call speechSynthesis.getVoices() to begin\n      // loading voices, but it returns a useless empty array synchronously,\n      // with no option for a callback or promise. We must then listen to the\n      // 'voiceschanged' event to determine when at least one voice is ready.\n      // Who knows when they all are! Grrr. See errata 11 in the spec:\n      // https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi-errata.html\n      else if (typeof speechSynthesis.addEventListener === 'function') {\n        return new Promise(waitForVoices);\n      }\n\n      // In theory, a platform could support the synthesis API but not have any\n      // voices available. Or all the voices could suddenly be uninstalled.\n      // We have not encountered that, but we try to take care of it here.\n      return Promise.reject(\n          new Error(errMessage.NO_VOICES)\n      );\n    }\n\n    // Based on a given set of voices and locale restrictions, get sitecues'\n    // favorite voice. We want to sound the best.\n    function getBestVoice(option) {\n\n      var\n        voices = option.voices,\n        locale = option.locale,\n        lang = locale.split('-')[0];\n\n      var acceptableVoices = voices.filter(function (voice) {\n          var voiceLocale = voice.lang;\n          // Allow universal speech engines, which exist on Windows. These can\n          // speak just about any language.\n          if (!voiceLocale) {\n            return true;\n          }\n          return voiceLocale === lang || voiceLocale.startsWith(lang + '-');\n        }).filter(function (voice) {\n          return SC_BROWSER_NETWORK_SPEECH || voice.localService;\n        });\n\n      if (acceptableVoices.length > 0) {\n        return acceptableVoices.sort(compareVoices)[0];\n      }\n\n      throw new Error('No local voice available for ' + locale);\n\n      function compareVoices(a, b) {\n\n        var\n          aLocale = a.lang,\n          bLocale = b.lang;\n\n        // Prefer voices with the perfect accent (or lack thereof).\n        if (aLocale === locale && bLocale !== locale) {\n          return -1;\n        }\n        if (bLocale === locale && aLocale !== locale) {\n          return 1;\n        }\n\n        // Prefer to respect the user's default voices.\n        if (a.default && !b.default) {\n          return -1;\n        }\n        if (b.default && !a.default) {\n          return 1;\n        }\n\n        // Prefer voices without an accent, to avoid mapping one accent to\n        // another if at all possible.\n        if (aLocale === lang && bLocale !== lang) {\n          return -1;\n        }\n        if (bLocale === lang && aLocale !== lang) {\n          return 1;\n        }\n      }\n    }\n\n    // Stop speech. This method is idempotent. It does not matter if we are\n    // currently playing or not.\n    function stop() {\n      speechSynthesis.cancel();\n    }\n\n    // Turn text into speech.\n    function speak(option) {\n\n      var\n        // TODO: Replace this poor excuse for a speech dictionary.\n        text = option.text.replace(/sitecues/gi, 'sightcues').trim(),\n        locale  = option.locale;\n\n      var\n        voice = option.voice,\n        prom = Promise.resolve();\n\n      if (!text) {\n        return prom;\n      }\n\n      if (!voice) {\n        prom = getVoices().then(function (voices) {\n            return getBestVoice({\n              voices : voices,\n              locale : locale\n            });\n          })\n          .then(function (bestVoice) {\n            voice = bestVoice;\n          });\n      }\n\n      // By default, the Web Speech API queues up synthesis requests.\n      // But this is typically not what is desired by sitecues.\n      if (!option.polite) {\n        // Immediately discontinue any currently playing speech.\n        stop();\n      }\n\n      // When and if we have a voice to use, finish setting up\n      // and then play speech.\n      prom = prom.then(function () {\n        return new Promise(function (resolve, reject) {\n\n          var speech = new SpeechSynthesisUtterance(text);\n\n          speech.voice = voice;\n          // Note: Some voices do not support altering these settings and will break silently!\n          speech.lang = locale;\n          // speech.voiceURI = 'native';\n          // speech.volume = 1;  // float from 0 to 1, default is 1\n          // speech.rate   = 1;  // float from 0 to 10, default is 1\n          // speech.pitch  = 1;  // float from 0 to 2, default is 1\n\n          // Event listeners...\n\n          var onStart = option.onStart;\n\n          if (onStart) {\n            speech.addEventListener('start', onStart);\n          }\n\n          function removeListeners() {\n            if (onStart) {\n              speech.removeEventListener('start', onStart);\n            }\n            speech.removeEventListener('end', onSpeechEnd);\n            speech.removeEventListener('error', onSpeechError);\n          }\n\n          function onSpeechEnd() {\n            if (SC_DEV) {\n              console.log('Finished in ' + event.elapsedTime + ' seconds.');\n            }\n            removeListeners();\n            resolve();\n          }\n\n          function onSpeechError(event) {\n            removeListeners();\n            reject(event.error);\n          }\n\n          speech.addEventListener('end', onSpeechEnd);\n          speech.addEventListener('error', onSpeechError);\n\n          // Examples of other things we could do:\n          // speech.addEventListener('resume', function onSpeechResume(event) {\n          //     console.log('Speech has resumed from a paused state.');\n          // });\n          // speech.addEventListener('boundary', function onSpeechBoundary(event) {\n          //     console.log('Encountered a word or sentence boundary.');\n          // });\n          // speech.addEventListener('mark', function onSpeechMark(event) {\n          //     console.log('Encountered an SSML mark tag.');\n          // });\n\n          speechSynthesis.speak(speech);\n        });\n      });\n\n      return prom;\n    }\n\n    // \"Polite\" mode means wait your turn and let others finish speaking.\n    // It adds speech to the queue and does not play it immediately.\n    function speakPolitely(option) {\n      option = Object.create(option);\n      option.polite = true;\n      speak(option);\n    }\n\n    // NOTE: This method will be fooled by another app besides sitecues speaking.\n    //       Prefer to keep track of state based on the promise from speak().\n    function isBusy() {\n      return speechSynthesis.pending || speechSynthesis.speaking;\n    }\n\n    return {\n      stop          : stop,\n      speak         : speak,\n      speakPolitely : speakPolitely,\n      isBusy        : isBusy\n    };\n  }\n);\n\n","/**\n * This is the audio player we use for remote speech and anything\n * that is not speech.\n */\nsitecues.define('audio/network-player',['$', 'run/conf/urls', 'run/conf/site', 'Promise' ], function ($, urls, site, Promise) {\n\n  var audioElementsToPlay = [],\n    ERR_NO_NETWORK_TTS = 'Sitecues network speech is not available on this website.';\n\n  /**\n   * Retrieve and play audio from a URL.\n   * @param option, settings such as source of audio to play\n   */\n  function play(option) {\n    var\n      url = option.url,\n      onStart = option.onStart,\n      audioElement = new Audio(),\n      isSpeech = option.isSpeech;\n\n    audioElementsToPlay.push(audioElement);\n\n    if (!isSpeech) {\n      // No need to check network speech config for playing earcons\n      return new Promise(beginRequest);\n    }\n\n    return new Promise(function(resolve, reject) {\n      getNetworkSpeechConfig(function (speechConfig, error) {\n        if (speechConfig.ttsAvailable) {\n          beginRequest(resolve, reject);\n        }\n        else {\n          // Fetched site config disallowed network speech\n          // This is a network setting as opposed to a client strategy\n          releaseAudioElement(audioElement);\n          reject(new Error(error || ERR_NO_NETWORK_TTS));\n        }\n      });\n    });\n\n    function beginRequest(resolve, reject) {\n      if (onStart) {\n        $(audioElement).one('playing', onStart);\n      }\n\n      // TODO: Can we remove this? Test across browsers.\n      audioElement.src = ''; // Clean up\n\n      $(audioElement).one('canplay', onCanPlay);\n      $(audioElement).one('error', function(event) {\n        onEnded(event);\n        reject(event);\n      });\n      $(audioElement).one('ended', function(event) {\n        onEnded(event);\n        resolve();\n      });\n      $(audioElement).one('pause', function(event) {\n        onEnded(event);\n        resolve();\n      });\n      audioElement.src = url;\n    }\n\n    function onCanPlay(event) {\n      var audioElement = event.target;\n      if (audioElementsToPlay.indexOf(audioElement) >= 0) {\n        // Still in list of <audio> elements to play -- has not been stopped\n        audioElement.play();\n      }\n    }\n\n    function releaseAudioElement() {\n      var index = audioElementsToPlay.indexOf(audioElement);\n      if (index >= 0) {\n        audioElementsToPlay.splice(index, 1);\n      }\n    }\n\n    function onEnded(event) {\n      var audioElement = event.target;\n      removeListeners(audioElement);\n      releaseAudioElement(audioElement);\n    }\n  }\n\n  // Busy when 1) pending network request, or 2) currently playing audio\n  function isBusy() {\n    return audioElementsToPlay.length > 0;\n  }\n\n  function removeListeners(audioElement) {\n    var $audioElement = $(audioElement);\n    $audioElement.off('canplay'); // Don't fire notification to play if we haven't played yet\n    $audioElement.off('error');\n    $audioElement.off('ended');\n    $audioElement.off('pause');\n  }\n\n  /**\n   * Stop any currently playing audio and abort the request\n   */\n  function stop() {\n    audioElementsToPlay.forEach(function(audioElement) {\n      audioElement.pause();  // Will be removed by pause handler (onEnded)\n    });\n    audioElementsToPlay.length = 0; // Need to remove synchronously so that we don't accidentally get double speech\n  }\n\n  function getNetworkSpeechConfig(callbackFn) {\n    if (getNetworkSpeechConfig.cached) {\n      // Already retrieved\n      callbackFn(getNetworkSpeechConfig.cached);\n      return;\n    }\n\n    if (getNetworkSpeechConfig.isRetrieving) {\n      // Currently retrieving -- this is a weird case -- as if network speech was requested again before the config was fetched\n      callbackFn({});\n      return;\n    }\n\n    getNetworkSpeechConfig.isRetrieving = true;\n\n    fetchNetworkSpeechConfig(function(speechConfig, error) {\n      getNetworkSpeechConfig.isRetrieving = false;\n      getNetworkSpeechConfig.cached = speechConfig;\n      callbackFn(speechConfig, error);\n    });\n  }\n\n  function fetchNetworkSpeechConfig(callbackFn) {\n    require(['run/util/xhr'], function(xhr) {\n      xhr.getJSON({\n        // The 'provided.siteId' parameter must exist, or else core would have aborted the loading of modules.\n        url: urls.getApiUrl('2/site/' + site.getSiteId() + '/config'),\n        success: function (data) {\n          var origSettings = data.settings,\n            currentSetting,\n            i = 0;\n          // Map the incoming format\n          // From:\n          //   [ { key: foo, value: bar}, { key: foo2, value: bar2} ... ] to\n          // To:\n          //   { key: bar, key2: bar2 }\n\n          // Copy the fetched key/value pairs into the speechConfig\n          var speechConfig = {};\n          for (; i < origSettings.length; i++) {\n            currentSetting = origSettings[i];\n            speechConfig[currentSetting.key] = currentSetting.value;\n          }\n          callbackFn(speechConfig);\n        },\n        error: function(error) {\n          callbackFn({}, error);\n        }\n      });\n    });\n  }\n\n  return {\n    play   : play,\n    stop   : stop,\n    isBusy : isBusy\n  };\n});\n\n\n","/**\n * This is the main audio library.  It manages all of the events\n * and requests and should be the only speech component referenced\n * by other parts of the application.\n *\n * Specifically, it is responsible for:\n * - Playing speech when HLB opens, if speech is on. In this case it must request\n *   a media type supported both by the server (provided via site preferences)\n * - Stopping speech when a key is pressed or the Lens closes\n * - Playing audio by key when requested by another module\n */\n\nsitecues.define(\n  'audio/audio',[\n    'audio/constant',\n    'run/conf/preferences',\n    'run/conf/site',\n    '$',\n    'audio/speech-builder',\n    'run/locale',\n    'run/metric/metric',\n    'run/conf/urls',\n    'audio/text-select',\n    'run/data-map',\n    'run/events',\n    'audio/local-player',\n    'audio/network-player'\n  ],\n  function(\n    constant,\n    pref,\n    site,\n    $,\n    builder,\n    locale,\n    metric,\n    urls,\n    textSelect,\n    dataMap,\n    events,\n    localPlayer,\n    networkPlayer\n  ) {\n  'use strict';\n\n  var ttsOn = false,\n    lastPlayer,\n    isInitialized,\n    AUDIO_BUSY_EVENT = 'audio/did-toggle',\n    speechStrategy = constant.speechStrategy;\n\n  function onLensOpened(lensContent, fromHighlight) {\n    if (ttsOn) {\n      speakContentImpl(fromHighlight.picked, constant.TRIGGER_TYPES.LENS);\n    }\n  }\n\n  function isBusy() {\n    return lastPlayer && lastPlayer.isBusy();\n  }\n\n  function speakContent(content, doAvoidInterruptions) {\n    if (doAvoidInterruptions && isBusy()) {\n      return; // Already reading the highlight\n    }\n    if (!content) {\n      return; // Nothing to read\n    }\n\n    speakContentImpl(content, constant.TRIGGER_TYPES.HIGHLIGHT);\n  }\n\n  function speakContentImpl($content, triggerType) {\n    stopAudio();\n\n    var text = builder.getText($content);\n    if (text) {\n      speakText(text, $content[0], triggerType);\n    }\n  }\n\n  // text and triggerType are optional\n  // @rootNode is root node of the text to be spoken, if available -- it will be used to get the locale\n  function speakText(text, rootNode, triggerType) {\n    stopAudio();  // Stop any currently playing audio and halt keydown listener until we're playing again\n    if (!text.trim()) {\n      return; // Nothing to speak\n    }\n\n    var startRequestTime = Date.now(),\n      textLocale = getAudioLocale(rootNode);\n    addStopAudioHandlers();\n\n    function onSpeechPlaying(isLocal) {\n      var timeElapsed = Date.now() - startRequestTime;\n      new metric.TtsRequest({\n        requestTime : timeElapsed,\n        audioFormat : isLocal ? null : getMediaTypeForNetworkAudio(),\n        charCount   : text.length,\n        trigger     : triggerType,\n        isLocalTTS  : isLocal\n      }).send();\n    }\n\n    function speakLocally(onUnavailable) {\n      var onUnavailableFn = onUnavailable || fireNotBusyEvent;\n      if (isLocalSpeechAllowed()) {\n        lastPlayer = localPlayer;\n        fireBusyEvent();\n        return localPlayer\n          .speak({\n            text: text,\n            locale: textLocale,\n            onStart: function () {\n              onSpeechPlaying(true);\n            }\n          })\n          .then(fireNotBusyEvent)\n          .catch(function() {\n            onUnavailableFn(); // Call with no arguments (don't pass on the error value)\n          });\n      }\n      else {\n        onUnavailableFn();\n      }\n    }\n\n    function speakViaNetwork(onUnavailable) {\n      var onUnavailableFn = onUnavailable || fireNotBusyEvent;\n      if (isNetworkSpeechAllowed(textLocale)) {\n        lastPlayer = networkPlayer;\n        fireBusyEvent();\n\n        var ttsUrl = getTTSUrl(text, textLocale);\n\n        networkPlayer\n          .play({\n            url: ttsUrl,\n            onStart: function () {\n              onSpeechPlaying(false);\n            }\n          })\n          .then(fireNotBusyEvent)\n          .catch(function() {\n            rerouteNetworkSpeechLang(textLocale);\n            onUnavailableFn();   // Call with no arguments (don't pass on the error value)\n          });\n      }\n      else {\n        onUnavailableFn();\n      }\n    }\n\n    var speakViaNetworkFn = SC_LOCAL ? fireNotBusyEvent : speakViaNetwork; // Helps the minifier\n\n    if (isLocalSpeechPreferred()) {\n      speakLocally(speakViaNetworkFn);\n    }\n    else {\n      speakViaNetworkFn(speakLocally);\n    }\n  }\n\n  function addStopAudioHandlers() {\n    // Stop speech on any key down.\n    // Wait a moment, in case it was a keystroke that just got us here,\n    // for example down arrow to read next Lens or a hotkey to toggle speech\n    removeBlurHandler();\n    $(window).one('blur', stopAudio);\n  }\n\n  // Remove handler that stops speech on any key down.\n  function removeBlurHandler() {\n    $(window).off('blur', stopAudio);\n  }\n\n  /*\n   * Stops the player that is attached to a highlight box.\n   * This is safe to call if the player has not been initialized\n   * or is not playing.\n   */\n  function stopAudio() {\n    if (isBusy()) {\n      lastPlayer.stop();\n      removeBlurHandler();\n    }\n  }\n\n  function fireBusyEvent() {\n    if (isBusy()) {\n      // Already fired\n      return;\n    }\n    events.emit(AUDIO_BUSY_EVENT, true);\n  }\n\n  function fireNotBusyEvent() {\n    if (isBusy()) {\n      // Still has other audio to play -- one of the players is still busy\n      return;\n    }\n    events.emit(AUDIO_BUSY_EVENT, false);\n  }\n\n  // Get language that applies to node (optional param), otherwise the document body\n  // If no locale found, falls back on document and then browser default language\n  // Returns a full country-affected language, like en-CA when the browser's language matches the site's language prefix.\n  // For example, if an fr-CA browser visits an fr-FR website, then fr-CA is returned instead of the page code,\n  // because that is the preferred accent for French.\n  // However, if the fr-CA browser visits an en-US or en-UK page, the page's code is returned because the\n  // user's preferred English accent in unknown\n  function getAudioLocale(optionalStartNode) {\n    function toPreferredRegion(contentLocale) {\n      return locale.swapToPreferredRegion(contentLocale);\n    }\n\n    // Get this first, because Google translate overwrites all text in the document, but not lang attributes\n    var translationLocale = locale.getTranslationLocale();\n    if (translationLocale) {\n      return toPreferredRegion(translationLocale);\n    }\n\n    var node = optionalStartNode || document.body;\n\n    if (node.nodeType !== node.ELEMENT_NODE) {\n      // May have started on text node\n      node = node.parentElement;\n    }\n\n    while (node) {\n      var nodeLocale = node.getAttribute('lang') || node.getAttribute('xml:lang');\n      if (nodeLocale && locale.isValidLocale(nodeLocale)) {\n        return toPreferredRegion(nodeLocale);\n      }\n      node = node.parentElement;\n    }\n\n    return toPreferredRegion(locale.getPageLocale());\n  }\n\n  function getAudioCueTextAsync(cueName, cueTextLocale, callback) {\n    var\n      AUDIO_CUE_DATA_PREFIX = 'locale-data/cue/',\n      cueModuleName = AUDIO_CUE_DATA_PREFIX + cueTextLocale;\n\n    dataMap.get(cueModuleName, function(data) {\n      callback(data[cueName] || '');\n    });\n  }\n\n  function toCueTextLocale(cueAudioLocale) {\n    var locale = cueAudioLocale.toLowerCase(),\n      lang = locale.split('-')[0];\n\n    function useIfAvailable(tryLocale) {\n      return constant.AVAILABLE_CUES[tryLocale] && tryLocale;\n    }\n\n    return useIfAvailable(locale) || useIfAvailable(lang);\n  }\n\n  // Puts in delimiters on both sides of the parameter -- ? before and & after\n  // locale is a required parameter\n  function getLocaleParameter(locale) {\n    return '?l=' + locale + '&';\n  }\n\n  function getCueUrl(name, locale) {  // TODO why does an audio cue need the site id?\n    var restOfUrl = 'cue/site/' + site.getSiteId() + '/' +\n      name + '.' + getMediaTypeForNetworkAudio() + getLocaleParameter(locale);\n    return urls.getApiUrl(restOfUrl);\n  }\n\n  /**\n   * Get URL for speaking text\n   * @param text  Text to be spoken\n   * @param locale  required locale parameter\n   * @returns {string} url\n   */\n  function getTTSUrl(text, locale) {\n    var restOfUrl = 'tts/site/' + site.getSiteId() + '/tts.' + getMediaTypeForNetworkAudio() + getLocaleParameter(locale) + 't=' + encodeURIComponent(text);\n    return urls.getApiUrl(restOfUrl);\n  }\n\n  /**\n   * Turn speech on or off\n   * @param isOn Whether to turn speech on or off\n   */\n  function setSpeechState(isOn, doSuppressAudioCue) {\n    if (ttsOn !== isOn) {\n      ttsOn = isOn;\n      pref.set('ttsOn', ttsOn);\n      events.emit('speech/did-change', ttsOn);\n      if (!doSuppressAudioCue) {\n        require(['audio-cues/audio-cues'], function(audioCues) {\n          audioCues.playSpeechCue(ttsOn);\n        });\n      }\n    }\n  }\n\n  function toggleSpeech() {\n    setSpeechState(!ttsOn);\n  }\n\n  /*\n   * Uses a provisional player to play back audio by cue name, used for audio cues.\n   */\n  function speakCueByName(name) {\n    stopAudio();  // Stop any currently playing audio\n\n    var cueAudioLocale = getAudioLocale(); // Use document language for cue voice, e.g. en-US or en\n    addStopAudioHandlers();\n\n    function speakLocally(onUnavailable) {\n      var onUnavailableFn = onUnavailable || fireNotBusyEvent,\n        cueTextLocale = toCueTextLocale(cueAudioLocale);  // Locale for text (likely just the 2-letter lang prefix)\n      if (cueTextLocale && isLocalSpeechAllowed()) {\n        lastPlayer = localPlayer;\n        fireBusyEvent();\n        getAudioCueTextAsync(name, cueTextLocale, function (cueText) {\n          if (cueText) {\n            localPlayer\n              .speak({\n                text: cueText,\n                locale: cueAudioLocale\n              })\n              .then(fireNotBusyEvent)\n              .catch(function() {\n                onUnavailableFn();\n              });\n          }\n        });\n      }\n      else {\n        onUnavailableFn();\n      }\n    }\n\n    function speakViaNetwork(onUnavailable) {\n      var onUnavailableFn = onUnavailable || fireNotBusyEvent;\n      if (isNetworkSpeechAllowed(cueAudioLocale)) {\n        lastPlayer = networkPlayer;\n        fireBusyEvent();\n        var url = getCueUrl(name, cueAudioLocale);\n        networkPlayer\n          .play({\n            isSpeech: true,\n            url: url\n          })\n          .then(fireNotBusyEvent)\n          .catch(function() {\n            onUnavailableFn();\n          });\n      }\n      else {\n        onUnavailableFn();\n      }\n    }\n\n    var speakViaNetworkFn = SC_LOCAL ? fireNotBusyEvent : speakViaNetwork;\n\n    if (isLocalSpeechPreferred()) {\n      speakLocally(speakViaNetworkFn);\n    }\n    else {\n      speakViaNetworkFn(speakLocally);\n    }\n  }\n\n  function playEarcon(earconName) {\n    if (!SC_LOCAL) {\n      // TODO can we play earcons in the extension without the heavyweight network player?\n      stopAudio();\n\n      var url = urls.resolveResourceUrl('earcons/' + earconName + '.' + getMediaTypeForNetworkAudio());\n\n      networkPlayer.play({\n        url: url\n      });\n    }\n  }\n\n  function getBrowserSupportedTypeFromList(listOfAvailableExtensions) {\n    var audioApi,\n      index = 0,\n      MEDIA_TYPES = {\n        ogg : 'audio/ogg',\n        mp3 : 'audio/mpeg'\n        // aac : 'audio/aac'    // Not currently used\n      };\n\n    try {\n      audioApi = new Audio();\n    } catch (e) {}\n\n    if (audioApi) {\n      for (; index < listOfAvailableExtensions.length; index++) {\n        var extension = listOfAvailableExtensions[index];\n        if (audioApi.canPlayType(MEDIA_TYPES[extension])) {\n          return extension;\n        }\n      }\n    }\n\n    // Must be Safari version <= 6, because we don't support other browsers without Audio() support\n    return listOfAvailableExtensions.indexOf('aac') >= 0 ? 'aac' : 'mp3';  // Prefer aac, otherwise use mp3\n  }\n\n  // What audio format will we use for prerecorded audio?\n  function getMediaTypeForNetworkAudio() {\n    if (!getMediaTypeForNetworkAudio.cached) {\n      getMediaTypeForNetworkAudio.cached = getBrowserSupportedTypeFromList(['mp3','ogg']);\n    }\n    return getMediaTypeForNetworkAudio.cached;\n  }\n\n  /**\n   * Returns if TTS is enabled or not.  Always returns true or false.\n   */\n  function isSpeechEnabled() {\n    // Flag indicating that this site is enabled for TTS.\n    return ttsOn;\n  }\n\n  // Get the client's preferred speech strategy.\n  // This may not be the ultimate speech strategy used, because\n  // 1) network speech will not play if ttsAvailable = false in served site preferences\n  function getClientSpeechStrategy() {\n    if (SC_LOCAL) {\n      return speechStrategy.LOCAL;\n    }\n    if (!getClientSpeechStrategy.cached) {\n      getClientSpeechStrategy.cached = (site.get('speech') || {}).strategy || speechStrategy.AUTO;\n      if (getClientSpeechStrategy.cached === speechStrategy.AUTO) {\n        getClientSpeechStrategy.cached = constant.autoStrategy;\n      }\n      // if (SC_DEV) {\n      //   console.log('Speech strategy: ' + getClientSpeechStrategy.cached);\n      // }\n    }\n\n    return getClientSpeechStrategy.cached;\n  }\n\n  function isLocalSpeechAllowed() {\n    return getClientSpeechStrategy() !== speechStrategy.NETWORK && window.speechSynthesis;\n  }\n\n  function isLocalSpeechPreferred() {\n    var clientSpeechStrategy = getClientSpeechStrategy();\n    return clientSpeechStrategy === speechStrategy.LOCAL || clientSpeechStrategy === speechStrategy.PREFER_LOCAL;\n  }\n\n  function getRerouteNetworkSpeechLangKey(lang) {\n    return constant.REROUTE_NETWORK_SPEECH_KEY + lang;\n  }\n\n  function isNetworkSpeechAllowed(lang) {\n    return getClientSpeechStrategy() !== speechStrategy.LOCAL &&\n      !window.sessionStorage.getItem(getRerouteNetworkSpeechLangKey(lang));\n  }\n\n  // This language failed on the network -- disallow it for this tab (uses sessionStorage)\n  function rerouteNetworkSpeechLang(lang) {\n    // Set to any value to reroute this language to local speech\n    try {\n      window.sessionStorage.setItem(getRerouteNetworkSpeechLangKey(lang), true);\n    }\n    catch(ex) {}\n  }\n\n  function init() {\n\n    if (isInitialized) {\n      return;\n    }\n\n    isInitialized = true;\n\n    // Speak on text selection\n    textSelect.init();\n\n    /*\n     * Speak whenever the lens is opened, if speech is on, etc.\n     * Use a later speech fetch if local speech is preferred, because it makes the lens expansion animation janky.\n     * TODO: It would be better to always listen for 'hlb/did-create' here so that\n     *      speech synthesis happens during the opening animation.\n     *      Unfortunately, this currently causes browsers to choke\n     *      on the animation when using local speech. But that\n     *      may improve in time.\n     */\n    var SPEECH_BEGIN_EVENT = isLocalSpeechPreferred() ? 'hlb/ready' : 'hlb/did-create';\n    events.on(SPEECH_BEGIN_EVENT, onLensOpened);\n\n    /*\n     * A highlight box was closed.  Stop/abort/dispose of the player\n     * attached to it.\n     */\n    events.on('hlb/closed', stopAudio);\n\n    if (SC_DEV) {\n      // For debugging purposes\n      // Takes one of the strategies from audio/constant.js\n      sitecues.setSpeechStrategy = function setSpeechStrategy(newStrategy) {\n        getClientSpeechStrategy.cached = newStrategy;\n      };\n    }\n\n    ttsOn = pref.get('ttsOn');\n  }\n\n  return {\n    stopAudio: stopAudio,\n    setSpeechState: setSpeechState,\n    toggleSpeech: toggleSpeech,\n    isSpeechEnabled: isSpeechEnabled,\n    speakCueByName: speakCueByName,\n    speakContent: speakContent,\n    speakText: speakText,\n    playEarcon: playEarcon,\n    getTTSUrl: getTTSUrl,\n    init: init\n  };\n});\n\n","\nsitecues.define(\"audio\", function(){});\n"]}