{"version":3,"sources":["../../config-wrap-start-default.js","hlb/event-handlers.js","hlb/constants.js","hlb/styling.js","hlb/safe-area.js","hlb/positioning.js","hlb/dimmer.js","hlb/animation.js","hlb/hlb.js","../../../../../../module-create.js"],"names":["sitecues","define","$","wheelEventCallback","isCapturing","releaseWheelEvents","window","removeEventListener","captureWheelEvents","$hlb","event","deltaY","parseInt","wheelDeltaY","preventScroll","elem","scrollHeight","scrollTop","clientHeight","scrollBottom","scrollingDown","scrollingUp","scrolledToBottom","scrolledToTop","target","contains","preventDefault","returnValue","addEventListener","constants","HLB_WRAPPER_ID","HLB_ID","HLB_READY","MAX_ZINDEX","common","pref","inlineStyle","arrayUtil","defaultPadding","defaultBorder","transitionProperty","BACKGROUND_IMAGE_ANCESTOR_TRAVERSAL_COUNT","HLB_DEFAULT_BACKGROUND_COLOR","HLB_DEFAULT_TEXT_COLOR","HLB_IMAGE_DEFAULT_BACKGROUND_COLOR","HLBCSSBlacklist","HLBElementBlacklist","HLBAttributeBlacklist","defaultHLBStyles","position","zIndex","border","padding","margin","borderRadius","boxSizing","visibility","maxWidth","maxHeight","opacity","filterBlacklistedElements","find","join","remove","filterHiddenElements","$picked","hiddenElements","pickedElementIsListItem","is","pickedDescendants","get","hlbDescendants","children","SC_DEV","length","console","warn","forEach","element","index","filterStyles","i","removeProperty","filterAttributes","removeAttr","getDescendantStyles","$descendant","foundationDescendantStyle","styles","webkitTextFillColor","textDecoration","bottom","height","min-width","fontSize","parseFloat","lineHeight","indexOf","log","display","wordWrap","getBulletWidth","$element","elementComputedStyle","listStyleType","listStyleImage","isTransparent","style","charAt","getNonEmptyBackgroundImage","ancestorCount","backgroundStyles","$parents","parents","each","$ancestor","this","css","backgroundImage","backgroundRepeat","backgroundAttachment","getNonTransparentBackground","newBackgroundColor","getHLBBackgroundColor","backgroundColor","getHLBBackgroundImage","newBackgroundImage","getHLBLeftPadding","$foundation","computedStyle","getHLBDisplay","shouldRemovePadding","$child","initialHLBRect","childBoundingClientRect","getBoundingClientRect","childLeftPadding","childRightPadding","childTopPadding","childBottomPadding","width","left","right","top","getChildPadding","paddingStyles","zoom","paddingLeft","paddingRight","paddingTop","paddingBottom","initializeHLBElementStyles","cssText","getComputedStyleCssText","initializeHLBDescendantStyles","computedChildStyles","foundation","hlb","removeMargins","foundationNodes","hlbNodes","foundationNode","pop","hlbNode","initializeCloneStyle","concat","from","originalNode","cloneNode","$original","$clone","getComputedStyle","set","shouldRemoveHorizontalMargins","marginLeft","marginRight","$foundationDescendant","$children","parent","parentsUntil","parentCount","childCount","hasOverlap","boundingRects","j","push","setHLBChildTextColor","textColor","forceTextColor","parentBackgroundColor","color","getHLBStyles","highlight","originalElement","originalElementRect","calculatedHLBStyles","scrollLeft","borderStyles","borderColor","hasDarkBackgroundColor","highlightBorderColor","animationOptimizationStyles","willChange","backfaceVisibility","extend","filter","initializeStyles","getPropertyValue","HLB_SAFE_AREA","getUnsafePixels","hypotenuse","Math","sqrt","pow","innerHeight","innerWidth","getSafeZoneBoundingBox","unsafePixels","hlbStyling","elemClassifier","hlbSafeArea","originCSS","translateCSS","CHAR_WIDTH_LIMIT","isEditable","isVisualMedia","isFormControl","getChildWidth","child","sum","hlbBoundingRect","childBoundingRect","inheritedZoom","getInheritedZoom","leftDiff","leftSum","rightSum","addBack","borderRightWidth","borderLeftWidth","limitChildWidth","fixit","allHLBChildren","hlbClientWidth","childRect","hlbRect","scrollDiff","hlbElementRangeWidth","hlbElementContentRangeWidth","hlbElementRangeRect","document","createRange","borderLeftAndRight","selectNode","selectNodeContents","clientWidth","max","mitigateVerticalScroll","addVerticalScroll","fixOverflowWidth","isEligibleForConstrainedWidth","allowWrapping","hasSiblings","parentNode","childElementCount","isLonerElement","isLoner","closest","elemToCheckForSiblings","hasPositioningCss","float","testAllowWrapping","whiteSpace","getExtraLeftPadding","midPointDiff","rect1","rect2","br1x","br1y","br2x","br2y","x","y","limitWidth","$originalElement","characterWidthLimit","hasVertScroll","scaleRectFromCenter","constrainHeightToSafeArea","constrainPosition","offset","container","hlbStyle","originalHeight","safeZoneHeight","getFinalScale","constrainWidthToSafeArea","originalWidth","safeZoneWidth","initializeSize","getPageZoom","clonedNodeBoundingBox","zoomFactor","overflowY","hlbElement","scrollWidth","fixNegativeMargins","childLeft","childTop","hasBackgroundImage","hlbLeft","hlbTop","extraLeft","extraTop","originalHLBLeftPadding","originalHLBTopPadding","thisStyle","getOriginCSS","getTranslateCSS","setOriginCSS","val","setTranslateCSS","getHlbZoom","getStartingScale","body","sizeHLB","positionHLB","constrainedOffset","HLBBoundingBoxAfterZoom","HLBBoundingBox","expandedWidthOffset","expandedHeightOffset","startAnimationZoom","hlbStyles","transform","transformOrigin","DIMMER_ID","DIMMER_MIN_OPACITY","DIMMER_MAX_OPACITY","requestFrameFn","requestAnimationFrame","dimBackgroundContent","inflationSpeed","$foreground","createDimmerElement","documentElement","useCss","pointerEvents","newDimmer","attr","animateOpacity","dimmerElement","getDimmerElement","insertBefore","startOpacity","endOpacity","speed","onCompleteFn","startTime","Date","now","nextFrame","timeElapsed","percentComplete","currentOpacity","undimBackgroundContent","deflationSpeed","dimmer","onDimmerClosed","getElementById","hlbPositioning","platform","nativeGlobal","INFLATION_SPEED","INFLATION_SPEED_FAST","DEFLATION_SPEED","transitionInHLB","doShowQuickly","data","startingScale","animateCss","onHLBReady","transitionOutHLB","isHLBZoomed","onHLBClosed","getCurrentScale","startScale","endScale","fromCss","toCss","onTransitionEnd","transitionEndEvent","setTimeout","transition","getComputedScale","scale","eventHandlers","hlbAnimation","geo","metric","events","$hlbWrapper","EXTRA_HIGHLIGHT_PADDING","MOUSE_SAFETY_ZONE","FORMS_SELECTOR","removeTemporaryFoundation","preventDeflationFromMouseout","isListeningToMouseEvents","isHLBClosing","isSticky","foundations","li","getValidListElement","fieldset","getValidFieldsetElement","input","getValidFormElement","state","loggingEnabled","mapForm","$from","$to","$currentFromInput","$currentToInput","cloneIndex","fromInputType","$fromInputs","$toInputs","len","eq","prop","getAttribute","removeAttribute","browser","isSafari","copyFormDataToPage","isButtonDown","mouseEvent","buttons","which","onTargetChange","newTarget","mouseX","clientX","mouseY","clientY","isMouseDown","closeHLB","turnOnHLBEventListeners","on","onHLBHover","onClick","focus","emit","turnOffHLBEventListeners","off","targetHLB","isRetargeting","fixedContentRect","picked","getInitialHLBRect","getFoundation","createHLB","toggleHLB","retargetHLB","expandOrContractRect","initializeHLB","viewData","getEditableItems","getOrCreateHLBWrapper","isIE","appendTo","insertAfter","cloneHLB","LensOpen","send","id","pickedElement","pickedElementComputedStyle","pickedElementBoundingBox","pickedElementClone","$pickedAndDescendants","$pickedCloneAndDescendants","append","pageXOffset","pageYOffset","pickedElementsBoundingBox","setCloneIndexOnFormDescendants","$formDescendants","setAttribute","$submitButton","submitButtonClone","clone","tag","Object","prototype","hasOwnProperty","call","tagName","isElementInsideHlb","removeHLBWrapper","undefined","$wrapper","overflow","getElement","toggleStickyHLB","toggleHLBLogging"],"mappings":"AAAA;;;;;;;;;ACOAA,SAAAC,OAAA,wBAAA,OAAA,SAAAC;;;;;;;EASA,IAAAC,oBAEAC;;;;EAKA,SAAAC;IAEAC,OAAAC,oBAAA,SAAAJ;IAEAC,cAAA;;;;;;EAOA,SAAAI,mBAAAC;IAEA,IAAAL;MACA;;IAGAA,cAAA;;;;;;;;IASAD,qBAAA,SAAAO;;MAGA,IAAAC,SAAAC,SAAAF,MAAAC,WAAAD,MAAAG;;;;MAIA,KAAAF;;QAGA,OAAAG,cAAAJ;;;;;;;;;;;;;;;;;;MAoBA,IAAAK,OAAAN,KAAA;MACAO,eAAAD,KAAAC;MACAC,YAAAF,KAAAE;MACAC,eAAAH,KAAAG;MACAC,eAAAH,eAAAC,YAAAC;MACAE,gBAAAT,SAAA;MACAU,cAAAV,SAAA;MACAW,mBAAAH,gBAAA;MACAI,gBAAAR,KAAAE,aAAA;;;;;MAMA,IAAAR,KAAA,OAAAC,MAAAc,WAAAtB,EAAAuB,SAAAV,MAAAL,MAAAc;QACAV,cAAAJ;;;;MAKA,IAAAU,iBAAAT,UAAAQ,cAAA;;QAEAJ,KAAAE,YAAAF,KAAAC;;QAEAF,cAAAJ;;;MAIA,IAAAY,oBAAAF;QACAN,cAAAJ;;;;MAKA,IAAAW,eAAAJ,aAAAN,UAAA,GAAA;;QAEAI,KAAAE,YAAA;;QAEAH,cAAAJ;;;MAIA,IAAAa,iBAAAF;QACAP,cAAAJ;;;MAIA,SAAAI;QACAJ,MAAAgB;QACAhB,MAAAiB,cAAA;QACA,OAAA;;;;IAOArB,OAAAsB,iBAAA,SAAAzB;;EAGA;IACAE,oBAAAA;IACAG,oBAAAA;;;;AAKAR,SAAAC,OAAA,qBAAA;EChJA,IAAA4B;;EAIAA,UAAAC,iBAAA;;EACAD,UAAAE,SAAA;;EACAF,UAAAG,YAAA;;;EAGAH,UAAAI,aAAA;EAEA,OAAAJ;;;;;;;;ACRA7B,SAAAC,OACA,iBACA,KACA,oBACA,wBACA,iBACA,iCACA,4BAEA,SACAC,GACAgC,QACAC,MACAN,WACAO,aACAC;;;;;EASA,IAAAC,iBAAA;EACA,IAAAC,gBAAA;;;;EAKA,IAAAC,qBAAA;;;;EAMA;;EAGAC,4CAAA;EAGAC,+BAAA;EAGAC,yBAAA;EAGAC,qCAAA;EAGAC,oBACA,WACA,UACA,QACA,OACA,SACA,UACA,cACA,aACA,qBACA,kBACA,iBACA,4BACA,yBACA,wBACA,cACA,sBACA,SACA,UACA,2BACA,cACA,aACA,cACA,aACA;EAIAC,wBACA,UACA;EAIAC,0BACA,MACA;EAIAC;IACAC,UAAA;;IACAC,QAAArB,UAAAI;;IACAkB,QAAAZ,gBAAA;IACAa,SAAAd;IACAe,QAAA;;IACAC,cAAA;;IACAC,WAAA;;IACAC,YAAA;IACAC,UAAA;IACAC,WAAA;IACAC,SAAA;;;;;;;;;EAWA,SAAAC,0BAAAnD;IACAA,KAAAoD,KAAAf,oBAAAgB,KAAA,MAAAC;;;;;;;;EASA,SAAAC,qBAAAvD,MAAAwD,SAAAC;IAEA,IAAAC,0BAAAF,QAAAG,GAAA,OACAC,oBAAAJ,QAAAJ,KAAA,KAAAS,OACAC,kBAAAJ,0BAAA1D,KAAA+D,WAAAX,KAAA,OAAApD,KAAAoD,KAAA,MAAAS;IAEA,IAAAG;MACA,IAAAJ,kBAAAK,WAAAH,eAAAG;QACAC,QAAAC,KAAA;;;IAIAP,kBAAAQ,QAAA,SAAAC,SAAAC;MACA,IAAAb,eAAAI,IAAAQ;QACA5E,EAAAqE,eAAAQ,QAAAhB;;;;;;;;EASA,SAAAiB,aAAAvE;IACA,KAAA,IAAAwE,IAAA,GAAAA,IAAApC,gBAAA6B,QAAAO,KAAA;MACA7C,YAAA8C,eAAAzE,KAAA,IAAAoC,gBAAAoC;;;;;;;EAQA,SAAAE,iBAAA1E;IACA,KAAA,IAAAwE,IAAA,GAAAA,IAAAlC,sBAAA2B,QAAAO,KAAA;MACAxE,KAAA2E,WAAArC,sBAAAkC;;;;;;;;;;EAWA,SAAAI,oBAAAC,aAAAC;;IAGA,IAAAC;MACAC,qBAAA;MACAC,gBAAA;MACAC,QAAA;;MACAC,QAAA;;MACAC,aAAA;OAEAC,WAAAC,WAAAR,0BAAAO,WACAE,aAAAD,WAAAR,0BAAAS,aACAN,iBAAAH,0BAAAG;;;IAIA,IAAAA,eAAAO,QAAA,kBAAA;MAEAT,OAAAE,iBAAA;;MAEA,IAAAA,eAAAO,QAAA,iBAAA;QAEAT,OAAAE,iBAAA;;QAEA,IAAAA,eAAAO,QAAA,qBAAA;UAEAT,OAAAE,iBAAA;;;;;;IAMA,IAAAI,WAAAE,YAAA;MACA,IAAAvB;QACAE,QAAAuB,IAAA,2CAAA;;MAEAV,OAAAQ,aAAAF,WAAA;;;;;;;;IASA,IAAA,eAAAP,0BAAAtC,UAAA;MACAuC,OAAAvC,WAAA;MACAuC,OAAAW,UAAA;;;IAIA,IAAAb,YAAAlB,GAAA;MACAoB,OAAAY,WAAA;;IAGA,OAAAZ;;EAIA,SAAAa,eAAAC,UAAAC;;IAGA,IAAA,WAAAA,qBAAAC,iBAAA,WAAAD,qBAAAE;MACA,OAAAvE,OAAAmE,eAAAC,SAAA,IAAAC;;IAGA,OAAA;;;;;;;EAQA,SAAAG,cAAAC;IACA,OAAAA,MAAAV,QAAA,aAAA,MAAAU,MAAAV,QAAA,UAAA,KAAA,QAAAU,MAAAC,OAAAD,MAAAjC,SAAA,OACA,kBAAAiC;;;;;;;;;EAUA,SAAAE,2BAAA5C,SAAA6C;IACA,IAAAC,uBACAC,WAAA/C,QAAAgD;IAEAD,SAAAE,KAAA,SAAAnC;MACA,IAAAA,SAAA+B;QACA,OAAA;;MAGA,IAAAK,YAAAjH,EAAAkH;MAEA,IAAA,WAAAD,UAAAE,IAAA,oBAAA;QACAN,iBAAAO,kBAAAH,UAAAE,IAAA;QACAN,iBAAAQ,mBAAAJ,UAAAE,IAAA;QACAN,iBAAAS,uBAAA;QACAT,iBAAAI,YAAAA;QACA,OAAA;;;IAIA,OAAAJ;;;;;;;;;EAUA,SAAAU,4BAAAxD;IAEA,IAAAyD,oBACAT,UAAAhD,QAAAgD;IAEAA,QAAAC,KAAA;MACA,KAAAR,cAAAxG,EAAAkH,MAAAC,IAAA,qBAAA;QACAK,qBAAAxH,EAAAkH,MAAAC,IAAA;QACA,OAAA;;;IAIA,OAAAK;;;;;;;;;;;;;EAeA,SAAAC,sBAAA1D,SAAAsC;IAEA,IAAAmB;IAEA,IAAAhB,cAAAH,qBAAAqB;MAEA,IAAA3D,QAAAG,GAAA;QAEA,OAAAxB;aAEA;QAEA8E,qBAAAD,4BAAAxD;QAEA,IAAAyD;UAEA,OAAAA;;UAIA,OAAAhF;;;;IAQA,OAAA6D,qBAAAqB;;;;;;;;EAUA,SAAAC,sBAAA5D,SAAAsC;IACA,IAAAuB;;IAGA,IAAA,WAAAvB,qBAAAe,mBACAZ,cAAAH,qBAAAqB,kBAAA;MAEAE,qBAAAjB,2BAAA5C,SAAAxB;MAEA,IAAAqF;QACA,OAAAA;;;IAIA;MACAR,iBAAAf,qBAAAe;MACAC,kBAAAhB,qBAAAgB;MACAC,sBAAA;;;;;;;;;;EAWA,SAAAO,kBAAAC,aAAAC;IAEA,OAAA3F,iBAAA+D,eAAA2B,aAAAC;;;;;;;;;;;;;;;;;;EAoBA,SAAAC,cAAAD;IAEA,IAAA,YAAAA,cAAA9B;MACA,OAAA;;IAGA,OAAA8B,cAAA9B;;;;;;;;;EAWA,SAAAgC,oBAAAC,QAAAC;IAEA,IAAAC,0BAAAF,OAAA,GAAAG,yBACAC,mBAAAzC,WAAAqC,OAAAf,IAAA,iBACAoB,oBAAA1C,WAAAqC,OAAAf,IAAA,kBACAqB,kBAAA3C,WAAAqC,OAAAf,IAAA,gBACAsB,qBAAA5C,WAAAqC,OAAAf,IAAA;IAEA,IAAAe,OAAAhE,GAAA,iBAAA,MAAAkE,wBAAAM;MACA;;IAGA,IAAAN,wBAAAO,OAAAR,eAAAQ,QAAAL,mBAAA,KACAF,wBAAAQ,QAAAT,eAAAS,SAAAL,oBAAA,KACAH,wBAAAS,MAAAV,eAAAU,OAAAL,kBAAA,KACAJ,wBAAA3C,SAAA0C,eAAA1C,UAAAgD,qBAAA,GACA;MAEA,IAAAlE;QACAE,QAAAuB,IAAA,2CAAA;;MAEA,OAAA;;;;;;;;;;EAYA,SAAA8C,gBAAAZ,QAAAC;IAEA,IAAAC,0BAAAF,OAAA,GAAAG,yBACAC,mBAAAzC,WAAAqC,OAAAf,IAAA,iBACAoB,oBAAA1C,WAAAqC,OAAAf,IAAA,kBACAqB,kBAAA3C,WAAAqC,OAAAf,IAAA,gBACAsB,qBAAA5C,WAAAqC,OAAAf,IAAA,mBACA4B,oBACAC,OAAA/G,KAAAmC,IAAA,WAAA;IAEA,IAAAgE,wBAAAO,OAAAR,eAAAQ,QAAAL,mBAAA;MACAS,cAAAE,cAAAX,oBAAAH,eAAAQ,OAAAP,wBAAAO,QAAAK;;IAGA,IAAAZ,wBAAAQ,QAAAT,eAAAS,SAAAL,oBAAA;MACAQ,cAAAG,eAAAX,qBAAAH,wBAAAQ,QAAAT,eAAAS,SAAAI;;IAGA,IAAAZ,wBAAAS,MAAAV,eAAAU,OAAAL,kBAAA;MACAO,cAAAI,aAAAX,mBAAAL,eAAAU,MAAAT,wBAAAS,OAAAG;;IAGA,IAAAZ,wBAAA3C,SAAA0C,eAAA1C,UAAAgD,qBAAA;MACAM,cAAAK,gBAAAX,sBAAAL,wBAAA3C,SAAA0C,eAAA1C,UAAAuD;;IAGA,OAAAD;;;;;;;;EAUA,SAAAM,2BAAAvB,aAAAvH;IACA2B,YAAA3B,KAAA,IAAA+I,UAAAC,wBAAAzB,YAAA;;;;;;;;;;;;;EAeA,SAAA0B,8BAAA1B,aAAAvH,MAAA4H,gBAAAnE;IAEA,IAEAqB,2BACAoE,qBAHAC,aAAA5B,YAAA,IACA6B,MAAApJ,KAAA,IAGAqJ,gBAAA,MACAC,oBAAAH,cACAI,aAAAH;;;IAIA,OAAAE,gBAAArF,QAAA;MACA,IAAAuF,iBAAAF,gBAAAG,OACAC,UAAAH,SAAAE;MAEA,IAAAhG,eAAAI,IAAA2F;QACA;;MAGAG,qBAAAH,gBAAAE;MAEAJ,kBAAAA,gBAAAM,OAAAhI,UAAAiI,KAAAL,eAAAzF;MACAwF,WAAAA,SAAAK,OAAAhI,UAAAiI,KAAAH,QAAA3F;;IAGA,SAAA4F,qBAAAG,cAAAC;MACA,IAAAC,YAAAvK,EAAAqK,eACAG,SAAAxK,EAAAsK;;MAEAjF,4BAAAoF,iBAAAJ;;MAGAnI,YAAAoI,WAAAhB,UAAAC,wBAAAc;MAEA,IAAApC,oBAAAsC,WAAApC;QACAjG,YAAAwI,IAAAJ,WAAAxB,gBAAAyB,WAAApC;;;MAIAsB,sBAAAtE,oBAAAoF,WAAAlF;;MAGA,IAAAsF,8BAAAJ,WAAAzC,cAAA;QACA,IAAAvD;UACAE,QAAAuB,IAAA,oDAAA;;QAEAyD,oBAAAmB,aAAA;QACAnB,oBAAAoB,cAAA;;QAEAjB,gBAAA;;;MAIA1H,YAAAwI,IAAAJ,WAAAb;;;MAIAxE,iBAAAuF;;;;;;;;;;EAWA,SAAAG,8BAAAG,uBAAAhD;IAEA,IAAAiD,YAAAD,sBAAAE,SAAA1G,YACAwC,WAAAgE,sBAAAG,aAAAnD,cACAoD,cAAApE,SAAAtC,QACA2G,aAAAJ,UAAAvG,QACA4G,aAAA,OACAC,oBACAtG,IAAA,GACAuG,IAAA;IAEA,IAAA,MAAAH;MACA,OAAA;;IAGA,MAAApG,IAAAmG,aAAAnG,KAAA;MACA,IAAA+B,SAAA/B,GAAAsD,wBAAAM,OAAAmC,sBAAA,GAAAzC,wBAAAM;QACA,OAAA;;;IAIA,KAAA5D,IAAA,GAAAA,IAAAoG,YAAApG,KAAA;MACAsG,cAAAE,KAAAR,UAAAhG,GAAAsD;;IAGA,KAAAtD,IAAA,GAAAA,IAAAoG,YAAApG,KAAA;MACA,MAAAuG,IAAAH,YAAAG,KAAA;QACA,IAAAvG,MAAAuG;UACA,MAAAD,cAAAtG,GAAA8D,OAAAwC,cAAAC,GAAA7F,UACA4F,cAAAtG,GAAAU,UAAA4F,cAAAC,GAAAzC;YACAuC,aAAA;;;;;IAMA,QAAAA;;;;;;;;;;;EAcA,SAAAI,qBAAAjL;IAEA,IAAA+D;;;IAIA,IAAA,WAAA/D,KAAA4G,IAAA;MACA;;IAGA7C,WAAA/D,KAAAoD,KAAA;;IAGAW,SAAA0C,KAAA;MAEA,IAAAyE,YAAAzL,EAAAkH,MAAAC,IAAA,UACAO,kBAAA1H,EAAAkH,MAAAC,IAAA,oBACAuE,iBAAA;;;;MAKA,IAAAlF,cAAAkB,oBAAA+D,cAAA/D,iBAAA;;QAGA1H,EAAAkH,MAAA+D,aAAA1K,KAAAyK,UAAAhE,KAAA;UAEA,IAAA2E,wBAAA3L,EAAAkH,MAAAC,IAAA;;UAGA,KAAAX,cAAAmF;;;YAIA,IAAAF,cAAAE,uBAAA;cAEAD,iBAAA;cACA,OAAA;;cAGA,OAAA;;;;QAOA,IAAAA;UACAxJ,YAAAgF,MAAA0E,QAAAnJ;;;;;;;;;;EAcA,SAAAoJ,aAAA9H,SAAA+D,aAAAgE;IAEA,IAAAC,kBAAAjE,YAAA,IACAkE,sBAAAD,gBAAA1D,yBACAhC,uBAAAjG,OAAAqK,iBAAAsB,kBACAlF,mBAAAc,sBAAA5D,SAAAsC,uBACAqB,kBAAAD,sBAAA1D,SAAAsC,uBACA4F;MACAhD,aAAApB,kBAAAC,aAAAzB;MACAJ,SAAA+B,cAAA3B;MACAsC,MAAAqD,oBAAArD,OAAAvI,OAAA8L;MACArD,KAAAmD,oBAAAnD,MAAAzI,OAAAW;OAEAoL;MACAC,aAAAN,UAAAO,yBAAAP,UAAAQ,uBAAA;OAEAC;MACAC,YAAA;MACAC,oBAAA;;;IAIA,IAAA/E,oBAAAI,YAAAX,IAAA,UAAA;MACA8E,oBAAAL,QAAAnJ;MACAwJ,oBAAAvE,kBAAAlF;;MAEAyJ,oBAAAvE,kBAAAA;;;;;IAMA,IAAA,WAAAI,YAAAX,IAAA,sBAAA,aAAAW,YAAAX,IAAA,qBAAA;MACA8E,oBAAAhD,cAAAnB,YAAAX,IAAA;MACA8E,oBAAA9C,aAAArB,YAAAX,IAAA;MACA8E,oBAAA7C,gBAAAtB,YAAAX,IAAA;MACA8E,oBAAA/C,eAAApB,YAAAX,IAAA;;MAEA,IAAAN,iBAAAI,WAAA;QACA,IAAAA,YAAAJ,iBAAAI;;QAGA,IAAA,aAAAA,UAAAE,IAAA,qBAAA;UACA8E,oBAAAhD,cAAAhC,UAAAE,IAAA;UACA8E,oBAAA9C,aAAAlC,UAAAE,IAAA;UACA8E,oBAAA7C,gBAAAnC,UAAAE,IAAA;UACA8E,oBAAA/C,eAAAjC,UAAAE,IAAA;;;;WAIAN,iBAAAI;IAEA,OAAAjH,EAAA0M,WACA5J,kBACAqJ,cACAF,qBACApF,kBACA0F;;;;;;EAQA,SAAAI,OAAApM,MAAAwD,SAAAC;IAEAc,aAAAvE;IAEAuD,qBAAAvD,MAAAwD,SAAAC;IAEAN,0BAAAnD;IAEA0E,iBAAA1E;;;;;;;EASA,SAAAqM,iBAAA9E,aAAAvH,MAAA4H,gBAAAnE;IAEAqF,2BAAAvB,aAAAvH;IAEAiJ,8BAAA1B,aAAAvH,MAAA4H,gBAAAnE;;;;;;;;EAWA,SAAAuF,wBAAA3E;IAEA,IAAA6B,QAAArG,OAAAqK,iBAAA7F,UACA0E,UAAA;IAEA,IAAA,OAAA7C,MAAA6C;MACA,OAAA7C,MAAA6C;;IAGA,KAAA,IAAAvE,IAAA,GAAAA,IAAA0B,MAAAjC,QAAAO;MACAuE,WAAA7C,MAAA1B,KAAA,OAAA0B,MAAAoG,iBAAApG,MAAA1B,MAAA;;IAGA,OAAAuE;;EAGA;IACAjH,eAAAA;IACAD,gBAAAA;IACAE,oBAAAA;IACAkJ,sBAAAA;IACAK,cAAAA;IACAc,QAAAA;IACAC,kBAAAA;IACArD,yBAAAA;;;;AAKAzJ,SAAAC,OAAA,qBAAA;;;;;;;;ECnyBA,IAAA+M,gBAAA;;;;;;;;;EAWA,SAAAC;IAEA,IAAAC,aAAAC,KAAAC,KACAD,KAAAE,IAAA/M,OAAAgN,aAAA,KACAH,KAAAE,IAAA/M,OAAAiN,YAAA;IAGA,OAAAL,aAAAF;;;;;;EASA,SAAAQ;IAEA,IAAAC,eAAAR;IAEA;MACApE,MAAA4E;MACA1E,KAAA0E;MACA7E,OAAAtI,OAAAiN,aAAA,IAAAE;MACA7H,QAAAtF,OAAAgN,cAAA,IAAAG;MACA3E,OAAAxI,OAAAiN,aAAAE;MACA9H,QAAArF,OAAAgN,cAAAG;;;EAIA;IACAD,wBAAAA;;;;;;;;;;AC/CAxN,SAAAC,OACA,qBACA,KACA,iBACA,eACA,oBACA,gCACA,iBACA,mCAEA,SACAC,GACAiC,MACAuL,YACAxL,QACAyL,gBACAC,aACAxL;;;;EAQA;EAEAyL;EACAC,cAHAC,mBAAA;EAIAC,aAAAL,eAAAK,YACAC,gBAAAN,eAAAM,eACAC,gBAAAP,eAAAO;;;;;;;;;;EAYA,SAAAC,cAAAC,OAAA3N;IAEA,IAMA4N,KANAC,kBAAA7N,KAAA,GAAA8H,yBACAgG,oBAAAH,MAAA7F,yBACAiG,gBAAAC,iBAAAhO,OACAiO,WAAAH,kBAAA1F,OAAAyF,gBAAAzF,OAAA0F,kBAAA1F,OAAAyF,gBAAAzF,OAAA,GACA8F,UAAA,GACAC,WAAA;IAGA1O,EAAAkO,OAAAjD,aAAA1K,KAAAyK,UAAA2D,UAAA3H,KAAA;MACA,IAAAe,gBAAA0C,iBAAAvD;;;;;;;MAOAwH,YAAA7I,WAAAkC,cAAAmB,gBACArD,WAAAkC,cAAA6G;MAEAH,WAAA5I,WAAAkC,cAAA6C,cACA/E,WAAAkC,cAAAkB,eACApD,WAAAkC,cAAA8G;;IAGAV,MAAAM,UAAAC;IAEA,IAAAF,YAAAA,WAAAC;MACAD,YAAAC;;MAEAD,WAAA;;IAGA,OAAAJ,gBAAA1F,QAAA4F,gBAAAH,MAAAK;;;;;;EAQA,SAAAM,gBAAAvO;IAEA,IAAAwO,OACAC,gBACAC,gBACAC,WACAC,SACAC,YAKAC,sBACAC;;IAFAC,sBAAAC,SAAAC,eAGAC,qBAAA,KAAA7J,WAAAtF,KAAA4G,IAAA,mBAAA;IAEAoI,oBAAAI,WAAApP,KAAA;IAEA8O,uBAAAE,oBAAAlH,wBAAAK,QAAAgH;IAEAH,oBAAAK,mBAAArP,KAAA;IAEA+O,8BAAAC,oBAAAlH,wBAAAK,QAAAgH;IAEA,IAAAnP,KAAA,GAAAsP,cAAA5C,KAAA6C,IAAAT,sBAAAC,8BAAA;MAEA,IAAA/K;QACAE,QAAAuB,IAAA,uDAAA;;MAGAgJ,iBAAAzO,KAAAoD,KAAA;MAEAoL,QAAA;MAEAC,eAAAhI,KAAA;QACA9E,YAAAgF,MAAA3D,WAAA0K,cAAA/G,MAAA3G,QAAA;;;IAKA0O,iBAAA1O,KAAA,GAAAsP;;;IAIAE,uBAAAxP;;;IAIAyP,kBAAAzP;IAEA,IAAAwO,SAAAxO,KAAA,GAAAsP,cAAAZ,gBAAA;MAEA,IAAA1K;QACAE,QAAAuB,IAAA,kFAAA;;MAGAoJ,aAAAH,iBAAA1O,KAAA,GAAAsP;MAEAV,UAAA5O,KAAA,GAAA8H;MAEA2G,eAAAhI,KAAA;;QAEAkI,YAAAhI,KAAAmB;QACA,IAAA6G,UAAAvG,OAAAwG,QAAAxG,QAAAuG,UAAAtG,QAAAwG,aAAAD,QAAAvG;UACA1G,YAAAgF,MAAA3D,WAAAsC,WAAA4E,iBAAAvD,MAAA3D,YAAA6L,aAAA;;;;IAMAa,iBAAA1P;;;;;;;EAQA,SAAA2P,8BAAA3P;IAEA,IAAA4P,gBAAA;;;;;;;;;;IAaA,SAAAC,YAAAxL;MACA,OAAAA,QAAAyL,WAAAC,oBAAA;;IAGA,SAAAC,eAAA3L;MACA,IAAA4L,UAAA;MACAxQ,EAAA4E,SAAA6L,QAAAlQ,MAAAyG,KAAA,SAAAnC,OAAA6L;QACAF,UAAAjQ,KAAA,OAAAmQ,2BAAAN,YAAAM;QACA,OAAAF;;MAEA,OAAAA;;;IAIA,SAAAG,kBAAAxJ;MACA,OAAA,aAAAA,IAAApE,YAAA,WAAAoE,IAAAyJ,SAAA,iBAAAzJ,IAAAlB;;;;IAKA,SAAA4K,kBAAAhM,OAAAD;MACA,IAAAuC,MAAAsD,iBAAA7F;MAEAuL,iBAAA,aAAAhJ,IAAA2J,cAAA,cAAA3J,IAAA2J,iBACAH,kBAAAxJ,QAAAoJ,eAAA3L,cACAmJ,cAAAnJ,aAAAoJ,cAAApJ,aAAAkJ,WAAAlJ;;;;;MAOA,OAAAuL;;;;;IAMA,IAAA,OAAA5P,KAAA4G,IAAA,YAAAT,OAAA;MACA;;;;IAKA,IAAAnG,KAAA2D,GAAA;MACA;;IAGA3D,KAAAoD,KAAA,KAAAgL,UAAA3H,KAAA6J;IAEA,OAAAV;;;;;;;EASA,SAAAY,oBAAAxQ;IACA,OAAAG,SAAAH,KAAA4G,IAAA,kBAAAqG,WAAApL;;;;;;EAOA,SAAA4O,aAAAC,OAAAC;IAEA,IAAAC,OAAAF,MAAAtI,OAAAsI,MAAAvI,QAAA,GACA0I,OAAAH,MAAApI,MAAAoI,MAAAvL,SAAA,GACA2L,OAAAH,MAAAvI,OAAAuI,MAAAxI,QAAA,GACA4I,OAAAJ,MAAArI,MAAAqI,MAAAxL,SAAA;IAEA;MACA6L,GAAAJ,OAAAE;MACAG,GAAAJ,OAAAE;;;;;;;;;EAWA,SAAAG,WAAAC,kBAAAnR,MAAAoR;;;IAIA,IAAAzB,8BAAA3P,OAAA;MAEA,IAAAgE;QACAE,QAAAuB,IAAA,6CAAA;;;MAIA9D,YAAA3B,KAAA,IAAAgD,WAAAoO,sBAAA;;;;;;;EASA,SAAA5B,uBAAAxP;IACA,IAAAoJ,MAAApJ,KAAA;;IAEA,IAAAyB,OAAA4P,cAAAjI,QACAkI,oBAAAtR,MAAAmF,SAAAgI,YAAAJ,yBAAA5H,QAAA;;;MAIAxD,YAAAyH,KAAAjE,SAAAiE,IAAA7I,eAAAJ,SAAA+J,iBAAAd,KAAAP,iBAAA;;;MAGA0I,0BAAAvR;;;;;;;;;;EAWA,SAAAwR,kBAAAnN;IAEA,IAAAoN;MACAT,GAAA;MACAC,GAAA;OAGAS,YAAAvE,YAAAJ;IAEA,IAAA1I,QAAA+D,OAAAsJ,UAAAtJ;MACAqJ,OAAAT,KAAAU,UAAAtJ,OAAA/D,QAAA+D;;IAEA,IAAA/D,QAAAiE,MAAAoJ,UAAApJ;MACAmJ,OAAAR,KAAAS,UAAApJ,MAAAjE,QAAAiE;;IAEA,IAAAjE,QAAA+D,OAAA/D,QAAA8D,QAAAuJ,UAAArJ;MACAoJ,OAAAT,KAAA3M,QAAA+D,OAAA/D,QAAA8D,QAAAuJ,UAAArJ;;IAEA,IAAAhE,QAAAiE,MAAAjE,QAAAc,SAAAuM,UAAAxM;MACAuM,OAAAR,KAAA5M,QAAAiE,MAAAjE,QAAAc,SAAAuM,UAAAxM;;IAEA,OAAAuM;;;;;;;EAQA,SAAAF,0BAAAvR;IAEA,IAAAoJ,MAAApJ,KAAA,IACA2R,WAAAhQ,YAAAyH,MACAwI,iBAAAN,oBAAAtR,MAAAmF,QACA0M,iBAAA1E,YAAAJ,yBAAA5H;;IAGA,IAAAyM,iBAAAC,gBAAA;;MAGAF,SAAAxM,SAAA0M,iBAAAC,cAAA9R,QAAAgO,iBAAAhO,SACAiN,WAAAnL,gBACAmL,WAAAnL,gBACA3B,SAAAH,KAAA4G,IAAA,iBACAzG,SAAAH,KAAA4G,IAAA,qBAEA;;MAGA,IAAA4G,cAAApE;;QAGAuI,SAAAxJ,QAAAiB,IAAAtB,wBAAAK,QAAA6F,iBAAAhO,SACA6R,iBAAAD,kBAAA;;;;;;;;;EAUA,SAAAG,yBAAA/R;IAEA,IAAAoJ,MAAApJ,KAAA,IACA2R,WAAAhQ,YAAAyH,MACA4I,gBAAAV,oBAAAtR,MAAAmI,OACA8J,gBAAA9E,YAAAJ,yBAAA5E;;IAGA,IAAA6J,gBAAAC,eAAA;;MAGAN,SAAAxJ,QAAA8J,gBAAAH,cAAA9R,QAAAgO,iBAAAhO,QACA,KAAAiN,WAAAnL,gBAAAmL,WAAApL,iBAAA2O,oBAAAxQ,QAAA,KAAA;;MAGA,IAAAwN,cAAApE;;QAGAuI,SAAAxM,SAAAiE,IAAAtB,wBAAA3C,SAAA6I,iBAAAhO,SACAiS,gBAAAD,iBAAA;;;;;;;;;;EAWA,SAAAE,eAAAlS,MAAA4H;IAEA,IAAAa,OAAA0J,eACAhK,QAAAP,eAAAO,QAAAM,OAAA,MACAtD,SAAAyC,eAAAzC,SAAAsD,OAAA;IACA9G,YAAAwI,IAAAnK,KAAA;MACAmI,OAAAA;;MACAhD,QAAAA;;;;;;;IAQAxD,YAAAwI,IAAAnK,KAAAoD,KAAA,KAAAS;MACAb,UAAAmF;;;;;;;;EASA,SAAAmJ,oBAAAtR;IAEA,IAAAoS,wBAAApS,KAAA,GAAA8H,yBACAuK,aAAAP,cAAA9R;;IAGA;MACAoI,MAAAgK,sBAAAhK,QAAAgK,sBAAAjK,QAAAkK,aAAAD,sBAAAjK,SAAA;MACAG,KAAA8J,sBAAA9J,OAAA8J,sBAAAjN,SAAAkN,aAAAD,sBAAAjN,UAAA;MACAgD,OAAAiK,sBAAAjK,QAAAkK;MACAlN,QAAAiN,sBAAAjN,SAAAkN;;;;;;;;EASA,SAAA5C,kBAAAzP;IACA,IAAAoJ,MAAApJ,KAAA;IAEA,IAAAyB,OAAA4P,cAAAjI,MAAA;MACAzH,YAAAyH,KAAAkJ,YAAA;;MAEA5C,iBAAA1P;;;;;;;EAQA,SAAA0P,iBAAA1P;IAEA,IAAAuS,aAAAvS,KAAA;;IAGA,IAAAuS,WAAAjD,cAAAiD,WAAAC,aAAA;MAEA,IAAAxO;QACAE,QAAAuB,IAAA,uCAAA;;MAGA9D,YAAAwI,IAAAoI;QACApK,OAAAoK,WAAAC,cAAAvF,WAAApL,iBAAA;QACAmB,UAAA;;;MAIA+O,yBAAA/R;;;;;;;;;;EAWA,SAAAyS,mBAAAzS,MAAA4H;IAEA,IAKAc,aACAE,YACA8J,WACAC,UACAC,oBACA9E,mBAVAD,kBAAA7N,KAAA,GAAA8H,yBACA+K,UAAAhF,gBAAAzF,MACA0K,SAAAjF,gBAAAvF,KACAyK,YAAA,GACAC,WAAA,GAOAC,yBAAA3N,WAAAtF,KAAA4G,IAAA,iBACAsM,wBAAA5N,WAAAtF,KAAA4G,IAAA;IAEA5G,KAAAoD,KAAA,KAAAqD,KAAA;MACA,IAAA0M,YAAAxR,YAAAgF;;;MAGA,KAAAlH,EAAAkH,MAAAhD,GAAA,kBACAlE,EAAAkH,MAAAC,IAAA,cAAApB,QAAA,UAAA,KACA/F,EAAAkH,MAAAC,IAAA,aAAApB,QAAA,UAAA,IAAA;QAEAsI,oBAAAnH,KAAAmB;QACA4K,YAAA5E,kBAAA1F;QACAuK,WAAA7E,kBAAAxF;QACAsK,qBAAA,WAAAO,UAAAtM;QACA6B,cAAAkK,qBAAA,IAAAtN,WAAA6N,UAAAzK;QACAE,aAAAgK,qBAAA,IAAAtN,WAAA6N,UAAAvK;QAEA,IAAA8J,YAAAhK,cAAAmK,WAAAA,UAAAH,YAAAhK,cAAAqK,WAAA;UACA,IAAA/O;YACAE,QAAAuB,IAAA,6CAAA;;UAEAsN,YAAAF,UAAAH,YAAAhK;;QAGA,IAAAiK,WAAA/J,aAAAkK,UAAAA,SAAAH,WAAA/J,aAAAoK,UAAA;UACA,IAAAhP;YACAE,QAAAuB,IAAA,4CAAA;;UAEAuN,WAAAF,SAAAH,WAAA/J;;;;;;;;MASA,IAAAmK,WAAA;QAEA,IAAA/O;UACAE,QAAAuB,IAAA,+DAAA;;QAGA9D,YAAA3B,KAAA,IAAAmI,QAAAP,eAAAO,QAAAgK,gBAAAY,YAAA;QAEArD,iBAAA1P;;;IAIA2B,YAAAwI,IAAAnK,KAAA;MACA4I,YAAAoK,WAAAE,wBAAAF,WAAA/F,WAAApL,iBAAAoL,WAAAnL,gBAAAoR;MACAxK,aAAAqK,YAAAE,yBAAAF,YAAA9F,WAAApL,iBAAAoL,WAAAnL,gBAAAmR;;;;;;EAQA,SAAAG;IACA,OAAAhG;;EAGA,SAAAiG;IACA,OAAAhG;;EAGA,SAAAiG,aAAAC;IACAnG,YAAAmG;;EAGA,SAAAC,gBAAAD;IACAlG,eAAAkG;;EAGA,SAAAE;IACA,OAAA;;;;EAaA,SAAA3B,cAAA9R;IACA,OAAAyT,eAAAC,iBAAA1T;;EAGA,SAAAmS;IACA,OAAAzQ,KAAAmC,IAAA,WAAA;;;EAIA,SAAA6P,iBAAA1T;IACA,OAAAA,KAAAkQ,QAAAjB,SAAA0E,MAAA1P,SAAA,IAAAkO;;;;EAKA,SAAAnE,iBAAAhO;IACA,OAAAA,KAAAkQ,QAAAjB,SAAA0E,MAAA1P,SAAAkO,gBAAA;;EAGA,SAAAyB,QAAA5T,MAAAmR,kBAAAvJ;;IAGA,IAAA5D;MACAE,QAAAuB,IAAA,eAAAmC;;IAGAsK,eAAAlS,MAAA4H;;IAGA2J,0BAAAvR;IACA+R,yBAAA/R;;IAGAkR,WAAAC,kBAAAnR,MAAAsN;IAEAiB,gBAAAvO;IAEA0P,iBAAA1P;IAEAyS,mBAAAzS,MAAA4H;;;;;EAOA,SAAAiM,YAAA7T,MAAA4H,gBAAAmG;;IAGA,IAAA+F,mBACA1K,MAAApJ,KAAA,IACA+T,0BAAAzC,oBAAAtR,OACAgU,iBAAA5K,IAAAtB;;IAIAmM,uBAAAF,wBAAA5L,QAAA6L,eAAA7L,SAAA,GACA+L,wBAAAH,wBAAA5O,SAAA6O,eAAA7O,UAAA;IAGAsM,SAAAhB,aAAArH,IAAAtB,yBAAAF;;;IAIAmM,wBAAA3L,OAAA4L,eAAA5L,OAAAqJ,OAAAT,IAAAiD;IACAF,wBAAAzL,MAAA0L,eAAA1L,MAAAmJ,OAAAR,IAAAiD;IACAH,wBAAA1L,QAAA0L,wBAAA3L,OAAA2L,wBAAA5L;IACA4L,wBAAA7O,SAAA6O,wBAAAzL,MAAAyL,wBAAA5O;;;;;IAMA2O,oBAAAtC,kBAAAuC;;;;IAKAtC,OAAAT,KAAA8C,kBAAA9C;IACAS,OAAAR,KAAA6C,kBAAA7C;;IAGA5D,eAAA,gBAAAoE,OAAAT,IAAAjD,gBAAA,UAAA0D,OAAAR,IAAAlD,gBAAA;;IAGAX,aAAAqE,OAAAT,IAAAjD,gBAAAiG,eAAA7L,QAAA,IAAA4F,gBAAA,UACA0D,OAAAR,IAAAlD,gBAAAiG,eAAA7O,SAAA,IAAA4I,iBAAA;;IAGA,IAAAoG,qBAAAhC,gBAAApE,eACAqG;MACAC,WAAA,WAAAF,qBAAA,OAAA9G;MACAiH,iBAAAlH;;IAGAzL,YAAAwI,IAAAf,KAAAgL;;EAGA;IACAhB,cAAAA;IACAC,iBAAAA;IACAC,cAAAA;IACAE,iBAAAA;IACA1B,eAAAA;IACA4B,kBAAAA;IACA1F,kBAAAA;IACA4F,SAAAA;IACAC,aAAAA;;;;;;;AC3rBAtU,SAAAC,OACA,gBACA,KACA,iBACA,mCAEA,SACAC,GACA2B,WACAO;;;;EAQA,IAAA4S,YAAA,8BAEAC,qBAAA,GACAC,qBAAA,KAEAC,iBAAA7U,OAAA8U;;;;;;;;;EAWA,SAAAC,qBAAAC,gBAAAC;IAEA,SAAAC;MACA,IAAAC,kBAAA/F,SAAA+F,iBACA7M,QAAAuE,KAAA6C,IAAAyF,gBAAAxC,aAAA3S,OAAAiN,aACA3H,SAAAuH,KAAA6C,IAAAyF,gBAAAzU,cAAAV,OAAAgN;MAEAoI;QACAvP,SAAA;QACAlD,UAAA;QACAC,QAAArB,UAAAI;QACA8G,KAAA;QACAF,MAAA;QACAD,OAAAA,QAAA;QACAhD,QAAAA,SAAA;QACAgC,iBAAA;QACA+N,eAAA;QACAjJ,YAAA;SAEAkJ,YAAA1V,EAAA;MAEAkC,YAAAwI,IAAAgL,UAAA,IAAAF;MACAE,YAAAA,UAAAC,KAAA,MAAAb,WAAA;MAEAc,eAAAF,WAAAX,oBAAAC,oBAAAI;MAEA,OAAAM;;IAGA,IAAAG,gBAAAC,sBAAAR;;IAGAtV,EAAA6V,eAAAE,aAAAV;;EAGA,SAAAO,eAAAC,eAAAG,cAAAC,YAAAC,OAAAC;IAEA,IAAAC,YAAAC,KAAAC;IAEA,SAAAC;MACA,IAAAC,cAAAH,KAAAC,QAAAF,WACAK,kBAAAD,cAAAN,QAAA,IAAAM,cAAAN,OACAQ,iBAAAV,gBAAAC,aAAAD,gBAAAS;MAEAvU,YAAA2T,eAAApS,UAAAiT;MAEA,IAAAD,kBAAA;QACAxB,eAAAsB;;QAEA,IAAAJ;UACAA;;;;IAGAI;;;;;;EAOA,SAAAI,uBAAAC;IAEA,IAAAC,SAAAf;IAEA,IAAAe;;MACAjB,eAAAiB,QAAA7B,oBAAAD,oBAAA6B,gBAAAE;;;;;;EAQA,SAAAA;IACA9W,EAAA8V,oBAAAjS;;EAGA,SAAAiS;IACA,OAAAtG,SAAAuH,eAAAjC;;EAGA;IACAK,sBAAAA;IACAwB,wBAAAA;;;;;;;;ACnHA7W,SAAAC,OACA,mBACA,cACA,oBACA,mBACA,gBACA,KACA,iBACA,2BACA,mCAEA,SACA8W,QACA7U,QACAgV,gBACAC,UACAjX,GACA2B,WACAuV,cACAhV;EAIA,IAAAiV,kBAAA;EACAC,uBAAA;EACAC,kBAAA;EAEApD,mBAAA+C,eAAA/C;;;;;EAMA,SAAAqD,gBAAAC,eAAAC;;IAGAX,OAAA1B,qBAAAgC,iBAAAnX,EAAA,MAAA2B,UAAAC;IAEA,IACArB,OAAAiX,KAAAjX,MACA2V,QAAAqB,gBAAAH,uBAAAD,iBACAM,gBAAAxD,iBAAA1T;IAEA2B,YAAA3B,KAAA,IAAAsU,kBAAA2C,KAAA7J;IAEA+J,WAAAnX,KAAA,IAAAkX,eAAAT,eAAA3E,cAAA9R,OAAA2V,OAAAsB,KAAA5J,cAAA4J,KAAAG;;;;;;EAOA,SAAAC,iBAAAJ;IAEA,IAAAjX,OAAAiX,KAAAjX;;IAGAsW,OAAAF,uBAAAU;;;;;;;;;IAWA,KAAAQ,YAAAtX,OAAA;MACAiX,KAAAM;MACA;;IAGAJ,WAAAnX,KAAA,IAAAwX,gBAAAxX,OAAA0T,iBAAA1T,OAAA8W,iBAAAG,KAAA5J,cAAA4J,KAAAM;;EAGA,SAAAJ,WAAA5E,YAAAkF,YAAAC,UAAA/B,OAAAtI,cAAAuI;IACA,IACA+B,cACAC;MACAvD,WAAA,WAAAqD,WAAA,OAAArK;;IAGA1L,YAAA4Q,YAAAxQ,qBAAA;;IAEA,KAAA4T,OAAA;;MAEAhU,YAAAwI,IAAAoI,YAAAqF;MACAhC;MACA;;;IAIA+B,QAAAtD,YAAA,WAAAoD,aAAA,OAAApK;IACA1L,YAAAwI,IAAAoI,YAAAoF;IAEA,SAAAE;MACAtF,WAAAzS,oBAAA4W,SAAAoB,oBAAAD;MACAjC;;;;IAKAe,aAAAoB,WAAA;MACAH,MAAAI,aAAA,eAAArC,QAAA;MACAhU,YAAAwI,IAAAoI,YAAAqF;MACArF,WAAApR,iBAAAuV,SAAAoB,oBAAAD;OACA;;EAGA,SAAAL,gBAAAxX;IACA,OAAAyB,OAAAwW,iBAAAjY,KAAA;;;;;;;;;EAUA,SAAAsX,YAAAtX;;IAEA,IAAAkY,QAAAV,gBAAAxX;IACA,OAAAkY,QAAAzB,eAAA/C,iBAAA1T;;EAGA;IACA+W,iBAAAA;IACAM,kBAAAA;;;;;;;;ACjIA9X,SAAAC,OACA,aACA,KACA,sBACA,mBACA,eACA,wBACA,gBACA,gCACA,iBACA,iBACA,qBACA,iBACA,cACA,mCAEA,SACAC,GACA0Y,eACA1B,gBACAxJ,YACAvL,MACAgV,UACAxJ,gBACAkL,cACAC,KACAC,QACAlX,WACAmX,QACA5W;;;;;;;;EAYA,IAIA6B;EACA+D;EACAvH;EACAwY;EAEA5Q;EACAmG,eAVA0K,0BAAA;EACAC,oBAAA;EACAC,iBAAA;EASAC,4BAAA;EACAC,+BAAA;EACAC,2BAAA;EACAC,eAAA;EACAC,WAAA;EACAC;;;IAGAC,IAAAC;IACAC,UAAAC;IACAC,OAAAC;KAEAC;EAEA,IAAAxV;;IAEA,IAAAyV,iBAAA;;;;;;;;;;EAYA,SAAAC,QAAAC,OAAAC,KAAAb;;IAGA,IAIAvU,GACAqV,mBACAC,iBACAC,YACAC,eARAC,cAAAN,MAAAvW,KAAAuV,gBACAvK,QAAAuK,iBACAuB,YAAAN,IAAAxW,KAAAuV,gBACAvK,QAAAuK,iBACAwB,MAAAF,YAAAhW;IAMA,KAAAO,IAAA,GAAAA,IAAA2V,KAAA3V,KAAA,GAAA;MACAqV,oBAAAI,YAAAG,GAAA5V;MACAsV,kBAAAI,UAAAE,GAAA5V;MACAwV,gBAAAH,kBAAAQ,KAAA;MACAN,aAAAD,gBAAA,GAAAQ,aAAA;;MAGA,IAAAvB,gBAAAgB,YAAA;;QAEAF,kBAAA,GAAAU,gBAAA;;QAEAT,kBAAAra,EAAA,sBAAAsa,aAAA;;QAEAD,gBAAA,GAAAS,gBAAA;;MAGA,IAAA,YAAAP,iBAAA,eAAAA;QACAF,gBAAAO,KAAA,WAAAR,kBAAAQ,KAAA;aAEA;QACA,IAAA3D,SAAA8D,QAAAC;;;UAGAX,gBAAAvG,IAAAsG,kBAAAtG,QAAA;;QAEAuG,gBAAAvG,IAAAsG,kBAAAtG;;;;EAMA,SAAAmH;;IAEAhB,QAAA1Z,MAAAuH,aAAA;;;;;EAMA,SAAAoT,aAAAC;IACA,OAAA,uBAAAA,WAAAC,UAAAD,WAAAE,QAAAF,WAAAC;;;;;;;EAQA,SAAAE,eAAA9a;IAEA,IAIA+T,gBAJAgH,YAAA/a,MAAAc,QACAka,SAAAhb,MAAAib,SACAC,SAAAlb,MAAAmb,SACAC,cAAAV,aAAA1a;;;IAKA,IAAA4Y,gCAAAG;MACA;;;IAIA,IAAAhZ,KAAA,OAAAgb;MACA;;;;IAKA,IAAAK;MACA;;IAGArH,iBAAAhU,KAAA,GAAA8H;;;IAIA,IAAAmT,SAAAjH,eAAA5L,OAAAsQ,qBACAuC,SAAAjH,eAAA3L,QAAAqQ,qBACAyC,SAAAnH,eAAA1L,MAAAoQ,qBACAyC,SAAAnH,eAAA9O,SAAAwT;MAEA4C,SAAArb;;;;;;EAOA,SAAAsb;IACA,IAAAzC;MACA;;IAGAA,2BAAA;;IAGArZ,EAAAwP,UAAAuM,GAAA,aAAAT;;;IAIA/a,KAAAwb,GAAA,aAAAC;;IAGAhc,EAAA,QAAA+b,GAAA,SAAAE;;IAGAvD,cAAApY,mBAAAC;;;;;;EAOA,SAAAoX;;IAGA,IAAAlK,eAAAK,WAAAvN,KAAA;MACAA,KAAA2b;;;;IAKApD,OAAAqD,KAAAxa,UAAAG,WAAAvB,MAAAwZ,MAAAjO;;;;;EAMA,SAAAsQ;IACA,KAAA/C;MACA;;;IAIAX,cAAAvY;IAEAI,KAAA,GAAAF,oBAAA4W,SAAAoB,oBAAAV;;IAGA3X,EAAAwP,UAAA6M,IAAA,aAAAf;;IAGAtb,EAAA,QAAAqc,IAAA,SAAAJ;IAEA5C,2BAAA;;;;;EAMA,SAAAwC,SAAArb;IAEAya;;IAGA3B,eAAA;IAEA8C;IAEAzD,aAAAf;MACArX,MAAAA;MACAwY,aAAAA;MACApL,WAAAqJ,eAAArD;MACA/F,cAAAoJ,eAAApD;MACAkE,aAAA;QAAAA,YAAAtX;;MACA8B,oBAAAkL,WAAAlL;;;EAIA,SAAAga,UAAAxQ,WAAAyQ;IAEAxC,MAAAjO,YAAAA;IAEA,KAAAA,UAAA0Q;MACA;;;;IAKAzY,UAAA+H,UAAA2Q;;IAIAtU,iBAAAuU,kBAAA5Q;;;IAIAgN,OAAAqD,KAAA;;IAGArU,cAAA6U,cAAA5Y;;IAGAqY;IAEAQ,UAAA9Q,WAAAyQ;;;;;EAMA,SAAAM,UAAA/Q;;;;IAIA,IAAAwN;MACA;;IAGA,IAAA/Y;MACAsb;;MAEAS,UAAAxQ;;;;;;;EAQA,SAAAgR,YAAAhR;IACAmP;;IACA1a,KAAAsD;IACAyY,UAAAxQ,WAAA;;;;;;;;;EAUA,SAAA4Q,kBAAA5Q;IAEA,OAAA8M,IAAAmE,qBAAAjR,UAAA0Q,kBAAAxD;;;;;;EAQA,SAAA4D,UAAA9Q,WAAAyQ;;;IAIAS,cAAAlR;IAEAkL,eAAA7C,QAAA5T,MAAAuH,aAAAK;IAEA6O,eAAA5C,YAAA7T,MAAA4H,gBAAAmG;;;;IAKA,IAAA6K,2BAAA;MACArR,YAAAjE;MACAsV,4BAAA;;IAGA,IAAA8D;MACA1c,MAAAA;MACAwY,aAAAA;MACApL,WAAAqJ,eAAArD;MACA/F,cAAAoJ,eAAApD;MACA+D,YAAAA;MACArV,oBAAAkL,WAAAlL;;;;;;;;;IAUAqW,aAAArB,gBAAAiF,eAAAU;;EAGA,SAAAC;IACA,SAAApP,WAAAjJ,OAAAD;MACA,OAAA6I,eAAAK,WAAAlJ;;IAEA,OAAAkD,YAAAnE,KAAA,kBACAgL,UACAhC,OAAAmB;;;;;;;;EASA,SAAAkP,cAAAlR;;IAGAiN,cAAAoE;IAEA,IAAAlG,SAAA8D,QAAAqC,QAAAF,mBAAA1Y,QAAA;;;MAIA,IAAAD,QAAAyV;QACAvV,QAAAuB,IAAA;;MAGA+S,YAAAsE,SAAA;MACA/O,gBAAArM,KAAAmC,IAAA,WAAA;WAEA;MACA2U,YAAAuE,YAAA;MACAhP,gBAAA;;;IAIA8K,+BAAA;;IAGAmE,SAAAzR;IAEAgQ;;IAGAhD,OAAAqD,KAAA,kBAAA5b,MAAAuL;IACA,IAAA+M,OAAA2E,WAAAC;;;;;EAMA,SAAAF,SAAAzR;IAEA,IAAA6I;;IAGApU,OAAAP,EAAA8H,YAAA,GAAAwC,UAAA;IACA,IAAAX,MAAApJ,KAAA;;;;;IAMA0Z,QAAAnS,aAAAvH;;;IAIAiN,WAAAZ,iBAAA9E,aAAAvH,MAAA4H,gBAAA2D,UAAA9H;;;;;IAMAwJ,WAAAb,OAAApM,MAAAwD,SAAA+H,UAAA9H;;;;IAKA2Q,YAAAnH,WAAA3B,aAAA9H,SAAA+D,aAAAgE;;IAGA5J,YAAAwI,IAAAf,KAAAgL;IACApU,KAAA8c,SAAAtE;;IAGAvL,WAAAhC,qBAAAjL;;IAGAoJ,IAAA+T,KAAA/b,UAAAE;;;;;;;;;;EAWA,SAAA6X,oBAAA3V;IAEA,IAQAgB,GARA4Y,gBAAA5Z,QAAA,IACA6Z,6BAAAxd,OAAAqK,iBAAAkT,gBACAE,2BAAAF,cAAAtV;IAEAyV,qBAAAH,cAAArT,UAAA,OACAyT,wBAAAha,QAAAJ,KAAA,KAAAgL,WACAqP,6BAAAhe,EAAA8d,oBAAAna,KAAA,KAAAgL,WACA7G,cAAA9H,EAAA,QAAAie,OAAAH;;;;;;;;IAWA3E,4BAAA;;;IAIAjX,YAAA4F,YAAA,IAAAwB,UAAAkE,WAAAjE,wBAAAxF,QAAAgD,QAAA,UAAA;;IAGA7E,YAAAwI,IAAA5C,YAAA;MACA/E,UAAA;MACA4F,OAAAkV,yBAAAlV,OAAAvI,OAAA8d,eAAA5P;MACAzF,MAAAgV,yBAAAhV,MAAAzI,OAAA+d,eAAA7P;MACA7K,SAAA;MACAP,SAAA;MACAC,QAAA;MACAuF,OAAAmV,yBAAAnV,QAAA4F;MACAhI,eAAAsX,2BAAAtX,iBAAA;;IAGAwB,YAAAwV,YAAA;;IAGA,KAAAvY,IAAA,GAAAA,IAAAgZ,sBAAAvZ,QAAAO,KAAA;MACA7C,YAAA8b,2BAAAjZ,IAAAuE,UAAAkE,WAAAjE,wBAAAwU,sBAAAhZ;;IAGA,OAAA+C;;;EAIA,SAAA8R,wBAAA7V;IAEA,IAOAgB,GAPA4Y,gBAAA5Z,QAAA,IACAqa,4BAAAT,cAAAtV;IAEAyV,qBAAAH,cAAArT,UAAA,OACAyT,wBAAAha,QAAAJ,KAAA,KAAAgL,WACAqP,6BAAAhe,EAAA8d,oBAAAna,KAAA,KAAAgL,WACA7G,cAAA9H,EAAA,QAAAie,OAAAH;;;;IAMA3E,4BAAA;;IAGAjX,YAAAwI,IAAA5C,YAAA;MACA/E,UAAA;MACA4F,OAAAyV,0BAAAzV,OAAAvI,OAAA8d,eAAA5P;MACAzF,MAAAuV,0BAAAvV,MAAAzI,OAAA+d,eAAA7P;MACA7K,SAAA;MACAP,SAAA;MACAC,QAAA;MACAuF,OAAA0V,0BAAA1V,QAAA4F;;IAEAxG,YAAAwV,YAAA;;IAGA,KAAAvY,IAAA,GAAAA,IAAAgZ,sBAAAvZ,QAAAO,KAAA;MACA7C,YAAA8b,2BAAAjZ,IAAAuE,UAAAkE,WAAAjE,wBAAAwU,sBAAAhZ;;IAGA,OAAA+C;;EAGA,SAAAuW,+BAAAta;IACA,IAAAgB,GACAuZ,mBAAAva,QAAAJ,KAAAuV,gBACAvK,QAAAuK;IAEA,KAAAnU,IAAA,GAAAA,IAAAuZ,iBAAA9Z,QAAAO;MACAuZ,iBAAAvZ,GAAAwZ,aAAA,kBAAAxZ,IAAA;;;;EAKA,SAAA+U,oBAAA/V;IAEA,IAAAgB,GACA4Y,gBAAA5Z,QAAA,IACAqa,4BAAAT,cAAAtV;;;;IAKAgW,+BAAAta;IAEA,IAAA+Z,qBAAAH,cAAArT,UAAA,OACAyT,wBAAAha,QAAAJ,KAAA,KAAAgL,WACAqP,6BAAAhe,EAAA8d,oBAAAna,KAAA,KAAAgL,WACA6P,gBAAAxe;IACAye,oBAAAD,cAAAE,MAAA,OACA5W,cAAA9H,EAAA,UAAAie,OAAAH,oBAAAW;;;;IAKAtF,4BAAA;;IAGAjX,YAAAwI,IAAA5C,YAAA;MACA/E,UAAA;MACA4F,OAAAyV,0BAAAzV,OAAAvI,OAAA8d,eAAA5P;MACAzF,MAAAuV,0BAAAvV,MAAAzI,OAAA+d,eAAA7P;MACA7K,SAAA;MACAP,SAAA;MACAC,QAAA;MACAuF,OAAA0V,0BAAA1V,QAAA4F;;IAEAxG,YAAAwV,YAAA;;IAGA,KAAAvY,IAAA,GAAAA,IAAAgZ,sBAAAvZ,QAAAO,KAAA;MACA7C,YAAA8b,2BAAAjZ,IAAAuE,UAAAkE,WAAAjE,wBAAAwU,sBAAAhZ;;IAGA,OAAA+C;;;;;;;;;;EAWA,SAAA6U,cAAA5Y;IAEA,IAAA4a;IAEA,KAAAA,OAAAnF;MACA,IAAAoF,OAAAC,UAAAC,eAAAC,KAAAvF,aAAAmF;QACA,IAAA5a,QAAAG,GAAAya,MAAA;UACA,IAAApa,QAAAyV;YACAvV,QAAAuB,IAAA,4BAAA2Y,MAAA,KAAA;;UAEA,OAAAnF,YAAAmF,KAAA5a;;;;IAKA,IAAAQ,QAAAyV;MACAvV,QAAAuB,IAAA,YAAAjC,QAAA,GAAAib,SAAA;;IAGA,OAAAjb;;;;;;;;EASA,SAAAiY;;IAGAzb,KAAA8b,IAAA;;IAGAjD,+BAAA;;EAGA,SAAA6F,mBAAAra;IACA,OAAArE,KAAA,OAAAqE,WAAA5E,EAAAuB,SAAAhB,KAAA,IAAAqE;;EAGA,SAAAqX,QAAAzb;IACA,IAAAD,SAAA0e,mBAAAze,MAAAc;;;MAGAub;;;;;;;;EASA,SAAA/E,YAAAtX;;IAGA0e;IAEAlI,eAAAjD,gBAAAoL;IACAnI,eAAAnD,aAAAsL;;IAGA7F,eAAA;;IAGAR,OAAAqD,KAAA,cAAA3b;IAEAsH,cAAAqX;IACA5e,OAAA4e;IACApb,UAAAob;IAEA,IAAA5a,QAAAyV;MACAvV,QAAAuB,IACA,qDACA;;;;;;EAQA,SAAAmX;IAEA,IAAAiC,WAAArG,eACA/Y,EAAA;MACA0d,IAAA/b,UAAAC;;IAEAM,YAAAwI,IAAA0U,SAAA;MACAlc,SAAA;MACAC,QAAA;MACA0F,KAAA;MACAF,MAAA;MACA5F,UAAA;MACAsc,UAAA;;IAEA,OAAAD;;;;;EAMA,SAAAF;IACA,IAAAnG,aAAA;MACAA,YAAAlV;MACAkV,cAAA;;;;;;;EASA,SAAAuG;IACA,OAAA/e,QAAAA,KAAA;;;EAKA,IAAAgE,MAAA;IACAE,QAAAuB,IACA,oEACA;;;;;IAOAlG,SAAAyf,kBAAA;MACAhG,YAAAA;MACA,OAAAA;;IAGAzZ,SAAA0f,mBAAA;MACAxF,kBAAAA;MACA,OAAAA;;;EAIA;IACAsF,YAAAA;IACAzC,WAAAA;IACAC,aAAAA;;;;ACjwBAhd,SAAAC,OAAA,OAAA","file":"hlb.js.map","sourcesContent":["\"use strict\";\n","/**\n * In order to keep each module as clear as possible we take out some irrelevant code to the separate files.\n * The module represents HLB event handlers.\n * For example, we want to only allow scroll for HLB and its entities when HLB is open.\n * Stop event from bubbling up to window/document object.\n */\n// TODO: Call this module scrolling.js\nsitecues.define('hlb/event-handlers',['$' ], function($) {\n\n  /////////////////////////\n  // PRIVATE VARIABLES\n  ////////////////////////\n\n  //  Wheel event callback, must be scoped at the module level because\n  //  we create this event callback every time the HLB opens because\n  //  the callback requires a reference to the HLB element...s\n  var wheelEventCallback,\n\n    isCapturing;\n\n  /**\n   * [releaseWheelEvents disables the capturing of wheel events.  This is called once the HLB is closed.]\n   */\n  function releaseWheelEvents() {\n\n    window.removeEventListener('wheel', wheelEventCallback);\n\n    isCapturing = false;\n  }\n\n  /**\n   * [captureWheelEvents captures wheel events while the HLB is open. ]\n   * @param  {[jQuery Element]} $hlb [The HLB element]\n   */\n  function captureWheelEvents($hlb) {\n\n    if (isCapturing) {\n      return; // Already capturing\n    }\n\n    isCapturing = true;\n\n    /**\n     * [wheelHandler listens to all scroll events in the window and prevents scroll outside of HLB]\n     * @param  {[DOM scroll event]} e [Object representing scrolling data]\n     * TODO: Determine if this is the best way to handle this situation.  The reason we create a new\n     * function every time we want to listen to wheel events is because the callback needs reference\n     * to the HLB element. That is the problem that this approach solves, probably isn't ideal...\n    */\n    wheelEventCallback = function (event) {\n\n      // Get the deltaY value when the user scrolls (how fast the user is scrolling)\n      var deltaY = parseInt(event.deltaY || -event.wheelDeltaY);  // parseInt() sanitizes by converting strange -0 value to 0\n\n      // Sometimes there is no deltaY number, or a deltaY of \"0\"\n      // (when the user is scrolling horizontally along X)\n      if (!deltaY) {\n\n        // We prevent the scroll event for horizontal scrolls\n        return preventScroll(event);\n      }\n\n      /*\n\n        Dimension Calculations:\n\n                   /////////\n                 ↑ /       / ↕ Scroll Top\n          Scroll | XXXXXXXXX\n          Height | X       X ↑\n                 | X  HLB  X | Client Height\n                 | X       X ↓\n                 | XXXXXXXXX\n                 ↓ /       / ↕ Scroll Bottom\n                   /////////\n\n      */\n\n      // Get the dimensions\n      var elem             = $hlb[0],       // The HLB Element\n          scrollHeight     = elem.scrollHeight,    // The total height of the scrollable area\n          scrollTop        = elem.scrollTop,       // Pixel height of invisible area above element (what has been scrolled)\n          clientHeight     = elem.clientHeight,    // The height of the element in the window\n          scrollBottom     = scrollHeight-scrollTop-clientHeight, // The pixels height invisible area below element (what is left to scroll)\n          scrollingDown    = deltaY > 0,           // If the user is scrolling downwards\n          scrollingUp      = deltaY < 0,           // If the user is scrolling upwards\n          scrolledToBottom = scrollBottom <= 1,    // There are now more invisible pixels below the element\n          scrolledToTop    = elem.scrollTop <= 1;  // There are now more invisible pixels above the element\n\n\n      // Prevent any scrolling if the user is:\n      //   a) Not scrolling on the HLB element directly.\n      //   b) Not scrolling on a decendant of the HLB element.\n      if ($hlb[0] !== event.target && !$.contains(elem, event.target))  {\n        preventScroll(event);\n      }\n\n      // If the user is scrolling down, (but has not reached the bottom), and\n      // is trying to scroll down more pixels that there are left to scroll...\n      if (scrollingDown && deltaY >= scrollBottom) {\n        // ...set the scroll to the bottom...\n        elem.scrollTop = elem.scrollHeight;\n        // ...and stop scrolling.\n        preventScroll(event);\n      }\n\n      // If the user tries to scroll down past the bottom...\n      if (scrolledToBottom && scrollingDown) {\n        preventScroll(event); // ...stop scrolling.\n      }\n\n      // If the user is scrolling up, (but has not reached the top), and is\n      // trying to scroll up more pixels that there are left to scroll...\n      if (scrollingUp && scrollTop-(-deltaY) <= 0) {\n        // ...set the scroll to the top...\n        elem.scrollTop = 0;\n        // ...and stop scrolling.\n        preventScroll(event);\n      }\n\n      // If the user tries to scroll down past the bottom...\n      if (scrolledToTop && scrollingUp) {\n        preventScroll(event); // ...stop scrolling.\n      }\n\n      // Prevent the original scroll event\n      function preventScroll() {\n        event.preventDefault();\n        event.returnValue = false;\n        return false;\n      }\n\n    };\n\n\n    // Trap the mousewheel events (wheel for all browsers except Safari, which uses mousewheel)\n    window.addEventListener('wheel', wheelEventCallback);\n  }\n\n  return {\n    releaseWheelEvents: releaseWheelEvents,\n    captureWheelEvents: captureWheelEvents\n  };\n\n});\n\n","sitecues.define('hlb/constants',[], function() {\n\n    var constants = {};\n\n    // IDs\n\n    constants.HLB_WRAPPER_ID           = 'sitecues-hlb-wrapper'; // ID for element which wraps HLB and Dimmer elements\n    constants.HLB_ID                   = 'sitecues-hlb';         // ID for $hlb\n    constants.HLB_READY                = 'hlb/ready';            //Event fired when HLB is created\n\n    // Other\n    constants.MAX_ZINDEX               = 2147483647;\n\n    return constants;\n});\n\n","// */\n//   This module styles the HLB by filtering attributes, styles, dom elements,\n//   sets background, sets default styles, computes some styles,\n//   and cloned child styles from the original element to the HLB.\n//  */\nsitecues.define(\n  'hlb/styling',[\n    '$',\n    'page/util/common',\n    'run/conf/preferences',\n    'hlb/constants',\n    'run/inline-style/inline-style',\n    'run/util/array-utility'\n  ],\n  function (\n    $,\n    common,\n    pref,\n    constants,\n    inlineStyle,\n    arrayUtil\n  ) {\n  'use strict';\n\n  ///////////////////////////\n  // PUBLIC PROPERTIES\n  //////////////////////////\n\n  // All HLB instances will use these default padding and border values.\n  var defaultPadding = 4;\n  var defaultBorder  = 3;\n\n  // Transition property used for hlb animation (-webkit, -moz)\n  // This is used to transition the transform property for HLB\n  // inflation/deflation animation\n  var transitionProperty = 'transform ';\n\n  ///////////////////////////\n  // PRIVATE VARIABLES\n  ///////////////////////////\n\n  var\n      // How many ancestors do we move up the chain until we find a background image\n      // to use for the $hlb background image.\n      BACKGROUND_IMAGE_ANCESTOR_TRAVERSAL_COUNT = 3,\n\n      // Default background color for HLB, if HLB is NOT an image.\n      HLB_DEFAULT_BACKGROUND_COLOR = '#fff',\n\n      // Default text color for HLB\n      HLB_DEFAULT_TEXT_COLOR = '#000',\n\n      // Default background color for HLB, if HLB is an image.\n      HLB_IMAGE_DEFAULT_BACKGROUND_COLOR = '#000',\n\n      // Remove these styles from the HLB, but NOT its children.\n      HLBCSSBlacklist = [\n        'padding',\n        'margin',\n        'left',\n        'top',\n        'right',\n        'bottom',\n        'box-shadow',\n        'transform',\n        '-webkit-transform',\n        '-moz-transform',\n        '-ms-transform',\n        '-webkit-transform-origin',\n        '-moz-transform-origin',\n        '-ms-transform-origin',\n        'transition',\n        '-webkit-transition',\n        'width',\n        'height',\n        '-webkit-text-fill-color',\n        'min-height',\n        'min-width',\n        'max-height',\n        'max-width',\n        '-ms-scroll-limit-y-max' // Necessary to scroll the HLB in IE\n      ],\n\n      // What child elements of the HLB do we want to remove after a clone.\n      HLBElementBlacklist = [\n        'script',\n        'iframe'\n      ],\n\n      // Remove ID from HLB because the speech module sets the ID for TTS to work\n      HLBAttributeBlacklist = [\n        'id',\n        'class'\n      ],\n\n      // Default css styles for HLB\n      defaultHLBStyles  = {\n        'position'         : 'absolute',   // Doesn't interfere with document flow\n        'zIndex'           : constants.MAX_ZINDEX,  // Max z-index for HLB overlay\n        'border'           : defaultBorder + 'px solid #000',\n        'padding'          : defaultPadding,\n        'margin'           : 0,            // Margin isn't necessary and only adds complexity\n        'borderRadius'     : '4px',        // Aesthetic purposes\n        'boxSizing'        : 'content-box', // Default value.  If we do not force this property, then our positioning algorithm must be dynamic...\n        'visibility'       : 'visible',\n        'maxWidth'         : 'none',\n        'maxHeight'        : 'none',\n        'opacity'          : 1\n      };\n\n  //////////////////////////\n  // PRIVATE FUNCTIONS\n  //////////////////////////\n\n  /**\n   * [filterElements removes HLBElementBlacklist elements from the HLB element, but not its children]\n   * @param  {[DOM element]} $hlb [HLB element]\n   */\n  function filterBlacklistedElements ($hlb) {\n    $hlb.find(HLBElementBlacklist.join(',')).remove();\n  }\n\n  /**\n   * [filterHiddenElements removes elements from the HLB that the picker deems unwanted.]\n   * @param  {[jQuery Element]} $hlb    [HLB element]\n   * @param  {[jQuery Element]} $picked [Element picked by picker]\n   * @param  {[Array]} hiddenElements [Array of elements to remove]\n   */\n  function filterHiddenElements ($hlb, $picked, hiddenElements) {\n\n    var pickedElementIsListItem = $picked.is('li'),\n        pickedDescendants      = $picked.find('*').get(),\n        hlbDescendants         = (pickedElementIsListItem ? $hlb.children().find('*') : $hlb.find('*')).get();\n\n    if (SC_DEV) {\n      if (pickedDescendants.length !== hlbDescendants.length) {\n        console.warn('There is not a 1:1 mapping for filterHiddenElements!');\n      }\n    }\n\n    pickedDescendants.forEach(function (element, index) {\n      if (hiddenElements.get(element)) {\n        $(hlbDescendants[index]).remove();\n      }\n    });\n  }\n\n  /**\n   * [filterElements removes css styles in HLBCSSBlacklist from the HLB element, but not its children]\n   * @param  {[DOM element]} $hlb [HLB element]\n   */\n  function filterStyles($hlb) {\n    for (var i = 0; i < HLBCSSBlacklist.length; i += 1) {\n      inlineStyle.removeProperty($hlb[0], HLBCSSBlacklist[i]);\n    }\n  }\n\n  /**\n   * [filterAttributes removes html attributes in HLBAttributeBlacklist]\n   * @param  {[DOM element]} $hlb [HLB element]\n  */\n  function filterAttributes($hlb) {\n    for (var i = 0; i < HLBAttributeBlacklist.length; i += 1) {\n      $hlb.removeAttr(HLBAttributeBlacklist[i]);\n    }\n  }\n\n  /**\n   * [getDescendantStyles computes HLB child element styles]\n   * @param  {[jQuery element]} $descendant                    [The current HLB element child we are styling]\n   * @param  {[Boolean]} hlbWidthGreaterThanSafeAreaWidth [True if the HLB width >= safe area width]\n   * @param  {[Object]} foundationDescendantStyle        [CSS styles returned from window.getComputedStyle]\n   * @return {[Object]}                                   [Styles to be consumed by jQuery.css]\n   */\n  function getDescendantStyles ($descendant, foundationDescendantStyle) {\n\n    // Defaut css styles for all HLB descendants\n    var styles = {\n          'webkitTextFillColor': '',\n          'textDecoration'     : 'none',\n          'bottom'             : 0,      // Added because bug found on TexasAT, first LI (About TATN) of \".horizontal rootGroup\"\n          'height'             : 'auto', // Added to fix cases where text overlapped vertically, like on eeoc\n          'min-width'          : ''\n        },\n        fontSize       = parseFloat(foundationDescendantStyle.fontSize),\n        lineHeight     = parseFloat(foundationDescendantStyle.lineHeight),\n        textDecoration = foundationDescendantStyle.textDecoration;\n\n    // NOTE: Copying cssText directly is not sufficient for copying textDecorations.\n    //       ts.dev.sitecues.com/hlb/styling/text-decoration.html\n    if (textDecoration.indexOf('underline') !== -1) {\n\n      styles.textDecoration = 'underline';\n\n    } else if (textDecoration.indexOf('overline') !== -1) {\n\n      styles.textDecoration = 'overline';\n\n    } else if (textDecoration.indexOf('line-through') !== -1) {\n\n      styles.textDecoration = 'line-through';\n\n    }\n\n    // Implemented to fix http://www.windoweyesforoffice.com/sitecues/index.php when HLBing\n    // Window-Eyes in header.  Applause: #1224073\n    if (fontSize > lineHeight) {\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: Increasing line height.',  'background:orange;');\n      }\n      styles.lineHeight = fontSize + 'px';\n    }\n\n    // This fixes a problem with the HLB on TexasAT home page when opening the entire \"News & Events\"\n    // ALSO...it fixes another problem that used a different fix.  I removed the old fix\n    // and will re-enable it if hlb content overlaps\n    //       // NOTE: Fix implemented because of opening HLB on http://abclibrary.org/teenzone on the #customheader\n    //                Fixes children overlapping children within the HLB.  Comment out the line below to\n    //                experience this problem.\n    if (foundationDescendantStyle.position === 'absolute') {\n      styles.position = 'static';\n      styles.display  = 'inline-block';\n    }\n\n    // Implemented to fix very long link that wasn't wrapping in the HLB on www.faast.org/news\n    if ($descendant.is('a')) {\n      styles.wordWrap = 'break-word';\n    }\n\n    return styles;\n\n  }\n\n  function getBulletWidth ($element, elementComputedStyle) {\n\n    //If the HLB is a list AND it has bullets...return their width\n    if (elementComputedStyle.listStyleType !== 'none' || elementComputedStyle.listStyleImage !== 'none') {\n      return common.getBulletWidth($element[0], elementComputedStyle);\n    }\n\n    return 0;\n  }\n\n  /**\n   * [isTransparent determines if a particular style is transparent]\n   * @param  {[CSS style property]}  style [Used for background color]\n   * @return {Boolean}       [True if transparent, false otherwise]\n   */\n  function isTransparent (style) {\n    return (style.indexOf('rgba') !== -1 && (style.indexOf('.') !== -1 || style.charAt(style.length - 2) === '0')) ||\n            style === 'transparent';\n  }\n\n  /**\n   * [getNonEmptyBackgroundImage determines what background image will be used\n   * for the HLB element.  It moves up the ancestor chain of the original element\n   * and returns the first background image it encounters.]\n   * @param  {[DOM element]} $picked [The picked element chosen by the picker]\n   * @return {[String]}                       [CSS background-image property]\n   */\n  function getNonEmptyBackgroundImage ($picked, ancestorCount) {\n    var backgroundStyles = {},\n        $parents = $picked.parents();\n\n    $parents.each(function (index) {\n      if (index >= ancestorCount) {\n        return false;\n      }\n  \n      var $ancestor = $(this);\n  \n      if ($ancestor.css('backgroundImage') !== 'none') {\n        backgroundStyles.backgroundImage      = $ancestor.css('backgroundImage');\n        backgroundStyles.backgroundRepeat     = $ancestor.css('backgroundRepeat');\n        backgroundStyles.backgroundAttachment = 'local';\n        backgroundStyles.$ancestor            = $ancestor;\n        return false;\n      }\n    });\n\n    return backgroundStyles;\n  }\n\n  /**\n   * [getNonTransparentBackground determines what background color will be used\n   * for the HLB element. It moves up the ancestor chain of the original element\n   * and returns the first background color it encounters that isn't transparent]\n   * @param  {[DOM element]} $picked [The original element chosen by the picker]\n   * @return {[String]}                       [CSS background-color property]\n   */\n  function getNonTransparentBackground ($picked) {\n\n    var newBackgroundColor,\n        parents = $picked.parents();\n\n    parents.each(function () {\n      if (!isTransparent($(this).css('backgroundColor'))) {\n        newBackgroundColor = $(this).css('backgroundColor');\n        return false;\n      }\n    });\n\n    return newBackgroundColor;\n\n  }\n\n  /**\n   * [getHLBBackgroundColor\n       If the $hlbElement has a transparent background color, we should find one\n       by looking up the entire ancestor chain and use the first non-transparent\n       color we find.  Otherwise, if the $hlbElement is not an image, we default\n       to a white background color.  If it is an image, however, the background\n       color is black.]\n   * @param  {[jQuery element]} $originalElement     [The original element chosen by picker]\n   * @param  {[Object]} elementComputedStyle         [The original elements computed styles]\n   * @return {[String]}                              [The HLB background color]\n   */\n  function getHLBBackgroundColor ($picked, elementComputedStyle) {\n\n    var newBackgroundColor;\n\n    if (isTransparent(elementComputedStyle.backgroundColor)) {\n\n      if ($picked.is('img')) {\n\n        return HLB_IMAGE_DEFAULT_BACKGROUND_COLOR;\n\n      } else {\n\n        newBackgroundColor = getNonTransparentBackground($picked);\n\n        if (newBackgroundColor) {\n\n          return newBackgroundColor;\n\n        } else {\n\n          return HLB_DEFAULT_BACKGROUND_COLOR;\n\n        }\n\n      }\n\n    }\n\n    return elementComputedStyle.backgroundColor;\n\n  }\n\n  /**\n   * [getHLBBackgroundImage determines the background image to be used by the $hlbElement]\n   * @param  {[jQuery element]} $picked   [The picked element chosen by the picker.]\n   * @param  {[Object]} elementComputedStyle     [The original elements computed style]\n   * @return {[String]}                          [The background image that will be used by the $hlbElement]\n   */\n  function getHLBBackgroundImage ($picked, elementComputedStyle) {\n    var newBackgroundImage;\n\n    // If the original element doesnt have a background image and the original element has a transparent background...\n    if (elementComputedStyle.backgroundImage === 'none' &&\n        isTransparent(elementComputedStyle.backgroundColor)) {\n\n      newBackgroundImage = getNonEmptyBackgroundImage($picked, BACKGROUND_IMAGE_ANCESTOR_TRAVERSAL_COUNT);\n\n      if (newBackgroundImage) {\n        return newBackgroundImage;\n      }\n    }\n\n    return {\n      'backgroundImage'     : elementComputedStyle.backgroundImage,\n      'backgroundRepeat'    : elementComputedStyle.backgroundRepeat,\n      'backgroundAttachment': 'local'\n    };\n  }\n\n  /**\n   * [getHLBLeftPadding is required to visually encapsulate bullet points within the HLB if the\n   * $hlb is itself a <ul> or <ol> that uses bullet points.\n   * @param  {[jQuery element]} $foundation   [The original element chosen by the picker.]\n   * @param  {[Object]} computedStyle  [The original elements computed style]\n   * @return {[Integer]}                      [The HLB left-padding]\n   */\n  function getHLBLeftPadding ($foundation, computedStyle) {\n\n    return defaultPadding + getBulletWidth($foundation, computedStyle);\n\n  }\n\n  /**\n   * [getHLBDisplay determines $hlbElement will use for its CSS display]\n   * @param  {[Object]} computedStyle [The original elements computed styles]\n   * @return {[String]}                      [The display the $hlbElement will use]\n   * NOTE:\n      // If the original elements display type is a table, force a display type of\n      // block because it allows us to set the height.  I believe display table\n      // is mutually exclusive to minimum height/minimum width.\n      //\n      // http://stackoverflow.com/questions/8739838/displaytable-breaking-set-width-height\n      //\n      // I found the issue on the eBank site that we maintain.  Make the HLB open a table\n      // and open the developer console and attempt to alter the height/width attributes.\n      //\n      // TODO: actually prove these beliefs\n   */\n  function getHLBDisplay (computedStyle) {\n\n    if (computedStyle.display === 'table') {\n      return 'block';\n    }\n\n    return computedStyle.display;\n\n  }\n\n   /**\n   * [shouldRemovePadding determines if children of our HLB have padding that should be\n   * removed because the highlight clips padding.]\n   * @param  {[jQuery Element]} $child [Child element of the HLB]\n   * @param  {[Object]} initialHLBRect [highlight rectangle]\n   * @return {[Boolean]}               [True: Remove Padding. False: Do Nothing]\n   */\n  function shouldRemovePadding ($child, initialHLBRect) {\n\n    var childBoundingClientRect = $child[0].getBoundingClientRect(),\n        childLeftPadding        = parseFloat($child.css('paddingLeft')),\n        childRightPadding       = parseFloat($child.css('paddingRight')),\n        childTopPadding         = parseFloat($child.css('paddingTop')),\n        childBottomPadding      = parseFloat($child.css('paddingBottom'));\n\n    if ($child.is('br, option') || childBoundingClientRect.width === 0) {\n      return;\n    }\n\n    if ((childBoundingClientRect.left   < initialHLBRect.left   && childLeftPadding   > 0) ||\n        (childBoundingClientRect.right  > initialHLBRect.right  && childRightPadding  > 0) ||\n        (childBoundingClientRect.top    < initialHLBRect.top    && childTopPadding    > 0) ||\n        (childBoundingClientRect.bottom > initialHLBRect.bottom && childBottomPadding > 0)\n      ) {\n\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: Removing child padding.',  'background:orange;');\n      }\n      return true;\n    }\n\n  }\n\n  /**\n   * [getChildPadding computes and returns the padding for a child element of the HLB.  Taking into account the\n   * initialHLBRect, clipping padding is something to be done to preserve that HLB size.]\n   * @param  {[jQuery Element]} $child [Child element of the HLB]\n   * @param  {[Object]} initialHLBRect [highlight rectangle]\n   * @return {[Object]}                [Padding styles for a child element]\n   */\n  function getChildPadding ($child, initialHLBRect) {\n\n    var childBoundingClientRect = $child[0].getBoundingClientRect(),\n        childLeftPadding        = parseFloat($child.css('paddingLeft')),\n        childRightPadding       = parseFloat($child.css('paddingRight')),\n        childTopPadding         = parseFloat($child.css('paddingTop')),\n        childBottomPadding      = parseFloat($child.css('paddingBottom')),\n        paddingStyles           = {},\n        zoom                    = pref.get('zoom') || 1;\n\n    if ((childBoundingClientRect.left < initialHLBRect.left && childLeftPadding > 0)) {\n      paddingStyles.paddingLeft = childLeftPadding - (initialHLBRect.left - childBoundingClientRect.left) / zoom;\n    }\n\n    if (childBoundingClientRect.right > initialHLBRect.right && childRightPadding > 0) {\n      paddingStyles.paddingRight = childRightPadding - (childBoundingClientRect.right - initialHLBRect.right) / zoom;\n    }\n\n    if (childBoundingClientRect.top < initialHLBRect.top && childTopPadding > 0) {\n      paddingStyles.paddingTop = childTopPadding - (initialHLBRect.top - childBoundingClientRect.top) / zoom;\n    }\n\n    if (childBoundingClientRect.bottom > initialHLBRect.bottom && childBottomPadding > 0) {\n      paddingStyles.paddingBottom = childBottomPadding - (childBoundingClientRect.bottom - initialHLBRect.bottom) / zoom;\n    }\n\n    return paddingStyles;\n\n  }\n\n  /**\n   * [initializeHLBElementStyles initializes the HLB elements styles by directly copying\n   *  the styles from the original element.]\n   * @param  {[jQuery element]} $foundation [The original element chosen by the picker]\n   * @param  {[jQuery element]} $hlb      [The HLB element]\n   */\n  function initializeHLBElementStyles ($foundation, $hlb) {\n    inlineStyle($hlb[0]).cssText =  getComputedStyleCssText($foundation[0]);\n  }\n\n   /**\n   * [initializeHLBDescendantStyles initializes the styles of the children of the HLB element.\n   *   Step 1: Copy computed styles of original element children to hlb element children.\n   *   Step 2: Remove padding if element is cropped by the initialHLBRect (mouse highlight rect)\n   *   Step 3: Compute child styles that must override a direct copy of computed styles.\n   *   Step 4: Set child styles.\n   *   Step 5: Filter child attributes.\n   * ]\n    * @param  {[jQuery element]} $foundation [The original element chosen by the picker]\n    * @param  {[jQuery element]} $hlb      [The HLB element]\n    */\n\n  function initializeHLBDescendantStyles ($foundation, $hlb, initialHLBRect, hiddenElements) {\n\n    var foundation = $foundation[0],\n        hlb        = $hlb[0],\n        foundationDescendantStyle,\n        computedChildStyles,\n        removeMargins = true,\n        foundationNodes = [foundation],\n        hlbNodes        = [hlb];\n\n    // Iterate through each node in the foundation, in document order, and exclude elements we've identified as hidden\n    // This is important because it's very expensive to call getComputedStyleCssText for each node in the tree in Firefox\n    while (foundationNodes.length) {\n      var foundationNode = foundationNodes.pop(),\n          hlbNode        = hlbNodes.pop();\n      \n      if (hiddenElements.get(foundationNode)) {\n        continue;\n      }\n\n      initializeCloneStyle(foundationNode, hlbNode);\n\n      foundationNodes = foundationNodes.concat(arrayUtil.from(foundationNode.children));\n      hlbNodes        = hlbNodes.concat(arrayUtil.from(hlbNode.children));\n    }\n\n    function initializeCloneStyle(originalNode, cloneNode) {\n      var $original = $(originalNode),\n          $clone    = $(cloneNode);\n      // Cache the HLB child computed style\n      foundationDescendantStyle = getComputedStyle(originalNode);\n\n      // Copy the original elements child styles to the HLB elements child.\n      inlineStyle(cloneNode).cssText = getComputedStyleCssText(originalNode);\n\n      if (shouldRemovePadding($original, initialHLBRect)) {\n        inlineStyle.set(cloneNode, getChildPadding($original, initialHLBRect));\n      }\n\n      // Compute styles that are more complicated than copying cssText.\n      computedChildStyles = getDescendantStyles($original, foundationDescendantStyle);\n\n      // Added to fix HLB sizing when selecting last 2 paragraphs on http://www.ticc.com/\n      if (shouldRemoveHorizontalMargins($original, $foundation)) {\n        if (SC_DEV) {\n          console.log('%cSPECIAL CASE: Removing left and right margins.',  'background:orange;');\n        }\n        computedChildStyles.marginLeft  = 0;\n        computedChildStyles.marginRight = 0;\n      } else {\n        removeMargins = false;\n      }\n\n      // Set the childs css.\n      inlineStyle.set(cloneNode, computedChildStyles);\n\n      // Ran into issues with children inheriting styles because of class and id CSS selectors.\n      // Filtering children of these attributes solves the problem.\n      filterAttributes($clone);\n    }\n  }\n\n  /**\n   * [shouldRemoveHorizontalMargins determines if left-margin and right-margin can be removed from\n   * a child in the HLB element.]\n   * @param  {[jQuery Element]} $foundationDescendant [One of the children of the picked element.]\n   * @param  {[jQuery Element]} $foundation      [The element that is the model for the HLB (typically same as $pickedElement.]\n   * @return {[Boolean]}\n   */\n  function shouldRemoveHorizontalMargins ($foundationDescendant, $foundation) {\n\n    var $children     = $foundationDescendant.parent().children(),\n        $parents      = $foundationDescendant.parentsUntil($foundation),\n        parentCount   = $parents.length,\n        childCount    = $children.length,\n        hasOverlap    = false,\n        boundingRects = [],\n        i             = 0,\n        j             = 0;\n\n    if (childCount === 1) {\n      return true;\n    }\n\n    for (; i < parentCount; i += 1) {\n      if ($parents[i].getBoundingClientRect().left < $foundationDescendant[0].getBoundingClientRect().left) {\n        return false;\n      }\n    }\n\n    for (i = 0; i < childCount; i += 1) {\n      boundingRects.push($children[i].getBoundingClientRect());\n    }\n\n    for (i = 0; i < childCount; i += 1) {\n      for (; j < childCount; j += 1) {\n        if (i !== j) {\n          if (!(boundingRects[i].top    >= boundingRects[j].bottom ||\n                boundingRects[i].bottom <= boundingRects[j].top)) {\n            hasOverlap = true;\n          }\n        }\n      }\n    }\n\n    return !hasOverlap;\n\n  }\n\n  //////////////////////////\n  // PUBLIC FUNCTIONS\n  //////////////////////////\n\n  /**\n   * [setHLBChildTextColor determines and sets a text color for all HLB children so that they are in\n   * contrast with the background colors behind them.]\n   * @param {[jQuery element]} $hlb [The HLB element]\n   * NOTE: This function was created to fix a bug found on TexasAT home page navigation (Home, Sitemap, Contact Us)\n   */\n  function setHLBChildTextColor($hlb) {\n\n    var children;\n\n    // If the $hlb uses a background image then assume text is readable.\n    // TODO: improve this entire mechanism.\n    if ($hlb.css('backgroundImage') !== 'none') {\n      return;\n    }\n\n    children = $hlb.find('*');\n\n    // For every HLB child...\n    children.each(function () {\n\n      var textColor       = $(this).css('color'),\n          backgroundColor = $(this).css('backgroundColor'),\n          forceTextColor  = false;\n\n      // If the HLB child has a transparent background, or the background is the same color as the text,\n      // then we have to determine if we need to set the HLB childs text color by traversing the ancestor\n      // chain for.\n      if (isTransparent(backgroundColor) || textColor === backgroundColor) {\n\n        //  Check every ancestor up to and including the HLB element\n        $(this).parentsUntil($hlb.parent()).each(function () {\n\n          var parentBackgroundColor = $(this).css('backgroundColor');\n\n          // If we run into a parent who has a non-transparent background color\n          if (!isTransparent(parentBackgroundColor)) {\n\n            // Set the childs text color if the current text color and the first non-transparent\n            // background color are exactly the same.\n            if(textColor === parentBackgroundColor) {\n\n              forceTextColor = true;\n              return false;\n\n            } else {\n              return false;\n            }\n\n          }\n\n        });\n\n        if (forceTextColor) {\n          inlineStyle(this).color = HLB_DEFAULT_TEXT_COLOR;\n        }\n\n      }\n\n    });\n\n  }\n\n  /**\n   * [getHLBStyles gets the HLB styles.]\n   * @param {[DOM element]} $foundation [the original element]\n   * @return {[Object]} [CSS style object to be used by jQuery.css()]\n   */\n  function getHLBStyles($picked, $foundation, highlight) {\n\n    var originalElement       = $foundation[0],\n        originalElementRect   = originalElement.getBoundingClientRect(),\n        elementComputedStyle  = window.getComputedStyle(originalElement),\n        backgroundStyles      = getHLBBackgroundImage($picked, elementComputedStyle),\n        backgroundColor       = getHLBBackgroundColor($picked, elementComputedStyle),\n        calculatedHLBStyles   = {\n          'paddingLeft'  : getHLBLeftPadding($foundation, elementComputedStyle),\n          'display'      : getHLBDisplay(elementComputedStyle),\n          'left'         : originalElementRect.left + window.scrollLeft,\n          'top'          : originalElementRect.top + window.scrollTop\n        },\n        borderStyles = {\n          borderColor: highlight.hasDarkBackgroundColor ? highlight.highlightBorderColor : '#000'\n        },\n        animationOptimizationStyles = {\n          willChange: 'transform',\n          backfaceVisibility: 'hidden'\n        };\n\n    // If the background color is the same as the text color, use default text and background colors\n    if (backgroundColor === $foundation.css('color')) {\n      calculatedHLBStyles.color           = HLB_DEFAULT_TEXT_COLOR;\n      calculatedHLBStyles.backgroundColor = HLB_DEFAULT_BACKGROUND_COLOR;\n    } else {\n      calculatedHLBStyles.backgroundColor = backgroundColor;\n    }\n\n    // If the original element uses a background image, preserve original padding.\n    // This was implemented to fix SC-1830\n    // If the background image repeats, there is no need to preserve the padding.\n    if ($foundation.css('backgroundImage') !== 'none' && $foundation.css('backgroundRepeat') !== 'repeat') {\n      calculatedHLBStyles.paddingLeft   = $foundation.css('paddingLeft');\n      calculatedHLBStyles.paddingTop    = $foundation.css('paddingTop');\n      calculatedHLBStyles.paddingBottom = $foundation.css('paddingBottom');\n      calculatedHLBStyles.paddingRight  = $foundation.css('paddingRight');\n    } \n    else if (backgroundStyles.$ancestor) {\n      var $ancestor = backgroundStyles.$ancestor;\n\n      // If the background image repeats, there is no need to preserve the padding.\n      if ($ancestor.css('backgroundRepeat') !== 'repeat') {\n        calculatedHLBStyles.paddingLeft   = $ancestor.css('paddingLeft');\n        calculatedHLBStyles.paddingTop    = $ancestor.css('paddingTop');\n        calculatedHLBStyles.paddingBottom = $ancestor.css('paddingBottom');\n        calculatedHLBStyles.paddingRight  = $ancestor.css('paddingRight');\n      }\n    }\n\n    delete backgroundStyles.$ancestor;\n\n    return $.extend({},\n      defaultHLBStyles,\n      borderStyles,\n      calculatedHLBStyles,\n      backgroundStyles,\n      animationOptimizationStyles\n    );\n  }\n\n  /**\n   * [filter filters elements, attributes, and styles from the HLB]\n   * @param  {[DOM element]} $hlb [HLB]\n   */\n  function filter($hlb, $picked, hiddenElements) {\n\n    filterStyles($hlb);\n\n    filterHiddenElements($hlb, $picked, hiddenElements);\n\n    filterBlacklistedElements($hlb);\n\n    filterAttributes($hlb);\n\n  }\n\n  /**\n   * [initializeStyles clones the original elements styles and the styles of all of its children.]\n   * @param  {[DOM element]} $foundation [sanitized picked element]\n   * @param  {[DOM element]} $hlb [The HLB]\n   */\n  function initializeStyles($foundation, $hlb, initialHLBRect, hiddenElements) {\n\n    initializeHLBElementStyles($foundation, $hlb);\n\n    initializeHLBDescendantStyles($foundation, $hlb, initialHLBRect, hiddenElements);\n\n  }\n\n\n  /**\n   * [getComputedStyleCssText returns the cssText of an element]\n   * @param  {[DOM element]} element [DOM element]\n   * @return {[String]}              [Computed styles for an DOM element]\n   * NOTE: Fixes bug described here: [https://bugzilla.mozilla.org/show_bug.cgi?id=137687]\n   */\n  function getComputedStyleCssText(element) {\n\n    var style   = window.getComputedStyle(element),\n        cssText = '';\n\n    if (style.cssText !== '') {\n      return style.cssText;\n    }\n\n    for (var i = 0; i < style.length; i++) {\n      cssText += style[i] + ': ' + style.getPropertyValue(style[i]) + '; ';\n    }\n\n    return cssText;\n  }\n\n  return {\n    defaultBorder: defaultBorder,\n    defaultPadding: defaultPadding,\n    transitionProperty: transitionProperty,\n    setHLBChildTextColor: setHLBChildTextColor,\n    getHLBStyles: getHLBStyles,\n    filter: filter,\n    initializeStyles: initializeStyles,\n    getComputedStyleCssText: getComputedStyleCssText\n  };\n\n});\n\n","sitecues.define('hlb/safe-area',[], function() {\n\n  /////////////////////////\n  // PRIVATE VARIABLES\n  ////////////////////////\n\n  /////////////////////////\n  // PUBLIC PROPERTIES\n  ////////////////////////\n\n  // Default fraction of viewport hypotenuse that will define the safe area\n  var HLB_SAFE_AREA = 0.05;\n\n  /////////////////////////\n  // PRIVATE FUNCTIONS\n  ////////////////////////\n\n  /**\n   * [getUnsafePixels returns the amount of pixels from the\n   * edge of the viewport that defines the safe zone]\n   * @return {number} [pixels]\n   */\n  function getUnsafePixels() {\n\n    var hypotenuse = Math.sqrt(\n      Math.pow(window.innerHeight, 2) +\n      Math.pow(window.innerWidth, 2)\n    );\n\n    return hypotenuse * HLB_SAFE_AREA;\n\n  }\n\n  /////////////////////////\n  // PUBLIC METHODS\n  ////////////////////////\n\n  // Returns a rectangle the represents the area in which the HLB is allowed to occupy\n  function getSafeZoneBoundingBox() {\n\n    var unsafePixels = getUnsafePixels();\n\n    return {\n      'left'   : unsafePixels,\n      'top'    : unsafePixels,\n      'width'  : window.innerWidth - unsafePixels * 2,\n      'height' : window.innerHeight - unsafePixels * 2,\n      'right'  : window.innerWidth - unsafePixels,\n      'bottom' : window.innerHeight - unsafePixels\n    };\n  }\n\n  return {\n    getSafeZoneBoundingBox: getSafeZoneBoundingBox\n  };\n\n});\n\n","/**\n * HLB Positioning is responsible for positioning the HLB so that the HLB and the original element's midpoints\n * overlap or the HLB is as close to the original element while being encapsulated within the HLB_SAFE_AREA.\n * It is also responsible for calculating and setting the appropriate height/width of the HLB so that it is\n * encapsulated within the HLB_SAFE_AREA.\n */\nsitecues.define(\n  'hlb/positioning',[\n    '$',\n    'run/conf/pref',\n    'hlb/styling',\n    'page/util/common',\n    'page/util/element-classifier',\n    'hlb/safe-area',\n    'run/inline-style/inline-style'\n  ],\n  function (\n    $,\n    pref,\n    hlbStyling,\n    common,\n    elemClassifier,\n    hlbSafeArea,\n    inlineStyle\n  ) {\n  'use strict';\n\n  /////////////////////////\n  // PRIVATE VARIABLES\n  /////////////////////////\n\n  var CHAR_WIDTH_LIMIT = 50,  // Amount of characters that fits horizontally in HLB\n\n      originCSS,    // The HLB element's midpoint for animation\n      translateCSS, // The HLB element's translation for final position\n      isEditable = elemClassifier.isEditable,\n      isVisualMedia = elemClassifier.isVisualMedia,\n      isFormControl = elemClassifier.isFormControl;\n\n  //////////////////////////////\n  // PRIVATE FUNCTIONS\n  //////////////////////////////\n\n  /**\n   * [getChildWidth returns the max-width for any child within the HLB.]\n   * @param  {[DOM element]}    child       [Child element of the HLB]\n   * @param  {[jQuery element]} $hlb [The HLB element]\n   * @return {[Float]}                      [Max-width for child element]\n   */\n  function getChildWidth(child, $hlb) {\n\n    var hlbBoundingRect   = $hlb[0].getBoundingClientRect(),\n        childBoundingRect = child.getBoundingClientRect(),\n        inheritedZoom     = getInheritedZoom($hlb),\n        leftDiff          = childBoundingRect.left > hlbBoundingRect.left ? childBoundingRect.left - hlbBoundingRect.left : 0,\n        leftSum           = 0,\n        rightSum          = 0,\n        sum;\n\n    $(child).parentsUntil($hlb.parent()).addBack().each(function () {\n      var computedStyle = getComputedStyle(this);\n      // marginRight has been commented out to fix issue on faast.org when HLBing\n      // \"About\" in the top navigation.  I thought marginRight pushes its content to the left,\n      // but in that case apparently not.  The rule of what marginRight does may be dependent\n      // on other factors which I do not know, but removing it does not appear to break anything\n      // that this function originally fixed.\n      // rightSum += parseFloat(computedStyle.marginRight);\n      rightSum += parseFloat(computedStyle.paddingRight) +\n        parseFloat(computedStyle.borderRightWidth);\n\n      leftSum += parseFloat(computedStyle.marginLeft) +\n        parseFloat(computedStyle.paddingLeft) +\n          parseFloat(computedStyle.borderLeftWidth);\n    });\n\n    sum = leftSum + rightSum;\n\n    if (leftDiff && leftDiff > leftSum) {\n      leftDiff = leftDiff - leftSum;\n    } else {\n      leftDiff = 0;\n    }\n\n    return (hlbBoundingRect.width / inheritedZoom) - sum - leftDiff;\n\n  }\n\n  /**\n   * [limitChildWidth computes and sets the max-width for all HLB child elements if needed.]\n   * @param  {[jQuery Element]} $hlb [The HLB element]\n   */\n  function limitChildWidth($hlb) {\n\n    var fixit,\n        allHLBChildren,\n        hlbClientWidth,\n        childRect,\n        hlbRect,\n        scrollDiff,\n\n        // document.createRange() is used instead of scrollWidth because of content on http://www.nvblindchildren.org/\n        // If content is pushed outside of the HLB to the left, we must use document.createRange().\n        hlbElementRangeRect = document.createRange(),\n        hlbElementRangeWidth,\n        hlbElementContentRangeWidth,\n        borderLeftAndRight = (parseFloat($hlb.css('borderWidth')) || 0) * 2;\n\n    hlbElementRangeRect.selectNode($hlb[0]);\n\n    hlbElementRangeWidth = hlbElementRangeRect.getBoundingClientRect().width - borderLeftAndRight;\n\n    hlbElementRangeRect.selectNodeContents($hlb[0]);\n\n    hlbElementContentRangeWidth = hlbElementRangeRect.getBoundingClientRect().width - borderLeftAndRight;\n\n    if ($hlb[0].clientWidth < Math.max(hlbElementRangeWidth, hlbElementContentRangeWidth)) {\n\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: HLB child width limiting algorithm.', 'background:orange;');\n      }\n\n      allHLBChildren = $hlb.find('*');\n\n      fixit = true;\n\n      allHLBChildren.each(function () {\n        inlineStyle(this).maxWidth = getChildWidth(this, $hlb) + 'px';\n      });\n\n    }\n\n    hlbClientWidth = $hlb[0].clientWidth;\n\n    // The following attempts to mitigate the vertical scroll bar by\n    // setting the height of the element to the scroll height of the element.\n    mitigateVerticalScroll($hlb);\n\n    // Vertical scroll should only appear when HLB is as tall as the\n    // safe area height and its scrollHeight is greater than its clientHeight\n    addVerticalScroll($hlb);\n\n    if (fixit && $hlb[0].clientWidth < hlbClientWidth) {\n\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: HLB child width limiting algorithm because vertical scrollbar.', 'background:orange;');\n      }\n\n      scrollDiff = hlbClientWidth - $hlb[0].clientWidth;\n\n      hlbRect = $hlb[0].getBoundingClientRect();\n\n      allHLBChildren.each(function () {\n        // Performing this check because http://www.nvblindchildren.org/give.html top navigation..\n        childRect = this.getBoundingClientRect();\n        if (childRect.left < hlbRect.left || childRect.right + scrollDiff > hlbRect.right) {\n          inlineStyle(this).maxWidth = (parseFloat(getComputedStyle(this).maxWidth) - scrollDiff) + 'px';\n        }\n      });\n\n    }\n\n    fixOverflowWidth($hlb);\n  }\n\n  /**\n   * [isEligibleForConstrainedWidth determines if the HLB is eligible for limiting its width to 50 characters]\n   * @param  {[jQuery element]} $hlb [HLB element]\n   * @return {[Boolean]}     [if true, limit the width]\n   */\n  function isEligibleForConstrainedWidth($hlb) {\n\n    var allowWrapping = true;\n\n    // Return true if there are no other elements in the HLB that will affect the positioning\n    // of this element\n    // hlbElement\n    //   \\\n    //    Grandparent\n    //        \\\n    //        Parent (no siblings)\n    //          \\\n    //           I am a loner! :(\n\n\n    function hasSiblings(element) {\n      return element.parentNode.childElementCount > 1;\n    }\n\n    function isLonerElement(element) {\n      var isLoner = true;\n      $(element).closest($hlb).each(function(index, elemToCheckForSiblings) {\n        isLoner = $hlb[0] === elemToCheckForSiblings || !hasSiblings(elemToCheckForSiblings);\n        return isLoner;\n      });\n      return isLoner;\n    }\n\n    // Return true if there is CSS that will cause an elements position to be based on another element's position\n    function hasPositioningCss(css) {\n      return css.position !== 'static' || css.float !== 'none' || css.display !== 'table-cell';\n    }\n\n    // Returns false when an element is not wrappable or, if part of an HLB,\n    // wrapping the HLB would be bad (would break the intended layout, for example).\n    function testAllowWrapping(index, element) {\n      var css = getComputedStyle(element);\n\n      allowWrapping = (css.whiteSpace === 'normal' || css.whiteSpace === 'preWrap') &&\n        (!hasPositioningCss(css) || isLonerElement(element)) &&\n        !isVisualMedia(element) && !isFormControl(element) && !isEditable(element);\n\n      // This fixed something on gwmicro, but broke other things.\n      // if (css.display === 'table-cell') {\n      //   allowWrapping = false;\n      // }\n\n      return allowWrapping; // Once false, the each() loop will stop as well\n    }\n\n    // Fixes case on www.reddit.com/r/science when opening HLB on \"The New Reddit Journal of Science\"\n    // We use max-width: 50ch to limit the width.  In this particular case, the font-size of the element\n    // is 0, which causes the units of width limiting to have no effect because they are multiples of 0.\n    if (+$hlb.css('fontSize').charAt(0) === 0) {\n      return;\n    }\n\n    // Easiest way to fix issue when HLBing\n    // \"Summary Table Voluntary Product Accessibility Template\" on http://www.gwmicro.com/Window-Eyes/VPAT/\n    if ($hlb.is('table')) {\n      return;\n    }\n\n    $hlb.find('*').addBack().each(testAllowWrapping);\n\n    return allowWrapping;\n\n  }\n\n  /**\n   * [getExtraLeftPadding returns addition left-padding of the HLB]\n   * @param  {[jQuery element]} $hlb [HLB element]\n   * @return {[integer]}                    [The additional left-padding]\n   */\n  function getExtraLeftPadding($hlb) {\n    return parseInt($hlb.css('paddingLeft')) - hlbStyling.defaultPadding;\n  }\n\n  /**\n   * [midPointDiff computes the distance between the midpoints of 2 rects]\n   * @return {[object]}         [x and y difference between the 2 midpoints]\n   */\n  function midPointDiff(rect1, rect2) {\n\n    var br1x = rect1.left + rect1.width / 2,\n        br1y = rect1.top + rect1.height / 2,\n        br2x = rect2.left + rect2.width / 2,\n        br2y = rect2.top + rect2.height / 2;\n\n    return {\n      'x': br1x - br2x,\n      'y': br1y - br2y\n    };\n\n  }\n\n  /**\n   * [limitWidth limits the width of the HLB to X characters, if eligible]\n   * @param  {[jQuery element]} $originalElement    [original element]\n   * @param  {[jQuery element]} $hlb         [HLB element]\n   * @param  {[Integer]}        characterWidthLimit [number of characters the HLB is restricted to horizontally]\n   */\n  function limitWidth($originalElement, $hlb, characterWidthLimit) {\n\n    // If the HLB is eligible for limiting the width to\n    // characterWidthLimit characters\n    if (isEligibleForConstrainedWidth($hlb)) {\n\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: 50 Character width limit.',  'background:orange;');\n      }\n\n      // 'ch' units are equal to the width of the \"0\" character\n      inlineStyle($hlb[0]).maxWidth = characterWidthLimit + 'ch';\n    }\n\n  }\n\n  /**\n   * [mitigateVerticalScroll increases the height of the HLB to fit its content.]\n   * @param  {[jQuery element]} $hlb [HLB]\n   */\n  function mitigateVerticalScroll($hlb) {\n    var hlb = $hlb[0];\n    // If the HLB has a vertical scrollbar and has a height less than the safe zone height\n    if (common.hasVertScroll(hlb) &&\n        scaleRectFromCenter($hlb).height < hlbSafeArea.getSafeZoneBoundingBox().height) {\n\n      // Set to the scroll height minus 4 (half of the padding)\n      // It is necessary to subtract the padding because scrollHeight includes padding.\n      inlineStyle(hlb).height = (hlb.scrollHeight - parseInt(getComputedStyle(hlb).paddingBottom)) + 'px';\n      // Now that we have set the height of the cloned element to the height of the scroll height...\n      // we need to test that the element's height does not exceed the height of the safe area.\n      constrainHeightToSafeArea($hlb);\n    }\n  }\n\n  /**\n   * [constrainPosition computes the distance between a rectangle and the\n   * minimum distance it must travel to occupy another rectangle]\n   * @param  {[DOM element]} element   [any element of a DOM]\n   * @param  {[object]}      container [the bounding rect]\n   * @return {[object]}                [x and y difference]\n   */\n  function constrainPosition(element) {\n\n    var offset = {\n          'x': 0,\n          'y': 0\n        },\n\n        container = hlbSafeArea.getSafeZoneBoundingBox();\n\n    if (element.left < container.left) {\n      offset.x -= container.left - element.left;\n    }\n    if (element.top < container.top) {\n      offset.y -= container.top - element.top;\n    }\n    if (element.left + element.width > container.right) {\n      offset.x += (element.left + element.width) - container.right;\n    }\n    if (element.top + element.height > container.bottom) {\n      offset.y += (element.top + element.height) - container.bottom;\n    }\n    return offset;\n  }\n\n  /**\n   * [constrainHeightToSafeArea constrains the height of the HLB to the safe area.\n   * If HLB is an image, then it keeps the aspect ratio.]\n   * @param  {[jQuery element]} $hlb [HLB element]\n   */\n  function constrainHeightToSafeArea($hlb) {\n\n    var hlb            = $hlb[0],\n        hlbStyle       = inlineStyle(hlb),\n        originalHeight = scaleRectFromCenter($hlb).height,\n        safeZoneHeight = hlbSafeArea.getSafeZoneBoundingBox().height;\n\n    // Would the scaled element's height be greater than the safe area height?\n    if (originalHeight > safeZoneHeight) {\n\n      // height is now the \"safe zone\" height, minus the padding/border\n      hlbStyle.height = ((safeZoneHeight / getFinalScale($hlb) / getInheritedZoom($hlb)) -\n          (hlbStyling.defaultBorder +\n            hlbStyling.defaultBorder +\n            parseInt($hlb.css('paddingTop')) +\n            parseInt($hlb.css('paddingBottom'))\n          )\n        ) + 'px';\n\n      // Keep aspect ratio if HLB is an image\n      if (isVisualMedia(hlb)) {\n\n        // We need to recalculate the bounding client rect of the HLB element, because we just changed it.\n        hlbStyle.width = (hlb.getBoundingClientRect().width / getInheritedZoom($hlb) *\n          (safeZoneHeight / originalHeight)) + 'px';\n      }\n    }\n  }\n\n  /**\n   * [constrainWidthToSafeArea constrains the width of the HLB to the safe area.\n   * If HLB is an image, then it keeps the aspect ratio.]\n   * @param  {[jQuery element]} $hlb [HLB element]\n   */\n  function constrainWidthToSafeArea($hlb) {\n\n    var hlb           = $hlb[0],\n        hlbStyle      = inlineStyle(hlb),\n        originalWidth = scaleRectFromCenter($hlb).width,\n        safeZoneWidth = hlbSafeArea.getSafeZoneBoundingBox().width;\n\n    // Would the scaled element's width be greater than the safe area width?\n    if (originalWidth > safeZoneWidth) {\n\n      // width is now the \"safe zone\" width, minus the padding/border\n      hlbStyle.width = ((safeZoneWidth / getFinalScale($hlb) / getInheritedZoom($hlb)) -\n        (hlbStyling.defaultBorder + hlbStyling.defaultPadding + getExtraLeftPadding($hlb) / 2) * 2) + 'px';\n\n      // Keep aspect ratio if HLB is an image\n      if (isVisualMedia(hlb)) {\n\n        // We need to recalculate the bounding client rect of the HLB element, because we just changed it.\n        hlbStyle.height = (hlb.getBoundingClientRect().height / getInheritedZoom($hlb) *\n          (safeZoneWidth / originalWidth)) + 'px';\n      }\n    }\n  }\n\n  /**\n   * [initializeSize sets the height and width of the HLB to the original element's bounding\n   * box height and width.  Useful for images.]\n   * @param  {[jQuery element]} $hlb      [The HLB]\n   * @param  {[Object]} $initialHLBRect [The highlight rect or the $originalElement  bounding client rect.]\n   */\n  function initializeSize($hlb, initialHLBRect) {\n\n    var zoom   = getPageZoom(),\n        width  = (initialHLBRect.width  / zoom) + 'px',\n        height = (initialHLBRect.height / zoom) + 'px';\n    inlineStyle.set($hlb[0], {\n      width  : width, //Preserve dimensional ratio\n      height : height //Preserve dimensional ratio\n    });\n\n    // This fixes the HLB being too wide or tall (lots of whitespace) for www.faast.org/news\n    // when HLBing \"News\" header.  Because we copy computedStyles, we sometimes get an HLB\n    // that has a child that is much wider or taller than the highlight, causing the HLB\n    // to increase in width and height for the purpose of avoiding scrollbars.\n    // TODO: cache descendants because we use it alot\n    inlineStyle.set($hlb.find('*').get(), {\n      maxWidth : width\n    });\n  }\n\n  /**\n   * [scaleRectFromCenter helper function for calculating a bounding box if an element were to be scaled from 50%50%]\n   * @param  {[jQuery element]} $hlb [HLB]\n   * @return {[object]}                     [A simulated bounding client rect]\n   */\n  function scaleRectFromCenter($hlb) {\n\n    var clonedNodeBoundingBox = $hlb[0].getBoundingClientRect(),\n        zoomFactor = getFinalScale($hlb);\n\n    // The bounding box of the cloned element if we were to scale it\n    return {\n      'left'  : clonedNodeBoundingBox.left   - ((clonedNodeBoundingBox.width  * zoomFactor - clonedNodeBoundingBox.width)  / 2),\n      'top'   : clonedNodeBoundingBox.top    - ((clonedNodeBoundingBox.height * zoomFactor - clonedNodeBoundingBox.height) / 2),\n      'width' : clonedNodeBoundingBox.width  * zoomFactor,\n      'height': clonedNodeBoundingBox.height * zoomFactor\n    };\n  }\n\n  /**\n   * [addVerticalScroll Adds a vertical scrollbar, if necessary, and corrects any\n   *  dimension/positioning problems resulting from adding the scrollbar]\n   * @param {[jQuery element]} $hlb [HLB element]\n   */\n  function addVerticalScroll($hlb) {\n    var hlb = $hlb[0];\n\n    if (common.hasVertScroll(hlb)) {\n      inlineStyle(hlb).overflowY = 'scroll';\n      // Adding a vertical scroll may sometimes make content overflow the width\n      fixOverflowWidth($hlb);\n    }\n  }\n\n  /**\n   * [fixOverflowWidth sets the width of the HLB to avoid horizontal scrollbars]\n   * @param  {[jQuery element]} clonedNode [HLB]\n   */\n  function fixOverflowWidth($hlb) {\n\n    var hlbElement = $hlb[0];\n\n    // If there is a horizontal scroll bar\n    if (hlbElement.clientWidth < hlbElement.scrollWidth) {\n\n      if (SC_DEV) {\n        console.log('%cSPECIAL CASE: Fix overflow width.',  'background:orange;');\n      }\n\n      inlineStyle.set(hlbElement, {\n        'width'    : hlbElement.scrollWidth + hlbStyling.defaultPadding + 'px',\n        'maxWidth' : 'none'\n      });\n\n      // Again, we can't be positive that the increase in width does not overflow the safe area.\n      constrainWidthToSafeArea($hlb);\n    }\n  }\n\n  /**\n   * [fixNegativeMargins gives the $hlb extra paddingTop and paddingLeft for elements\n   * that are positioned negatively. document.createRange() was attempted to avoid looping over\n   * all children, but children with background images are not accounted for...like on\n   * ctsenaterepublicans.com]\n   * @param  {[jQuery Element]} $hlb [HLB element]\n   */\n  function fixNegativeMargins($hlb, initialHLBRect) {\n\n    var hlbBoundingRect = $hlb[0].getBoundingClientRect(),\n        hlbLeft         = hlbBoundingRect.left,\n        hlbTop          = hlbBoundingRect.top,\n        extraLeft       = 0,\n        extraTop        = 0,\n        paddingLeft,\n        paddingTop,\n        childLeft,\n        childTop,\n        hasBackgroundImage,\n        childBoundingRect,\n        originalHLBLeftPadding = parseFloat($hlb.css('paddingLeft')),\n        originalHLBTopPadding  = parseFloat($hlb.css('paddingTop'));\n\n    $hlb.find('*').each(function () {\n      var thisStyle = inlineStyle(this);\n      // These elements to not make sense to check because their\n      // bounding rects are not consistent with their visual position\n      if (!$(this).is('br, option') &&\n          ($(this).css('marginLeft').indexOf('-') !== -1 ||\n           $(this).css('marginTop').indexOf('-')  !== -1)) {\n\n        childBoundingRect  = this.getBoundingClientRect();\n        childLeft          = childBoundingRect.left;\n        childTop           = childBoundingRect.top;\n        hasBackgroundImage = thisStyle.backgroundImage !== 'none';\n        paddingLeft        = hasBackgroundImage ? 0 : parseFloat(thisStyle.paddingLeft);\n        paddingTop         = hasBackgroundImage ? 0 : parseFloat(thisStyle.paddingTop);\n\n        if (childLeft + paddingLeft < hlbLeft && hlbLeft - childLeft - paddingLeft > extraLeft) {\n          if (SC_DEV) {\n            console.log('%cSPECIAL CASE: Negative Margin-Left Fix.',  'background:orange;');\n          }\n          extraLeft = hlbLeft - childLeft - paddingLeft;\n        }\n\n        if (childTop + paddingTop < hlbTop && hlbTop - childTop - paddingTop > extraTop) {\n          if (SC_DEV) {\n            console.log('%cSPECIAL CASE: Negative Margin-Top Fix.',  'background:orange;');\n          }\n          extraTop = hlbTop - childTop - paddingTop;\n        }\n      }\n\n      // Negative margin effects boundingClientRect.\n      // Removing padding on www.faast.org/news left column Device Loan Program uses negative left\n      // margin, making the contents of the HLB move to the left, making the HLB have extra empty space\n      // to the right of the HLB.  Ugh...\n      // Subtract width from HLB if they use negative left margin\n      if (extraLeft) {\n\n        if (SC_DEV) {\n          console.log('%cSPECIAL CASE: Reset HLB width to use padding for width...',  'background:orange;');\n        }\n\n        inlineStyle($hlb[0]).width = (initialHLBRect.width / getPageZoom()  - extraLeft) + 'px';\n\n        fixOverflowWidth($hlb);\n      }\n    });\n\n    inlineStyle.set($hlb[0], {\n      'paddingTop' : extraTop  ? originalHLBTopPadding  + extraTop  + hlbStyling.defaultPadding + hlbStyling.defaultBorder : originalHLBTopPadding,\n      'paddingLeft': extraLeft ? originalHLBLeftPadding + extraLeft + hlbStyling.defaultPadding + hlbStyling.defaultBorder : originalHLBLeftPadding\n    });\n  }\n\n  //////////////////////////\n  // PUBLIC FUNCTIONS\n  //////////////////////////\n\n  function getOriginCSS() {\n    return originCSS;\n  }\n\n  function getTranslateCSS() {\n    return translateCSS;\n  }\n\n  function setOriginCSS(val) {\n    originCSS = val;\n  }\n\n  function setTranslateCSS(val) {\n    translateCSS = val;\n  }\n\n  function getHlbZoom() {\n    return 1.5;\n\n//  TODO should we remove permanently or do we want to keep this?\n//    var lensSizeSetting = conf.get('lensSize');\n//    switch (lensSizeSetting) {\n//      case '-': return 1.2;\n//      case '+': return 2;\n//      default: return 1.5;\n//    }\n  }\n\n  // HLB transform scale necessary to provide the HLBExtraZoom size increase.\n  // If zoom is on the body, then scaling needs to account for that since the HLB is outside of the body.\n  function getFinalScale($hlb) {\n    return getHlbZoom() *getStartingScale($hlb);\n  }\n\n  function getPageZoom() {\n    return pref.get('zoom') || 1;\n  }\n\n  // HLB transform scale necessary to show HLB at same size as original highlighted content.\n  function getStartingScale($hlb) {\n    return $hlb.closest(document.body).length ? 1 : getPageZoom();\n  }\n\n  // Transform scale that affects HLB (was inherited from page zoom)\n  // If the HLB is outside the body, this will be 1 (since the page zoom is on <body>)\n  function getInheritedZoom($hlb) {\n    return $hlb.closest(document.body).length ? getPageZoom() : 1;\n  }\n\n  function sizeHLB($hlb, $originalElement, initialHLBRect) {\n\n    // Initialize height/width of the HLB\n    if (SC_DEV) {\n      console.log('INITIAL: %o',initialHLBRect);\n    }\n\n    initializeSize($hlb, initialHLBRect);\n\n    // Constrain the height and width of the HLB to the height and width of the safe area.\n    constrainHeightToSafeArea($hlb);\n    constrainWidthToSafeArea($hlb);\n\n    // Limit the width of the HLB to a maximum of CHAR_WIDTH_LIMIT characters.\n    limitWidth($originalElement, $hlb, CHAR_WIDTH_LIMIT);\n\n    limitChildWidth($hlb);\n\n    fixOverflowWidth($hlb);\n\n    fixNegativeMargins($hlb, initialHLBRect);\n\n  }\n\n  /**\n   * [positionHLB positions the HLB.]\n   */\n  function positionHLB($hlb, initialHLBRect, inheritedZoom) {\n\n    // The minimum distance we must move the HLB for it to fall within the safe zone\n    var constrainedOffset,\n        hlb = $hlb[0],\n        HLBBoundingBoxAfterZoom = scaleRectFromCenter($hlb),\n        HLBBoundingBox = hlb.getBoundingClientRect(),\n\n        // These are used in the positioning calculation.\n        // They are the differences in height and width before and after the HLB is scaled.\n        expandedWidthOffset  = (HLBBoundingBoxAfterZoom.width  - HLBBoundingBox.width)  / 2,\n        expandedHeightOffset = (HLBBoundingBoxAfterZoom.height - HLBBoundingBox.height) / 2,\n\n        // The difference between the mid points of the hlb element and the original\n        offset = midPointDiff(hlb.getBoundingClientRect(), initialHLBRect);\n\n    // Update the dimensions for the HLB which is used for constraint calculations.\n    // The offset of the original element and cloned element midpoints are used for positioning.\n    HLBBoundingBoxAfterZoom.left   = HLBBoundingBox.left - offset.x - expandedWidthOffset;\n    HLBBoundingBoxAfterZoom.top    = HLBBoundingBox.top  - offset.y - expandedHeightOffset;\n    HLBBoundingBoxAfterZoom.right  = HLBBoundingBoxAfterZoom.left + HLBBoundingBoxAfterZoom.width;\n    HLBBoundingBoxAfterZoom.bottom = HLBBoundingBoxAfterZoom.top  + HLBBoundingBoxAfterZoom.height;\n\n    // Constrain the scaled HLB to the bounds of the \"safe area\".\n    // This returns how much to shift the box so that it falls within the bounds.\n    // Note: We have already assured that the scaled cloned element WILL fit into the \"safe area\",\n    // but not that it is currently within the bounds.\n    constrainedOffset = constrainPosition(HLBBoundingBoxAfterZoom);\n\n    // Add the difference between the HLB position and the minimum amount of distance\n    // it must travel to be completely within the bounds of the safe area to the difference\n    // between the mid points of the hlb element and the original\n    offset.x += constrainedOffset.x;\n    offset.y += constrainedOffset.y;\n\n    // translateCSS and originCSS are used during deflation\n    translateCSS = 'translate(' + (-offset.x / inheritedZoom) + 'px, ' + (-offset.y / inheritedZoom) + 'px)';\n\n    // This is important for animating from the center point of the HLB\n    originCSS = ((-offset.x / inheritedZoom) + HLBBoundingBox.width  / 2 / inheritedZoom) + 'px ' +\n                ((-offset.y / inheritedZoom) + HLBBoundingBox.height / 2 / inheritedZoom) + 'px';\n\n    // Position the HLB without it being scaled (so we can animate the scale).\n    var startAnimationZoom = getPageZoom() / inheritedZoom,\n      hlbStyles = {\n        transform: 'scale(' + startAnimationZoom + ') ' + translateCSS,\n        transformOrigin: originCSS\n      };\n\n    inlineStyle.set(hlb, hlbStyles);\n  }\n\n  return {\n    getOriginCSS: getOriginCSS,\n    getTranslateCSS: getTranslateCSS,\n    setOriginCSS: setOriginCSS,\n    setTranslateCSS: setTranslateCSS,\n    getFinalScale: getFinalScale,\n    getStartingScale: getStartingScale,\n    getInheritedZoom: getInheritedZoom,\n    sizeHLB: sizeHLB,\n    positionHLB: positionHLB\n  };\n});\n","/**\n * BackgroundDimmer can dim all content in the page behind a given z-index.\n */\nsitecues.define(\n  'hlb/dimmer',[\n    '$',\n    'hlb/constants',\n    'run/inline-style/inline-style'\n  ],\n  function (\n    $,\n    constants,\n    inlineStyle\n  ) {\n  'use strict';\n\n  //////////////////////////////\n  // PRIVATE VARIABLES\n  /////////////////////////////\n\n  var DIMMER_ID = 'sitecues-background-dimmer',\n\n      DIMMER_MIN_OPACITY = 0,\n      DIMMER_MAX_OPACITY = 0.65,\n\n      requestFrameFn = window.requestAnimationFrame;\n\n  //////////////////////////////\n  // PUBLIC FUNCTIONS\n  /////////////////////////////\n\n  /**\n   * dimBackgroundContent creates the background dimmer element, positions it, and transitions opacity\n   * @param  {number}        inflationSpeed      The duration of the opacity transition\n   * @param  {Object} (optional) $parentOfDimmer  A selector describing the node that should parent the dimmer\n   */\n  function dimBackgroundContent(inflationSpeed, $foreground) {\n\n    function createDimmerElement() {\n      var documentElement = document.documentElement,\n        width = Math.max(documentElement.scrollWidth, window.innerWidth),\n        height = Math.max(documentElement.scrollHeight, window.innerHeight),\n        // Draw a rectangle that does not capture any mouse events\n        useCss = {\n          display: 'block',\n          position: 'absolute',\n          zIndex: constants.MAX_ZINDEX,\n          top: 0,\n          left: 0,\n          width: width + 'px',\n          height: height + 'px',\n          backgroundColor: '#000',\n          pointerEvents: 'none',\n          willChange: 'opacity'\n        },\n        newDimmer = $('<sc>');\n\n      inlineStyle.set(newDimmer[0], useCss);\n      newDimmer = newDimmer.attr('id', DIMMER_ID)[0];\n\n      animateOpacity(newDimmer, DIMMER_MIN_OPACITY, DIMMER_MAX_OPACITY, inflationSpeed);\n\n      return newDimmer;\n    }\n\n    var dimmerElement = getDimmerElement() || createDimmerElement();\n\n    // If created before, will ensure it's moved before the current hlb wrapper\n    $(dimmerElement).insertBefore($foreground);\n  }\n\n  function animateOpacity(dimmerElement, startOpacity, endOpacity, speed, onCompleteFn) {\n\n    var startTime = Date.now();\n\n    function nextFrame() {\n      var timeElapsed = Date.now() - startTime,\n        percentComplete = timeElapsed > speed ? 1 : timeElapsed / speed,\n        currentOpacity = startOpacity + (endOpacity - startOpacity) * percentComplete;\n\n      inlineStyle(dimmerElement).opacity = currentOpacity;\n\n      if (percentComplete < 1) {\n        requestFrameFn(nextFrame);\n      }\n      else if (onCompleteFn) {\n        onCompleteFn();\n      }\n    }\n    nextFrame();\n  }\n\n  /**\n   * [undimBackgroundContent transitions the opacity of the dimmer to DIMMER_MIN_OPACITY]\n   * @param  {[integer]} deflationSpeed [The duration of the opacity transition]\n   */\n  function undimBackgroundContent(deflationSpeed) {\n\n    var dimmer = getDimmerElement();\n\n    if (dimmer) { // Still there\n      animateOpacity(dimmer, DIMMER_MAX_OPACITY, DIMMER_MIN_OPACITY, deflationSpeed, onDimmerClosed);\n    }\n\n  }\n\n  /**\n   * [onDimmerClosed removes the dimmer element from the DOM]\n   */\n  function onDimmerClosed() {\n    $(getDimmerElement()).remove();\n  }\n\n  function getDimmerElement() {\n    return document.getElementById(DIMMER_ID);\n  }\n\n  return {\n    dimBackgroundContent: dimBackgroundContent,\n    undimBackgroundContent: undimBackgroundContent\n  };\n\n});\n\n","/*\n  This module animates the HLB.  Depending on the browser, the mechanism\n  of animation is either CSS3 Transitions or jQuery.animate.\n */\nsitecues.define(\n  'hlb/animation',[\n    'hlb/dimmer',\n    'page/util/common',\n    'hlb/positioning',\n    'run/platform',\n    '$',\n    'hlb/constants',\n    'mini-core/native-global',\n    'run/inline-style/inline-style'\n  ],\n  function (\n    dimmer,\n    common,\n    hlbPositioning,\n    platform,\n    $,\n    constants,\n    nativeGlobal,\n    inlineStyle\n  ) {\n  'use strict';\n\n  var INFLATION_SPEED = 400, // Default inflation duration\n      INFLATION_SPEED_FAST = 0, // Inflation duration when retargeting -- need > 0 so that animation end fires correctly\n      DEFLATION_SPEED = 150, // Default deflation duration\n\n      getStartingScale = hlbPositioning.getStartingScale;\n\n  /**\n   * [transitionInHLB animates the inflation of the HLB and background dimmer]\n   * @param  {[Object]} data [The information passed by the HLB module to perform the animation]\n   */\n  function transitionInHLB(doShowQuickly, data) {\n\n    // Dim the background!\n    dimmer.dimBackgroundContent(INFLATION_SPEED, $('#' + constants.HLB_WRAPPER_ID));\n\n    var\n      $hlb  = data.$hlb,\n      speed = doShowQuickly ? INFLATION_SPEED_FAST : INFLATION_SPEED,\n      startingScale = getStartingScale($hlb);\n\n    inlineStyle($hlb[0]).transformOrigin = data.originCSS;\n\n    animateCss($hlb[0], startingScale, hlbPositioning.getFinalScale($hlb), speed, data.translateCSS, data.onHLBReady);\n  }\n\n  /**\n   * [transitionOutHLB animates and removes the HLB and background dimmer]\n   * @param  {[Object]} data [The information passed by the HLB module to perform the animation]\n   */\n  function transitionOutHLB(data) {\n\n    var $hlb = data.$hlb;\n\n    // Un-dim the background!\n    dimmer.undimBackgroundContent(DEFLATION_SPEED);\n\n    // Do we bother animating the deflation?\n\n    // Sometimes, if the user presses the spacebar extremely fast, the HLB is toggled\n    // to close during the HLB inflation animation (transitionInHLB). Because this is\n    // possible, it is also possible that the value of transform:scale is 1 by the time\n    // we want to deflate, and thus the transition end event cannot be used as a callback\n    // mechanism (because there is nothing to animate if scale is already 1).  Therefore,\n    // we check to see if the HLB scale is greater than one, and if so, we animate the\n    // deflation, otherwise, we just skip the deflation step\n    if (!isHLBZoomed($hlb)) {\n      data.onHLBClosed();\n      return;\n    }\n\n    animateCss($hlb[0], getCurrentScale($hlb), getStartingScale($hlb), DEFLATION_SPEED, data.translateCSS, data.onHLBClosed);\n  }\n\n  function animateCss(hlbElement, startScale, endScale, speed, translateCSS, onCompleteFn) {\n    var\n      fromCss = {},\n      toCss   = {\n        transform: 'scale(' + endScale + ') ' + translateCSS\n      };\n\n    inlineStyle(hlbElement).transitionProperty = 'none';// Clear any existing transition\n\n    if (!speed) {\n      // No animation -- do it immediately and return\n      inlineStyle.set(hlbElement, toCss);\n      onCompleteFn();\n      return;\n    }\n\n    // Animate fromCss -> toCss\n    fromCss.transform = 'scale(' + startScale + ') ' + translateCSS;\n    inlineStyle.set(hlbElement, fromCss);\n\n    function onTransitionEnd() {\n      hlbElement.removeEventListener(platform.transitionEndEvent, onTransitionEnd);\n      onCompleteFn();\n    }\n\n    // Allow the from CSS to register so that setting the toCss actually animates there\n    // rather than just setting the toCss and ignoring the fromCss\n    nativeGlobal.setTimeout(function () {\n      toCss.transition = 'transform ' + speed + 'ms ease-in-out';\n      inlineStyle.set(hlbElement, toCss);\n      hlbElement.addEventListener(platform.transitionEndEvent, onTransitionEnd);\n    }, 0);\n  }\n\n  function getCurrentScale($hlb) {\n    return common.getComputedScale($hlb[0]);\n  }\n\n  /**\n   * [isHLBZoomed determines if the $hlb is scaled greater than one.\n   * This is useful for the transitionOutHLB function.]\n   * @return {Boolean} [if true, $hlb is scaled > zoom]\n   * @example \"matrix(1.5, 0, 0, 1.5, 1888.0610961914063, 2053.21875)\"\n   * @example \"matrix(1, 0, 0, 1, 1888.0610961914063, 2053.21875)\"\n   */\n  function isHLBZoomed($hlb) {\n    // If there isn't any transform, then it isn't scaled.\n    var scale = getCurrentScale($hlb);\n    return scale > hlbPositioning.getStartingScale($hlb);\n  }\n\n  return {\n    transitionInHLB: transitionInHLB,\n    transitionOutHLB: transitionOutHLB\n  };\n\n});\n\n","/**\n * This is the box that appears when the user asks to read the highlighted text in a page.\n * Documentation: https://equinox.atlassian.net/wiki/display/EN/HLB3\n */\nsitecues.define(\n  'hlb/hlb',[\n    '$',\n    'hlb/event-handlers',\n    'hlb/positioning',\n    'hlb/styling',\n    'run/conf/preferences',\n    'run/platform',\n    'page/util/element-classifier',\n    'hlb/animation',\n    'page/util/geo',\n    'run/metric/metric',\n    'hlb/constants',\n    'run/events',\n    'run/inline-style/inline-style'\n  ],\n  function (\n    $,\n    eventHandlers,\n    hlbPositioning,\n    hlbStyling,\n    pref,\n    platform,\n    elemClassifier,\n    hlbAnimation,\n    geo,\n    metric,\n    constants,\n    events,\n    inlineStyle\n  ) {\n  'use strict';\n\n  /////////////////////////\n  // PRIVATE VARIABLES\n  ////////////////////////\n\n      // Magic. Fixes problems where mouse highlight was SO accurate, that a simple rounding of a pixel\n      // would unnecessarily wrap text. Seemed to be more prevalent on IE, fixes stuff for EEOC.\n      // Value of 2 instead of 1 fixes wrapping text on this page for all headers:\n      // http://www.windoweyesforoffice.com/sitecues/index.php\n  var EXTRA_HIGHLIGHT_PADDING = 2, // TODO: Figure out why this is needed and compute it.\n      MOUSE_SAFETY_ZONE       = 50, // Number of pixels the mouse is allowed to go outside the HLB, before it closes.\n      FORMS_SELECTOR          = 'input, textarea, select',\n\n      $picked,         // The object chosen by the picker.\n      $foundation,     // The sanitized input, used as the basis for creating an $hlb.\n      $hlb,            // The cloned object, based on the $foundation.\n      $hlbWrapper,     // Container for both the HLB and background dimmer.\n\n      initialHLBRect,  // The highlight rect, if it exists, otherwise use the $foundation bounding client rect.\n      inheritedZoom,   // Amount of zoom inherited from page's scale transform.\n      removeTemporaryFoundation    = false,  // Did we create our own foundation? (becomes true for lonely elements)\n      preventDeflationFromMouseout = false,  // State tracking: should the HLB ignore mouse movement?\n      isListeningToMouseEvents     = false,  // State tracking: are event listeners currently attached?\n      isHLBClosing                 = false,  // State tracking: is the HLB currently deflating?\n      isSticky                     = false,  // DEBUG: prevents the HLB from deflating on mouseout.\n      foundations = {\n        // Keys are tag names of \"lonely\" elements, which rely upon another element being present to work.\n        // Values are functions that return a foundation (like the relied upon element).\n        'li'       : getValidListElement,\n        'fieldset' : getValidFieldsetElement,\n        'input'    : getValidFormElement\n      },\n      state = {};\n\n  if (SC_DEV) {\n    // Boolean that determines if we log HLB information (only works in SC_DEV mode)\n    var loggingEnabled = false;\n  }\n\n  //////////////////////////////\n  // PRIVATE FUNCTIONS\n  /////////////////////////////\n\n  /**\n   * [mapForm maps input values from one set of elements to another]\n   * @param  {[jQuery element]} from [The HLB or The Foundation]\n   * @param  {[jQuery element]} to   [The HLB or The Foundation]\n   */\n  function mapForm($from, $to, isHLBClosing) {\n\n    // Get descendants of The HLB / The Foundation that may have a value.\n    var $fromInputs = $from.find(FORMS_SELECTOR)\n            .addBack(FORMS_SELECTOR),\n        $toInputs = $to.find(FORMS_SELECTOR)\n            .addBack(FORMS_SELECTOR),\n        i, len = $fromInputs.length,\n        $currentFromInput,\n        $currentToInput,\n        cloneIndex,\n        fromInputType;\n\n    for (i = 0; i < len; i = i + 1) {\n      $currentFromInput = $fromInputs.eq(i);\n      $currentToInput = $toInputs.eq(i);\n      fromInputType = $currentFromInput.prop('type');\n      cloneIndex = $currentToInput[0].getAttribute('data-sc-cloned');\n\n      //If we're closing the HLB, and the current form element is part of a cloned foundation\n      if (isHLBClosing && cloneIndex) {\n        //Remove the index property from the HLB element\n        $currentFromInput[0].removeAttribute('data-sc-cloned');\n        //Query the DOM for the original form element, so we can copy the HLB form value back into the appropriate field\n        $currentToInput = $('[data-sc-cloned=\"' + cloneIndex + '\"]');\n        //Remove the index from the original form element\n        $currentToInput[0].removeAttribute('data-sc-cloned');\n      }\n\n      if (fromInputType === 'radio' || fromInputType === 'checkbox') {\n        $currentToInput.prop('checked', $currentFromInput.prop('checked'));\n      }\n      else {\n        if (platform.browser.isSafari) {\n          // In Safari, text inputs opening up in HLB show their contents flush to the bottom\n          // instead of vertically centered, unless we tweak the value of the input just after the styles are set\n          $currentToInput.val($currentFromInput.val() + ' ');\n        }\n        $currentToInput.val($currentFromInput.val());\n      }\n\n    }\n  }\n\n  function copyFormDataToPage() {\n    // Copy any form input the user may have entered in the HLB back into the page.\n    mapForm($hlb, $foundation, true);\n  }\n\n  // Return truthy value if a button is pressed on a mouse event.\n  // There are three properties for mouse buttons, and they all work differently -- both\n  // in terms of browsers and on mousemove events in particular.\n  function isButtonDown(mouseEvent) {\n    return typeof mouseEvent.buttons === 'undefined' ? mouseEvent.which : mouseEvent.buttons;\n  }\n\n  /**\n   * [onTargetChange is enabled when the HLB is READY.\n   * Deflates the HLB if allowed.]\n   * @param  {[DOM mousemove event]} event [Mousemove event.]\n   */\n  function onTargetChange(event) {\n\n    var newTarget   = event.target,\n        mouseX      = event.clientX,\n        mouseY      = event.clientY,\n        isMouseDown = isButtonDown(event),\n        HLBBoundingBox;\n\n    // The mouse has never been within the HLB bounds or\n    // debugging is enabled.\n    if (preventDeflationFromMouseout || isSticky) {\n      return;\n    }\n\n    // Mouse is currently hovering over the HLB\n    if ($hlb[0] === newTarget) {\n      return;\n    }\n\n    // Is the left mouse button pressed?\n    // The user is click + dragging text to copy.\n    if (isMouseDown) {\n      return;\n    }\n\n    HLBBoundingBox = $hlb[0].getBoundingClientRect();\n\n    // If the mouse coordinates are not within the bounds of\n    // the HLB + MOUSE_SAFETY_ZONE, then deflate the HLB.\n    if (mouseX < HLBBoundingBox.left   - MOUSE_SAFETY_ZONE ||\n        mouseX > HLBBoundingBox.right  + MOUSE_SAFETY_ZONE ||\n        mouseY < HLBBoundingBox.top    - MOUSE_SAFETY_ZONE ||\n        mouseY > HLBBoundingBox.bottom + MOUSE_SAFETY_ZONE) {\n\n      closeHLB(event);\n    }\n  }\n\n  /**\n   * [turnOnHLBEventListeners turns on HLB event handlers for deflation and scroll]\n   */\n  function turnOnHLBEventListeners() {\n    if (isListeningToMouseEvents) {\n      return; // Don't add twice in case of hlb retargeting\n    }\n\n    isListeningToMouseEvents = true;\n\n    // Register mouse mousemove handler for deflating the HLB\n    $(document).on('mousemove', onTargetChange);\n\n    // Register mousemove handler on the HLB element to turn on the ability to exit the HLB by mouse\n    // This event handler is unique in that it unregisters itself once executed.\n    $hlb.on('mousemove', onHLBHover);\n\n    // Register an event handler for closing the HLB by clicking outside of it.\n    $('body').on('click', onClick);\n\n    // Make sure mousewheel scrolls HLB but not page\n    eventHandlers.captureWheelEvents($hlb);\n  }\n\n  /**\n   * [onHLBReady executes once the HLB is ready (completed inflation animation).\n   * Adds the appropriate event listeners and emits hlb/ready]\n   */\n  function onHLBReady() {\n\n    // Focus input or textarea\n    if (elemClassifier.isEditable($hlb[0])) {\n      $hlb.focus();\n    }\n\n    // Let the rest of the application know that the hlb is ready\n    // Listeners: hpan.js, invert.js, highlight.js, speech.js\n    events.emit(constants.HLB_READY, $hlb, state.highlight);\n  }\n\n  /**\n   * [turnOffHLBEventListeners turns off HLB event handlers for deflation and scroll]\n   */\n  function turnOffHLBEventListeners() {\n    if (!isListeningToMouseEvents) {\n      return;\n    }\n\n    // UNTrap the mousewheel events (we don't want the event to even think when the user scrolls without the HLB)\n    eventHandlers.releaseWheelEvents();\n\n    $hlb[0].removeEventListener(platform.transitionEndEvent, onHLBReady);\n\n    // Turn off the ability to deflate the HLB with mouse\n    $(document).off('mousemove', onTargetChange);\n\n    // Register mouse mousemove handler for deflating the HLB\n    $('body').off('click', onClick);\n\n    isListeningToMouseEvents = false;\n  }\n\n  /**\n   * [closeHLB prepares and deflates the HLB.]\n   */\n  function closeHLB(event) {\n\n    copyFormDataToPage();\n\n    // Set this to true to prevent toggleHLB();\n    isHLBClosing = true;\n\n    turnOffHLBEventListeners();\n\n    hlbAnimation.transitionOutHLB({\n      '$hlb'               : $hlb,\n      '$hlbWrapper'        : $hlbWrapper,\n      'originCSS'          : hlbPositioning.getOriginCSS(),\n      'translateCSS'       : hlbPositioning.getTranslateCSS(),\n      'onHLBClosed'        : function () { onHLBClosed(event); },\n      'transitionProperty' : hlbStyling.transitionProperty\n    });\n  }\n\n  function targetHLB(highlight, isRetargeting) {\n\n    state.highlight = highlight;\n\n    if (!highlight.fixedContentRect) {\n      return;  // No highlight present -- nothing to open HLB on\n    }\n\n    // Highlight is present -- guaranteed to have\n    // at least one picked element and fixedContentRect outlining the highlight\n    $picked = highlight.picked;\n\n\n    // Set module scoped variable so the rest of the program has reference.\n    initialHLBRect = getInitialHLBRect(highlight);\n\n    // Disable mouse highlighting so we don't copy over the highlighting styles from the picked element.\n    // It MUST be called before getFoundation().\n    events.emit('mh/pause');\n\n    // Sanitize the input, by accounting for \"lonely\" elements.\n    $foundation = getFoundation($picked);\n\n    // Turn off listeners for the old HLB. createHLB() will add new ones.\n    turnOffHLBEventListeners();\n\n    createHLB(highlight, isRetargeting);\n  }\n\n  /**\n   * [toggleHLB closes or creates a new HLB]\n   */\n  function toggleHLB(highlight) {\n    // Sadly, the HLB animation system does not currently\n    // know how to reverse an animation, so we cannot\n    // toggle if currently deflating. :(\n    if (isHLBClosing) {\n      return;\n    }\n\n    if ($hlb) {\n      closeHLB();\n    } else {\n      targetHLB(highlight);\n    }\n  }\n\n  /**\n   * This is called when the user presses a key that moves the mouse highlight\n   * has changed while the HLB opens\n   */\n  function retargetHLB(highlight) {\n    copyFormDataToPage(); // Make sure we don't lose any of the form entry from the current HLB\n    $hlb.remove();\n    targetHLB(highlight, true);\n  }\n\n  /**\n   * [getInitialHLBRect returns the initial width and height for our HLB when we first create it.\n   * Preferably we utilize the highlight rectangle calculated by the picker.]\n   * @param  {[object]} highlight [Information about the highlight --\n   *          see https://equinox.atlassian.net/wiki/display/EN/Internal+sitecues+API#InternalsitecuesAPI-Highlight]\n   * @return {[Object]}   [Dimensions and position]\n   */\n  function getInitialHLBRect(highlight) {\n\n    return geo.expandOrContractRect(highlight.fixedContentRect, EXTRA_HIGHLIGHT_PADDING);\n  }\n\n\n  /**\n   * [createHLB initializes, positions, and animates the HLB]\n   * @param isRetargeting -- true if HLB is moving from one place to another, false if brand new HLB mode\n   */\n  function createHLB(highlight, isRetargeting) {\n\n    // clone, style, filter, emit hlb/did-create,\n    // prevent mousemove deflation, disable scroll wheel\n    initializeHLB(highlight);\n\n    hlbPositioning.sizeHLB($hlb, $foundation, initialHLBRect);\n\n    hlbPositioning.positionHLB($hlb, initialHLBRect, inheritedZoom);\n\n    // Now that we have extracted all the information from the foundation,\n    // it is time to ask whether or not a temporary element has been used\n    // and remove it if true.\n    if (removeTemporaryFoundation) {\n      $foundation.remove();\n      removeTemporaryFoundation = false;\n    }\n\n    var viewData = {\n      '$hlb'               : $hlb,\n      '$hlbWrapper'        : $hlbWrapper,\n      'originCSS'          : hlbPositioning.getOriginCSS(),\n      'translateCSS'       : hlbPositioning.getTranslateCSS(),\n      'onHLBReady'         : onHLBReady,\n      'transitionProperty' : hlbStyling.transitionProperty\n    };\n\n    // .setTimeout MIGHT be necessary for the browser to complete the rendering and positioning\n    // of the HLB.  Before we scale, it absolutely must be positioned correctly.\n    // Note: Interestingly enough, this timeout is unnecessary if we comment out the\n    // background dimmer in transitionInHLB(), because the operation took long enough\n    // for the browser to update/render the DOM.  This is here for safety (until proven otherwise).\n    // If we use a .setTimeout, we have to solve the problem of functions being added to the stack before\n    // the timeout completes...its a pain.\n    hlbAnimation.transitionInHLB(isRetargeting, viewData);\n  }\n\n  function getEditableItems() {\n    function isEditable(index, element) {\n      return elemClassifier.isEditable(element);\n    }\n    return $foundation.find('input,textarea')\n      .addBack()\n      .filter(isEditable);\n  }\n\n  /**\n   * [initializeHLB is the first step in the creation process for the HLB.\n   * This function is responsible for cloning the original element, mapping form data,\n   * cloning child styles, filtering attributes, styles, and elements, and setting the\n   * HLB with default styles and computed styles.]\n   */\n  function initializeHLB(highlight) {\n\n    // Create and append the HLB and DIMMER wrapper element to the DOM\n    $hlbWrapper = getOrCreateHLBWrapper();\n\n    if (platform.browser.isIE && getEditableItems().length) {\n      // TODO try to remove this hack:\n      // IE + text fields -- avoid bug where textfield was locked\n\n      if (SC_DEV && loggingEnabled) {\n        console.log('SPECIAL CASE: HLB inside <body>');\n      }\n\n      $hlbWrapper.appendTo('body');\n      inheritedZoom = pref.get('zoom') || 1;  // Zoom inherited from page\n\n    } else {\n      $hlbWrapper.insertAfter('body');\n      inheritedZoom = 1; // No zoom inherited, because zoom is on <body> and HLB is outside of that\n    }\n\n    // Prevents mouse movement from deflating the HLB until mouse is inside HLB\n    preventDeflationFromMouseout = true;\n\n    // Clone, style, filter\n    cloneHLB(highlight);\n\n    turnOnHLBEventListeners();\n\n    // Listeners: speech.js\n    events.emit('hlb/did-create', $hlb, highlight);\n    new metric.LensOpen().send();\n  }\n\n  /**\n   * [cloneHLB clones elements and styles from the foundation to the HLB.]\n   */\n  function cloneHLB(highlight) {\n\n    var hlbStyles;\n\n    // The cloned element (HLB)\n    $hlb = $($foundation[0].cloneNode(true));\n    var hlb = $hlb[0];\n\n    // Copies form values from the foundation to the HLB\n    // Need to do this on a timeout in order to enable Safari input fix hack\n    // Commenting out .setTimeout fixes problem on TexasAT\n    // .setTimeout(function() {\n    mapForm($foundation, $hlb);\n    // }, 0);\n\n    // Clone styles of HLB and children of HLB, so layout is preserved\n    hlbStyling.initializeStyles($foundation, $hlb, initialHLBRect, highlight.hiddenElements);\n\n    // Remove any elements and styles we dont want on the cloned element (such as <script>, id, margin)\n    // Filtering must happen after initializeStyles() because we map all children of the original element\n    // to the children of the HLB.  There is a possibility that filter will remove one of those children making\n    // it much more difficult to map...\n    hlbStyling.filter($hlb, $picked, highlight.hiddenElements);\n\n    // This step must occur after filtering, because some of the HLB default styles (such as padding),\n    // are filtered as well.  For example, if we want to HLB an element that has 20px of padding, we filter\n    // the padding styles (blacklist) and apply default styles.\n    hlbStyles = hlbStyling.getHLBStyles($picked, $foundation, highlight);\n\n    // Set the styles for the HLB and append to the wrapping element\n    inlineStyle.set(hlb, hlbStyles);\n    $hlb.appendTo($hlbWrapper);\n\n    // Fixes problem with TexasAT home page when opening the top nav (Home, Sitemap, Contact Us) in HLB\n    hlbStyling.setHLBChildTextColor($hlb);\n\n    // Set the ID of the hlb.\n    hlb.id = constants.HLB_ID;\n  }\n\n  /**\n   * [getValidListElement if the element chosen is an <li>, then we must wrap it with a <ul>\n      We must also append this newly created <ul> to the DOM so the HLB\n      module can utilize styles and positioning of the \"original element\"\n      Basically, we create a new original element.]\n   * @param  {[jQuery element]} originalElement [The element chosen by the picker]\n   * @return {[jQuery element]}                 [The element the HLB will use to create itself]\n   */\n  function getValidListElement($picked) {\n\n    var pickedElement              = $picked[0],\n        pickedElementComputedStyle = window.getComputedStyle(pickedElement),\n        pickedElementBoundingBox   = pickedElement.getBoundingClientRect(),\n        // TODO: Seth: Why not use jQuery's .clone() ??\n        pickedElementClone         = pickedElement.cloneNode(true),\n        $pickedAndDescendants      = $picked.find('*').addBack(),\n        $pickedCloneAndDescendants = $(pickedElementClone).find('*').addBack(),\n        $foundation                = $('<ul>').append(pickedElementClone),\n        i;\n\n    // ARCHITECTURE PROBLEM: This function does not take into account any elements in the DOM tree\n    // between the \"lonely\" picked element and its \"guardian\" ul or ol ancestor.\n    // Google search results currently have this structure.\n    // https://www.google.com/#q=cats\n\n    // Setting this to true will remove the $foundation from the DOM before inflation.\n    // This is a very special case where the foundation element is not the same as the picked element.\n    // NOTE: This is setting a module scoped variable so the rest of the program as access.\n    removeTemporaryFoundation = true;\n\n    // It is important to clone the styles of the parent <ul> of the original element, because it may\n    // have important styles such as background images, etc.\n    inlineStyle($foundation[0]).cssText = hlbStyling.getComputedStyleCssText($picked.parents('ul, ol')[0]);\n\n    // Create, position, and style this element so that it overlaps the element chosen by the picker.\n    inlineStyle.set($foundation[0], {\n      'position'      : 'absolute',\n      'left'          : (pickedElementBoundingBox.left + window.pageXOffset) / inheritedZoom,\n      'top'           : (pickedElementBoundingBox.top  + window.pageYOffset) / inheritedZoom,\n      'opacity'       : 0,\n      'padding'       : 0,\n      'margin'        : 0,\n      'width'         : pickedElementBoundingBox.width / inheritedZoom,\n      'listStyleType' : pickedElementComputedStyle.listStyleType || 'none'\n    });\n\n    $foundation.insertAfter('body');\n\n    // Map all picked elements children CSS to cloned children CSS\n    for (i = 0; i < $pickedAndDescendants.length; i += 1) {\n      inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);\n    }\n\n    return $foundation;\n  }\n\n  // Implemented to fix issue on http://www.gwmicro.com/Support/Email_Lists/ when HLBing Subscription Management\n  function getValidFieldsetElement($picked) {\n\n    var pickedElement              = $picked[0],\n        pickedElementsBoundingBox  = pickedElement.getBoundingClientRect(),\n        // TODO: Seth: Why not use jQuery's .clone() ??\n        pickedElementClone         = pickedElement.cloneNode(true),\n        $pickedAndDescendants      = $picked.find('*').addBack(),\n        $pickedCloneAndDescendants = $(pickedElementClone).find('*').addBack(),\n        $foundation                = $('<sc>').append(pickedElementClone),\n        i;\n\n    // Setting this to true will remove the $foundation from the DOM before inflation.\n    // This is a very special case where the foundation is not the same as the picked element.\n    // NOTE: This is setting a module scoped variable so the rest of the program as access.\n    removeTemporaryFoundation = true;\n\n    // Create, position, and style this element so that it overlaps the element chosen by the picker.\n    inlineStyle.set($foundation[0], {\n      'position'       : 'absolute',\n      'left'           : (pickedElementsBoundingBox.left + window.pageXOffset) / inheritedZoom,\n      'top'            : (pickedElementsBoundingBox.top  + window.pageYOffset) / inheritedZoom,\n      'opacity'        : 0,\n      'padding'        : 0,\n      'margin'         : 0,\n      'width'          : pickedElementsBoundingBox.width / inheritedZoom\n    });\n    $foundation.insertAfter('body');\n\n    // Map all picked elements children CSS to cloned children CSS\n    for (i = 0; i < $pickedAndDescendants.length; i += 1) {\n      inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);\n    }\n\n    return $foundation;\n  }\n\n  function setCloneIndexOnFormDescendants($picked) {\n    var i,\n      $formDescendants = $picked.find(FORMS_SELECTOR)\n        .addBack(FORMS_SELECTOR);\n\n    for (i = 0; i < $formDescendants.length; i++) {\n      $formDescendants[i].setAttribute('data-sc-cloned', i + 1);\n    }\n  }\n\n  // Implemented to fix issue on http://www.gwmicro.com/Support/Email_Lists/ when HLBing Subscription Management\n  function getValidFormElement($picked) {\n\n    var i,\n      pickedElement              = $picked[0],\n      pickedElementsBoundingBox  = pickedElement.getBoundingClientRect();\n\n    //Set data attributes on each of the form input elements\n    //This allows us to query the DOM for the original elements\n    //when we want to give them the values entered into the HLB\n    setCloneIndexOnFormDescendants($picked);\n\n    var pickedElementClone       = pickedElement.cloneNode(true),\n      $pickedAndDescendants      = $picked.find('*').addBack(),\n      $pickedCloneAndDescendants = $(pickedElementClone).find('*').addBack(),\n      $submitButton              = $(),// TODO why? This was duplicating the button: $picked.closest('form').find('input[type=\"submit\"],button[type=\"submit\"]'),\n      submitButtonClone          = $submitButton.clone(true),\n      $foundation                = $('<form>').append(pickedElementClone, submitButtonClone);\n\n    // Setting this to true will remove the $foundation from the DOM before inflation.\n    // This is a very special case where the foundation is not the same as the picked element.\n    // NOTE: This is setting a module scoped variable so the rest of the program as access.\n    removeTemporaryFoundation = true;\n\n    // Create, position, and style this element so that it overlaps the element chosen by the picker.\n    inlineStyle.set($foundation[0], {\n      'position'       : 'absolute',\n      'left'           : (pickedElementsBoundingBox.left + window.pageXOffset) / inheritedZoom,\n      'top'            : (pickedElementsBoundingBox.top  + window.pageYOffset) / inheritedZoom,\n      'opacity'        : 0,\n      'padding'        : 0,\n      'margin'         : 0,\n      'width'          : pickedElementsBoundingBox.width / inheritedZoom\n    });\n    $foundation.insertAfter('body');\n\n    // Map all picked elements children CSS to cloned children CSS\n    for (i = 0; i < $pickedAndDescendants.length; i += 1) {\n      inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);\n    }\n\n    return $foundation;\n  }\n\n  /**\n   * [getFoundation creates and returns a valid element for the HLB.\n   *  SC-1629 - Lonely bullets\n   *  It is possible that the picker chooses an element for the HLB that is invalid input, therefore,\n   *  return the valid input for the HLB given the invalid input/valid input from the picker.]\n   * @param  {[DOM element]} pickedElement   [The element chosen by the picker]\n   * @return {[DOM element]}                 [The new element create from the element chosen by the picker]\n   */\n  function getFoundation($picked) {\n\n    var tag;\n\n    for (tag in foundations) {\n      if (Object.prototype.hasOwnProperty.call(foundations, tag)) {\n        if ($picked.is(tag)) {\n          if (SC_DEV && loggingEnabled) {\n            console.log('%cSPECIAL CASE: Lonely ' + tag + '.' ,  'background:orange;');\n          }\n          return foundations[tag]($picked);\n        }\n      }\n    }\n\n    if (SC_DEV && loggingEnabled) {\n      console.log('%cTAG: ' + $picked[0].tagName,  'background:orange;');\n    }\n\n    return $picked;\n  }\n\n  /**\n   * [onHLBHover is registered as a \"mousemove\" event handler when the HLB is ready, and unregisters\n   * itself immediately after the mouse moves within the HLB element.  The purpose of this function\n   * is to handle the case where the HLB is positioned outside of the mouse coordinates and allows the\n   * deflation of the HLB by moving the mouse outside of the HLB area as well as enabling scrolling of the HLB.]\n   */\n  function onHLBHover() {\n\n    // We only need to know if the mouse has been in the HLB, so remove it once we are certain.\n    $hlb.off('mousemove');\n\n    // Any mouse detection within the HLB turns on the ability to exit HLB by moving mouse\n    preventDeflationFromMouseout = false;\n  }\n\n  function isElementInsideHlb(element) {\n    return $hlb[0] === element || $.contains($hlb[0], element);\n  }\n\n  function onClick(event) {\n    if ($hlb && !isElementInsideHlb(event.target)) {\n      // If click is outside of HLB, close it\n      // (Need to doublecheck this because HLB can sometimes be inside of <body>)\n      toggleHLB();\n    }\n  }\n\n  /**\n   * [onHLBClosed executes once the HLB is deflated (scale = 1).  This function is\n   * responsible for setting the state of the application to what it was before\n   * any HLB existed.]\n   */\n  function onHLBClosed(event) {\n\n    // Finally, remove the wrapper element for the HLB and dimmer\n    removeHLBWrapper();\n\n    hlbPositioning.setTranslateCSS(undefined);\n    hlbPositioning.setOriginCSS(undefined);\n\n    // Clean up \"module scoped\" vars\n    isHLBClosing = false;\n\n    // Listeners: hpan.js, highlight.js, speech.js\n    events.emit('hlb/closed', event);\n\n    $foundation = undefined;\n    $hlb        = undefined;\n    $picked     = undefined;\n\n    if (SC_DEV && loggingEnabled) {\n      console.log(\n        '%c--------------- HLB DESTROYED -----------------',\n        'color:orange; background:purple; font-size: 9pt'\n      );\n    }\n  }\n\n  /**\n   * [getHLBWrapper adds the sitecues HLB and DIMMER wrapper outside of the body.]\n   */\n  function getOrCreateHLBWrapper() {\n\n    var $wrapper =  $hlbWrapper ||\n            $('<sc>', {\n              'id': constants.HLB_WRAPPER_ID\n            });\n    inlineStyle.set($wrapper[0], {\n      'padding'  : 0,\n      'margin'   : 0,\n      'top'      : 0,\n      'left'     : 0,\n      'position' : 'absolute',\n      'overflow' : 'visible'\n    });\n    return $wrapper;\n  }\n\n  /**\n   * [removeHLBWrapper removes the sitecues HLB and DIMMER wrapper]\n   */\n  function removeHLBWrapper() {\n    if ($hlbWrapper) {\n      $hlbWrapper.remove();\n      $hlbWrapper = null;\n    }\n  }\n\n  //////////////////////////////////\n  // PUBLIC FUNCTIONS\n  //////////////////////////////////\n\n  // Return the current DOM element for the HLB or falsey value if there is no HLB\n  function getElement() {\n    return $hlb && $hlb[0];\n  }\n\n  // Public methods.\n\n  if (SC_DEV) {\n    console.log(\n      '%cToggle HLB logging by executing : sitecues.toggleHLBLogging();',\n      'background:black;color:white;font-size: 11pt'\n    );\n\n    /**\n     * [toggleStickyHLB enables/disables HLB deflation]\n     * @return {[Boolean]} [True if deflation is disabled.  False if deflation is enabled.]\n     */\n    sitecues.toggleStickyHLB = function() {\n      isSticky = !isSticky;\n      return isSticky;\n    };\n\n    sitecues.toggleHLBLogging = function () {\n      loggingEnabled = !loggingEnabled;\n      return loggingEnabled;\n    };\n  }\n\n  return {\n    getElement: getElement,\n    toggleHLB: toggleHLB,\n    retargetHLB: retargetHLB\n  };\n});\n","\nsitecues.define(\"hlb\", function(){});\n"]}