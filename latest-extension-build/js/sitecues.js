if ("true" !== window.localStorage.getItem("sitecues-disabled")) {
  (function() {
    var locale_data_de, locale_data_en_us, locale_data_en, locale_data_es, locale_data_fr, locale_data_pl, locale_data_sv, mini_core_user, run_util_object_utility, run_conf_preferences, mini_core_session, mini_core_page_view, run_conf_id, run_conf_site, run_conf_urls, run_constants, run_events, run_exports, run_data_map, run_locale, run_metric_metric, run_platform, run_bp_constants, run_bp_model_state, run_bp_helper, run_ab_test_ab_test, run_bp_view_markup_finalizer, run_bp_view_styles, run_bp_view_svg, mini_core_native_global, run_util_array_utility, run_inline_style_inline_style, run_bp_view_badge_placement, run_bp_view_size_animation, run_bp_view_panel_panel_classes, run_bp_view_badge_badge_classes, run_history_change_events, run_bp_view_view, run_dom_events, run_bp_controller_expand_controller, run_bp_model_classic_mode, run_bp_view_palette, run_bp_view_badge_page_badge, run_bp_bp, run_modifier_key_state, run_shake_constants, run_shake_shake, run_run, page_zoom_constants, bp_expanded_view_slider, run_errors, page_util_element_classifier, page_util_common, page_zoom_state, page_zoom_config_config, page_viewport_viewport, page_zoom_util_restrict_zoom, page_zoom_util_body_geometry, page_zoom_combo_boxes, page_util_transition_util, page_zoom_style, page_viewport_scrollbars, page_zoom_animation, page_zoom_flash, page_zoom_zoom, bp_expanded_controller_slider_controller, bp_expanded_controller_shrink_controller, bp_expanded_controller_focus_controller, bp_expanded_controller_scroll_prevention, bp_expanded_view_tts_button, bp_expanded_view_transform_util, bp_expanded_view_transform_animate, bp_expanded_view_transform_hovers, bp_expanded_view_more_button, bp_expanded_bp_expanded, bp_secondary_font_charset, bp_secondary_insert_secondary_markup, bp_secondary_tips, page_style_service_user_agent_css, page_style_service_media_queries, page_style_service_css_aggregator, page_style_service_style_service, page_util_color, page_cursor_cursor_css, page_cursor_cursor, bp_secondary_settings, bp_secondary_feedback, bp_secondary_about, run_util_xhr, bp_secondary_cards, bp_secondary_bp_secondary_features, bp_secondary_bp_secondary, bp_toolbar_badge_bp_toolbar_badge, bp_toolbar_menu_button_bp_toolbar_menu_button, bp_toolbar_menu_bp_toolbar_view, bp_toolbar_menu_bp_toolbar_features, bp_toolbar_menu_bp_toolbar_menu, bp_img_placeholder_bp_img_placeholder, page_reset_reset, page_highlight_traitcache, page_highlight_highlight_position, page_highlight_traits, page_highlight_judge, page_highlight_pick, page_util_geo, page_highlight_constants, page_highlight_highlight, page_positioner_constants, page_positioner_util_element_map, hlb_event_handlers, hlb_constants, hlb_styling, hlb_safe_area, hlb_positioning, hlb_dimmer, hlb_animation, hlb_hlb, page_positioner_util_element_info, page_positioner_style_lock_style_listener_selector_map, page_positioner_style_lock_style_listener_query_manager, page_positioner_style_lock_style_listener_selectors, page_highlight_fixed_elements, page_highlight_move_keys, page_keys_commands, page_keys_keys, page_hpan_hpan, page_positioner_transplant_clone, page_positioner_transplant_graft, page_positioner_transplant_mutation_relay, page_positioner_transplant_transplant, page_positioner_transform_targets, page_positioner_transform_rect_cache, page_positioner_transform_transform, page_positioner_positioner, page_focus_focus, page_page, theme_color_choices, theme_custom_site_theme, theme_theme, audio_constant, audio_speech_builder, audio_text_select, audio_local_player, audio_network_player, audio_audio, audio_cues_audio_cues, status_status, info_info, pick_debug_pick_debug, labs_labs, inverter_invert_url, inverter_orig_bg_info, inverter_img_classifier, inverter_bg_image_classifier, inverter_inverter, page_positioner_transplant_anchors = {}, page_positioner_style_lock_style_lock = {}, page_positioner_style_lock_style_listener_style_listener = {};
    sitecues.version = "20161027023750-LOCAL-AARON";
    locale_data_de = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Sitecues dialog",
      badge_label: "Sitecues Vergrößerungs und Sprachausgabe Steuerung. Sitecues unterstützt Menschen, die kein eigenes Bildschirmausleseprogramm oder Vergrößerungssoftware haben.",
      zoom_in: "Grösser",
      zoom_out: "Kleiner",
      // - Secondary
      more_features: "Mehr Möglichkeiten",
      previous: "Voriges",
      next: "Nöchstes",
      // - Feedback
      rating: "Bewertung",
      rating_1: "1 Stern",
      rating_2: "2 Stern",
      rating_3: "3 Stern",
      rating_4: "4 Stern",
      rating_5: "5 Stern",
      // Visible labels
      // - Main
      pre_zoom: "",
      post_zoom: " fach Zoom",
      zoom_off: "Zoom Aus",
      speech: "Sprache",
      on: "Ein",
      off: "Aus",
      // - Secondary
      tips: "Tipps",
      settings: "Einstellen",
      rate_us: "Bewerten",
      rate_us_prompt: "Wir würden uns über Rückmeldungen sehr freuen!",
      rate_us_suggest: "Haben Sie Fragen, Anmerkungen oder Vorschläge?",
      about: "Über uns",
      // - Feedback
      send: "Senden",
      tell_us_something: "Teilen Sie uns etwas mit ...",
      thank_you: "Danke",
      // - About
      about_preamble: "Diese Seite verwendet sirecues um Ihnen den Zugang zu erleichtern. Sie können die Inhalte vergrößern oder sogar vorlesen lassen. Weitere Informationen finden Sie unter ",
      about_rate_us: "Wir freuen uns über Rückmeldung Ihrer Erfahrungen mit Sitecues.",
      zoom_and_speech: "Vergrösserung &amp; Sprache"
    };
    locale_data_en_us = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Sitecues main panel",
      badge_label: "Sitecues zoom and speech tools; Sitecues assists users who do not have their own screen reader or magnifier.",
      zoom_in: "zoom in",
      zoom_out: "zoom out",
      // - Secondary
      more_features: "More features",
      previous: "Previous",
      next: "Next",
      // - Feedback
      rating: "Rating",
      rating_1: "1 star",
      rating_2: "2 stars",
      rating_3: "3 stars",
      rating_4: "4 stars",
      rating_5: "5 stars",
      // Visible labels
      // - Main
      pre_zoom: "Zoom ",
      post_zoom: "x",
      zoom_off: "Zoom Off",
      speech: "Speech",
      on: "On",
      off: "Off",
      // - Secondary
      tips: "Tips",
      settings: "Settings",
      rate_us: "Rate us",
      rate_us_prompt: "We would love to hear from you!",
      rate_us_suggest: "Have questions, comments or suggestions?",
      about: "About",
      // - Feedback
      send: "Send",
      tell_us_something: "Tell us something ...",
      thank_you: "Thank you",
      // - About
      about_preamble: "This website has added Sitecues to make it easier to see, hear, and use. For more information, please visit ",
      about_rate_us: "We encourage you to provide feedback on your experience.",
      zoom_and_speech: "zoom &amp; speech"
    };
    locale_data_en = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Sitecues main panel",
      badge_label: "Sitecues zoom and speech tools; Sitecues assists users who do not have their own screen reader or magnifier.",
      zoom_in: "zoom in",
      zoom_out: "zoom out",
      // - Secondary
      more_features: "More features",
      previous: "Previous",
      next: "Next",
      // - Feedback
      rating: "Rating",
      rating_1: "1 star",
      rating_2: "2 stars",
      rating_3: "3 stars",
      rating_4: "4 stars",
      rating_5: "5 stars",
      // Toolbar
      options_menu: "Sitecues options menu",
      // Visible labels
      // - Main
      pre_zoom: "Zoom ",
      post_zoom: "x",
      zoom_off: "Zoom Off",
      speech: "Speech",
      on: "On",
      off: "Off",
      // - Secondary
      tips: "Tips",
      settings: "Settings",
      rate_us: "Rate us",
      rate_us_prompt: "We would love to hear from you!",
      rate_us_suggest: "Have questions, comments or suggestions?",
      about: "About",
      // - Feedback
      send: "Send",
      tell_us_something: "Tell us something ...",
      thank_you: "Thank you",
      // - About
      about_preamble: "This website has added Sitecues to make it easier to see, hear, and use. For more information, please visit ",
      about_rate_us: "We encourage you to provide feedback on your experience.",
      zoom_and_speech: "zoom &amp; speech"
    };
    locale_data_es = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Panel principal de Sitecues",
      badge_label: "Herramientas de acercamiento y de voz de Sitecues. Sitecues ayuda a los usuarios que no tienen su propio lector de pantalla o magnificador de pantalla.",
      zoom_in: "aumentar acercamiento",
      zoom_out: "aisminuir acercamiento",
      // - Secondary
      more_features: "Más características",
      previous: "Previo",
      next: "Siguiente",
      // - Feedback
      rating: "Clasificación",
      rating_1: "1 estrella",
      rating_2: "2 estrellas",
      rating_3: "3 estrellas",
      rating_4: "4 estrellas",
      rating_5: "5 estrellas",
      // Visible labels
      // - Main
      pre_zoom: "Acercamiento ",
      post_zoom: "x",
      zoom_off: "Sin acercamiento",
      speech: "Voz",
      on: "Alta",
      off: "Baja",
      // - Secondary
      tips: "Consejos",
      settings: "Ajustes",
      rate_us: "Feedback",
      rate_us_prompt: "¡Nos encantaría saber de usted!",
      rate_us_suggest: "¿Tiene preguntas, comentarios o sugerencias?",
      about: "Sobre",
      // - Feedback
      send: "Enviar",
      tell_us_something: "Cuéntanos algo...",
      thank_you: "Gracias",
      // - About
      about_preamble: "Este sitio web ha añadido Sitecues para que sea más fácil de ver, oír y usar. Para mayor información por favor visite ",
      about_rate_us: "Le animamos a proporcionar comentarios sobre su experiencia.",
      zoom_and_speech: "amplia y habla"
    };
    locale_data_fr = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Console d'administration Sitecues",
      badge_label: "Outils de zoom et diction Sitecues. Sitecues aide les utilisateurs qui ne possèdent pas leur propre lecteur d'écran ou agrandisseur d'écran.",
      zoom_in: "agrandir",
      zoom_out: "réduire",
      // - Secondary
      more_features: "plus de fonctionnalités",
      previous: " précédent",
      next: " Suivant",
      // - Feedback
      rating: "évaluation",
      rating_1: "1 étoile ",
      rating_2: "2 étoiles ",
      rating_3: "3 étoiles ",
      rating_4: "4 étoiles",
      rating_5: " étoiles",
      // Visible labels
      // - Main
      pre_zoom: "Zoom ",
      post_zoom: "x",
      zoom_off: "Zoom desactivé",
      speech: "Diction",
      on: "activée",
      off: "desactivée",
      // - Secondary
      tips: "Pointe",
      settings: "Réglages",
      rate_us: "Évaluez",
      rate_us_prompt: "Nous serons très heureux de vous entendre!",
      rate_us_suggest: "Avez-vous des questions, des commentaires ou suggestions?",
      about: "Environ",
      // - Feedback
      send: "Envoyer",
      tell_us_something: "Parlez nous de vous en quelques choses...",
      thank_you: "Merci",
      // - About
      about_preamble: "Cet site web à ajouté des sites pour le rendre plus simple à voir, entendre, et à utiliser. Pour plus d'information, visiter nous s'il vous plait ",
      about_rate_us: "Nous vous encourageons à fournir des commentaires sur votre expérience.",
      zoom_and_speech: "zoom et discours"
    };
    locale_data_pl = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "główny panel Sitecues",
      badge_label: "narzędzia powiększania i mowy Sitecues; Sitecues pomaga słabowidzącym, którzy nie mają własnego programu czytającego czy powiększającego.",
      zoom_in: "powiększ",
      zoom_out: "pomniejsz",
      // - Secondary
      more_features: "Więcej ustawień",
      previous: "Poprzedni",
      next: "Następny",
      // - Feedback
      rating: "Ocena",
      rating_1: "1 gwiazdka",
      rating_2: "2 gwiazdki",
      rating_3: "3 gwiazdki",
      rating_4: "4 gwiazdki",
      rating_5: "5 gwiazdek",
      // Visible labels
      // - Main
      pre_zoom: "Powiększenie ",
      post_zoom: "x",
      zoom_off: "Powiększenie Wył",
      speech: "Głos",
      on: "Wł.",
      off: "Wył",
      // - Secondary
      tips: "Porady",
      settings: "Ustawienia",
      rate_us: "Oceń nas",
      rate_us_prompt: "Chcielibyśmy je usłyszeć!”",
      rate_us_suggest: "Masz pytania, komentarze, sugestie?",
      about: "O nas",
      // - Feedback
      send: "Wyślij",
      tell_us_something: "Powiedz nam ...",
      thank_you: "Dziękujemy",
      // - About
      about_preamble: "Ta strona zawiera Sitecues, dzięki czemu można ją lepiej zobaczyć, usłyszeć i używać. Więcej informacji znajdziesz tutaj ",
      about_rate_us: "Prosimy o informację o Państwa doświadczeniach.",
      zoom_and_speech: "powiększenie i mowa"
    };
    locale_data_sv = {
      // ARIA labels
      // - Main
      sitecues_main_panel: "Sitecues huvudpanel",
      badge_label: "Sitecues zoom- och läsverktyg; Sitecues vänder sig till användare som inte har en egen skärmläsare eller skärmförstorare.",
      zoom_in: "zooma in",
      zoom_out: "zooma ut",
      // - Secondary
      more_features: "Fler funktioner",
      previous: "Föregående",
      next: "Nästa",
      // - Feedback
      rating: "Betyg",
      rating_1: "1 stjärna",
      rating_2: "2 stjärnor",
      rating_3: "3 stjärnor",
      rating_4: "4 stjärnor",
      rating_5: "5 stjärnor",
      // Visible labels
      // - Main
      pre_zoom: "Zoom ",
      post_zoom: "x",
      zoom_off: "Zooma av",
      speech: "Tal",
      on: "på",
      off: "av",
      // - Secondary
      tips: "Tips",
      settings: "Inställn.",
      rate_us: "Tyck till",
      rate_us_prompt: "Vi skulle bli jätteglada om du hör av dig till oss!",
      rate_us_suggest: "Har du frågor, kommentarer eller förslag?",
      about: "Om",
      // - Feedback
      send: "Skicka",
      tell_us_something: "Berätta något för oss …",
      thank_you: "Tack så mycket",
      // - About
      about_preamble: "Denna webbsida använder Sitecues för att göra det lättare att se, lyssna och använda. För mer information, besök ",
      about_rate_us: "Vi tar gärna emot din feedback på din upplevelse.",
      zoom_and_speech: "zoom &amp; läs"
    };
    mini_core_user = function() {
      function assign(data) {
        return new Promise(function(resolve, reject) {
          chrome.storage.local.set(data, function() {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve();
            }
          });
        });
      }
      function getAll() {
        return new Promise(function(resolve, reject) {
          // Passing in null gets the entire contents of storage
          chrome.storage.local.get(null, function(storage) {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            } else {
              resolve(storage || {});
            }
          });
        });
      }
      function getId() {
        return Promise.resolve("user-123");
      }
      return {
        prefs: {
          assign: assign,
          getAll: getAll
        },
        getId: getId
      };
    }();
    run_util_object_utility = function() {
      // Using the MDN polyfill for IE11
      var assign = "function" === typeof Object.assign ? Object.assign : function(target) {
        if (void 0 === target || null === target) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        target = Object(target);
        Array.prototype.slice.call(arguments, 1).forEach(function(source) {
          if (void 0 !== source && null !== source) {
            Object.keys(source).forEach(function(key) {
              target[key] = source[key];
            });
          }
        });
        return target;
      };
      return {
        assign: assign
      };
    }();
    run_conf_preferences = function(user, objectUtil) {
      var cachedPrefs, handlers = {}, listeners = {};
      // Listeners are passed new preference values once they've been handled
      function bindListener(key, listener) {
        var prefValue = getPref(key);
        if ("undefined" !== typeof prefValue) {
          // Here we're perpetuating a pattern from the previous module design, if the
          // value has already been defined when we bind this listener, call the listener
          // with the current value. It's a little funky
          listener(prefValue);
        }
        listeners[key] = listeners[key] || [];
        listeners[key].push(listener);
      }
      // Handlers are passed new preference values, and the return value is saved and passed to
      // listeners to the preference
      function defineHandler(key, handler) {
        // set handler for key
        if ("function" === typeof handler) {
          handlers[key] = handler;
        }
      }
      // If callback is defined,
      function getPref(key) {
        if (!key) {
          return objectUtil.assign({}, cachedPrefs);
        }
        return cachedPrefs[key];
      }
      function setPref(key, value) {
        var safeValue;
        if (handlers[key]) {
          safeValue = handlers[key](value);
        } else {
          safeValue = value;
        }
        if (listeners[key]) {
          listeners[key].forEach(function(listener) {
            listener(safeValue);
          });
        }
        cachedPrefs[key] = safeValue;
        var setObj = {};
        setObj[key] = safeValue;
        user.prefs.assign(setObj);
      }
      function unset(key) {
        setPref(key, void 0);
      }
      // Reset all settings as if it is a new user
      function resetPrefs() {
        // Undefine all settings and call setting notification callbacks
        Object.keys(cachedPrefs).forEach(unset);
      }
      function hasPref(key) {
        return Boolean(cachedPrefs[key]);
      }
      function isSitecuesUser() {
        return hasPref("zoom") || hasPref("ttsOn");
      }
      function isValid() {
        return Boolean(cachedPrefs);
      }
      function init() {
        return user.prefs.getAll().then(function(prefs) {
          cachedPrefs = prefs;
        });
      }
      return {
        get: getPref,
        set: setPref,
        has: hasPref,
        isSitecuesUser: isSitecuesUser,
        reset: resetPrefs,
        defineHandler: defineHandler,
        bindListener: bindListener,
        isValid: isValid,
        init: init
      };
    }(mini_core_user, run_util_object_utility);
    mini_core_session = {
      getId: function() {
        return "session-123";
      }
    };
    mini_core_page_view = {
      getId: function() {
        return "page-123";
      }
    };
    run_conf_id = function(user, session, pageView) {
      var exports = {
        init: init
      };
      function init() {
        return user.getId().then(function(userId) {
          // Only the user id needs to be fetch asynchronously (it is retrieved from global storage)
          exports.session = session.getId();
          exports.pageView = pageView.getId();
          exports.user = userId;
          exports.isValid = exports.session && exports.pageView && exports.user;
        });
      }
      return exports;
    }(mini_core_user, mini_core_session, mini_core_page_view);
    run_conf_site = function() {
      var providedSiteConfig, everywhereConfig;
      // Get the site configuration property
      function get(key) {
        return getEverywhereConfig()[key] || getProvidedSiteConfig()[key];
      }
      // Names with underscores deprecated.
      // Here is the order of precedence:
      // 1. sitecues everywhere siteId
      // 2. sitecues.config.siteId (camelCase is the new way)
      // 3. sitecues.config.site_id (underscore in config field names is deprecated)
      function getSiteId() {
        var siteId = everywhereConfig.siteId || providedSiteConfig.siteId || providedSiteConfig.site_id;
        return siteId && siteId.trim();
      }
      // Get the entire site config object
      function getProvidedSiteConfig() {
        return sitecues.config || {};
      }
      // Configuration for sitecues everywhere, if it exists
      // TODO Should go away once we go to the new extension which is entirely in a content script
      function getEverywhereConfig() {
        return sitecues.everywhereConfig || {};
      }
      function init() {
        providedSiteConfig = getProvidedSiteConfig();
        everywhereConfig = getEverywhereConfig();
      }
      return {
        init: init,
        get: get,
        getSiteId: getSiteId,
        getSiteConfig: getProvidedSiteConfig,
        getEverywhereConfig: getEverywhereConfig
      };
    }();
    run_conf_urls = function(site) {
      var apiPrefix, // Either ws.sitecues.com/ or ws.dev.sitecues.com/
      scriptOrigin, // Either http[s]://js.sitecues.com/ or http[s]://js.dev.sitecues.com/
      BASE_RESOURCE_URL;
      function getBaseResourceUrl() {
        var basis = true ? getRawScriptUrl() : sitecues.require.toUrl(""), insecureBaseUrl = basis.substring(0, basis.lastIndexOf("/js/") + 1);
        return true ? insecureBaseUrl : enforceHttps(insecureBaseUrl);
      }
      // Change http:// or protocol-relative (just //) urls to use https
      // TODO Occasionally the sitecues.js core is loaded with http -- we will change that in the minicore. Remove this once we do that.
      function enforceHttps(absoluteUrl) {
        return "https:" + absoluteUrl.replace(/^https?:/, "");
      }
      // URL string for API calls
      function getApiUrl(restOfUrl) {
        return "https://" + apiPrefix + "sitecues/api/" + restOfUrl;
      }
      // Get an API like http://ws.sitecues.com/sitecues/api/css/passthrough/?url=http%3A%2F%2Fportal.dm.gov.ae%2FHappiness...
      // We use this for the image and CSS proxy services
      // Pass in the proxyApi, e.g. 'image/invert' or 'css/passthrough'
      function getProxyApiUrl(proxyApi, url) {
        var absoluteUrl = resolveUrl(url);
        return getApiUrl(proxyApi + "/?url=" + encodeURIComponent(absoluteUrl));
      }
      // URL string for sitecues.js
      // Enforces https so that all the resources we fetch and origin checking also uses https
      function getRawScriptUrl() {
        var insecureBaseUrl = enforceHttps(site.get("appUrl"));
        return true ? insecureBaseUrl : enforceHttps(insecureBaseUrl);
      }
      // Parsed URL object for sitecues.js
      function getParsedLibraryURL() {
        // Underscore names deprecated
        var url = getRawScriptUrl();
        return url && parseUrl(url);
      }
      //////////////////////////////////////////////////////////////////////////////////////////
      //
      //  URL Processing
      //
      //////////////////////////////////////////////////////////////////////////////////////////
      // Parse a URL into { protocol, hostname, origin, path }
      // Does not support mailto links (or anything where the protocol isn't followed by //)
      // TODO After we kill IE11, we can move to new URL(), but be careful of IE incompatibilities (e.g. port, origin, host)
      function parseUrl(urlStr) {
        if ("string" !== typeof urlStr) {
          return;
        }
        var pathname, lastSlashIndex, protocol, path, hostname, origin, port, parser = document.createElement("a");
        // Set up parser
        parser.href = urlStr;
        // Extract the path of the pathname.
        pathname = parser.pathname;
        // Ensure pathname begins with /
        // TODO is this necessary in any browser? Used to be for IE9
        if (pathname.indexOf("/") > 0) {
          pathname = "/" + pathname;
        }
        lastSlashIndex = pathname.lastIndexOf("/") + 1;
        protocol = parser.protocol || document.location.protocol;
        // IE does not include protocol unless it was specified. If not specified, get from current document.
        path = pathname.substring(0, lastSlashIndex);
        hostname = parser.hostname;
        origin = parser.origin;
        if (!origin) {
          // IE didn't give us the origin, so we construct it from the protocol, hostname and maybe the port
          origin = protocol + "//" + hostname;
          port = parser.port;
          // Fallback approach for IE -- note this doesn't include @username or password info
          // Add the port if it's specified in the url (80/443 is the default port, so only add that if it's really present in the url)
          if (port && urlStr.indexOf(":" + port + "/") > 0) {
            origin += ":" + port;
          }
        }
        return {
          protocol: protocol,
          path: path,
          hostname: hostname,
          origin: origin
        };
      }
      function isValidLibraryUrl() {
        return !!getParsedLibraryURL().hostname;
      }
      // Resolve a URL as relative to the main script URL.
      // Add a version parameter so that new versions of the library always get new versions of files we use, rather than cached versions.
      function resolveResourceUrl(urlStr, paramsMap) {
        var url = BASE_RESOURCE_URL + urlStr, params = paramsMap && Object.keys(paramsMap);
        function addParam(name) {
          url += name + "=" + encodeURIComponent(paramsMap[name]) + "&";
        }
        if (params) {
          url += "?";
          params.forEach(addParam);
        }
        return url;
      }
      // Is this production sitecues?
      function isProduction() {
        return "js.sitecues.com" === getParsedLibraryURL().hostname;
      }
      // Most sitecues scripts are loaded with https
      function getScriptOrigin() {
        if (!scriptOrigin) {
          scriptOrigin = getParsedLibraryURL().origin;
        }
        return scriptOrigin;
      }
      // The regular expression for an absolute URL. There is a capturing group for
      // the protocol-relative portion of the URL.
      var ABSOLUTE_URL_REGEXP = /^[a-zA-Z0-9-]+:(\/\/.*)$/i;
      // Return an absolute URL. If the URL was relative, return an absolute URL that is relative to a base URL.
      // @optional parsedBaseUrl If not provided, will use the current page.
      function resolveUrl(urlStr, baseUrl) {
        if ("function" === typeof URL) {
          // URL object exists in IE11 but "new URL()" throws error "Object doesn’t support this action"
          // TODO Strangely, saw an exception in Firefox 38: -- Illegal constructor
          // {"eventId":"87611cd9-5e0c-4ad9-b338-f4ce5b312e09","serverTs":1463709667327,"clientIp":"10.235.39.83","siteKey":"s-1e3f787a","isTest":false,"userId":null,"clientData":{"scVersion":"4.0.73-RELEASE","metricVersion":12,"sessionId":"12d5eb35-2f8b-4dd3-8006-722f6cfec4a5","pageViewId":"ac606acb-b05c-42b8-adba-13a764ee7372","siteId":"s-1e3f787a","userId":"cdbb986e-29e2-4a27-b07f-c1f253b2c645","pageUrl":"http://bestfriends.org/sanctuary/animals-special-needs/current/harvard?utm_medium=email&utm_source=bsd&utm_campaign=newsletter&utm_content=20160519&utm_term=2016national","browserUserAgent":"Mozilla/5.0 (Windows NT 6.1; rv:38.9) Gecko/20100101 Goanna/2.0 Firefox/38.9 PaleMoon/26.1.1","isClassicMode":false,"clientLanguage":"en-US","source":"page","isTester":false,"name":"error","clientTimeMs":1463709666975,"zoomLevel":1,"ttsState":false,"details":{"message":"Illegal constructor.","stack":".resolveUrl@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:28\nr@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\na@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\no@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nh@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\ns@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\n.each@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:1\nZ.prototype.each@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:1\nx@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nZ.Callbacks/c@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:1\nZ.Callbacks/f.add@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:1\nZ.fn.ready@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:1\ny@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nc@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nv@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\ng@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nm@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/page.js:4\nr/<@https://js.sitecues.com/l/s;id=s-1e3f787a/4.0.73-RELEASE/js/bp-toolbar-badge.js:1\nW@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:8\nO@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:9\nP/<@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:10\nk@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:20\nO/k.then/</<@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:21\nc/</<@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:19\nc/<@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:19\na@https://js.sitecues.com/l/s;id=s-1e3f787a/js/sitecues.js:19\n"}}}
          var parsedUrl = new URL(urlStr, baseUrl || document.location);
          return parsedUrl.toString();
        }
        // IE 9-11 polyfill (also Edge 12)
        // TODO remove if IE11 ever goes away!!
        var parsedBaseUrl = parseUrl(baseUrl || ".");
        var absRegExpResult = ABSOLUTE_URL_REGEXP.exec(urlStr);
        if (absRegExpResult) {
          // We have an absolute URL, with protocol. That's a no-no, so, convert to a
          // protocol-relative URL.
          urlStr = urlStr;
        } else {
          if (0 === urlStr.indexOf("//")) {
            // Protocol-relative. Add parsedBaseUrl's protocol.
            urlStr = parsedBaseUrl.protocol + urlStr;
          } else {
            if (0 === urlStr.indexOf("/")) {
              // Host-relative URL.
              urlStr = parsedBaseUrl.origin + urlStr;
            } else {
              // A directory-relative URL.
              urlStr = parsedBaseUrl.origin + parsedBaseUrl.path + urlStr;
            }
          }
        }
        // Replace ../ at beginning of path with just / as there is no parent folder to go to
        urlStr = urlStr.replace(/(^http[^\/]+\/\/[^\/]+\/)(?:\.\.\/)/, "$1", "i");
        return urlStr;
      }
      function isSameOrigin(url) {
        return parseUrl(url).origin === window.location.origin;
      }
      // Will cross-origin restrictions possibly burn us?
      function isCrossOrigin(url) {
        return !isSameOrigin(url);
      }
      // Returns the resource file extension, or an empty string if one isn't found
      function extname(url) {
        var index = url.lastIndexOf(".");
        return index >= 0 ? url.substring(index) : "";
      }
      function init() {
        var domainEnding = isProduction() ? ".sitecues.com" : ".dev.sitecues.com";
        BASE_RESOURCE_URL = getBaseResourceUrl();
        apiPrefix = "ws" + domainEnding + "/";
      }
      return {
        init: init,
        getApiUrl: getApiUrl,
        getProxyApiUrl: getProxyApiUrl,
        getScriptOrigin: getScriptOrigin,
        isValidLibraryUrl: isValidLibraryUrl,
        getRawScriptUrl: getRawScriptUrl,
        resolveResourceUrl: resolveResourceUrl,
        parseUrl: parseUrl,
        isSameOrigin: isSameOrigin,
        isCrossOrigin: isCrossOrigin,
        isProduction: isProduction,
        resolveUrl: resolveUrl,
        extname: extname
      };
    }(run_conf_site);
    run_constants = function() {
      var constants = {};
      constants.READY_STATE = {
        UNINITIALIZED: 0,
        INITIALIZING: 1,
        COMPLETE: 2
      };
      constants.METRIC_NAME = {
        BADGE_HOVER: "badge-hovered",
        ERROR: "error",
        FEEDBACK: "feedback-sent",
        KEY_COMMAND: "key-command",
        LENS_OPEN: "hlb-opened",
        MOUSE_SHAKE: "mouse-shake",
        OPTION_MENU_OPEN: "options-menu-open",
        OPTION_MENUITEM_SELECTION: "options-menuitem-selected",
        PAGE_CLICK_FIRST: "page-clicked-first",
        PAGE_SCROLL_FIRST: "page-scrolled-first",
        PAGE_UNLOAD: "page-unloaded",
        PANEL_CLICK: "panel-clicked",
        PANEL_CLOSE: "panel-closed",
        PANEL_FOCUS_MOVE: "panel-focus-moved",
        SITECUES_READY: "sc-ready",
        SLIDER_SETTING_CHANGE: "slider-setting-changed",
        TTS_REQUEST: "tts-requested",
        ZOOM_CHANGE: "zoom-changed"
      };
      constants.KEY_CODE = {
        MINUS_ALT1: 173,
        MINUS_ALT2: 45,
        MINUS_ALT3: 189,
        EQUALS_ALT1: 187,
        EQUALS_ALT2: 61,
        PLUS: 43,
        NUMPAD_SUBTRACT: 109,
        NUMPAD_ADD: 107,
        NUMPAD_0: 48,
        NUMPAD_1: 97,
        NUMPAD_2: 98,
        NUMPAD_3: 99,
        NUMPAD_4: 100,
        NUMPAD_6: 102,
        NUMPAD_7: 103,
        NUMPAD_8: 104,
        NUMPAD_9: 105,
        QUOTE: 222,
        ESCAPE: 27,
        SPACE: 32,
        PAGE_UP: 33,
        PAGE_DN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        LETTER_H: 72,
        SHIFT: 16,
        CTRL: 17,
        F8: 119,
        TAB: 9,
        ENTER: 13
      };
      constants.ZOOM_OUT_CODES = [ constants.KEY_CODE.MINUS_ALT1, constants.KEY_CODE.MINUS_ALT2, constants.KEY_CODE.MINUS_ALT3, constants.KEY_CODE.NUMPAD_SUBTRACT ];
      constants.ZOOM_IN_CODES = [ constants.KEY_CODE.EQUALS_ALT1, constants.KEY_CODE.EQUALS_ALT2, constants.KEY_CODE.PLUS, constants.KEY_CODE.NUMPAD_ADD ];
      constants.INIT_CODES = [ constants.KEY_CODE.QUOTE ].concat(constants.ZOOM_IN_CODES, constants.ZOOM_OUT_CODES);
      constants.MIN_TIME_BETWEEN_KEYS = 80;
      // How quickly might humans reasonably repeat keys
      return constants;
    }();
    run_events = function() {
      var arr = Array.prototype, manager = {};
      //////////////////////////////////////////////////////////////////////////////////////////
      //
      //  Event Management
      //
      //////////////////////////////////////////////////////////////////////////////////////////
      // bind an event, specified by a string name, `events`, to a `callback`
      // function. passing `'*'` will bind the callback to all events fired
      function on(events, callback, context) {
        /* jshint validthis: true */
        var ev, list, tail;
        events = events.split(/\s+/);
        var calls = this._events || (this._events = {});
        // The events.length check before events.shift() protects us against prototype.js
        while (events.length && (ev = events.shift())) {
          // create an immutable callback list, allowing traversal during
          // modification. the tail is an empty object that will always be used
          // as the next node
          list = calls[ev] || (calls[ev] = {});
          tail = list.tail || (list.tail = list.next = {});
          tail.callback = callback;
          tail.context = context;
          list.tail = tail.next = {};
        }
        return this;
      }
      // remove one or many callbacks. if `context` is null, removes all callbacks
      // with that function. if `callback` is null, removes all callbacks for the
      // event. if `events` is null, removes all bound callbacks for all events
      function off(events, callback, context) {
        /* jshint validthis: true */
        var ev, node, calls = this._events;
        if (!events) {
          delete this._events;
        } else {
          if (calls) {
            events = events.split(/\s+/);
            while (events.length && (ev = events.shift())) {
              node = calls[ev];
              delete calls[ev];
              if (!callback || !node) {
                continue;
              }
              // create a new list, omitting the indicated event/context pairs
              while ((node = node.next) && node.next) {
                if (node.callback === callback && (!context || node.context === context)) {
                  continue;
                }
                this.on(ev, node.callback, node.context);
              }
            }
          }
        }
        return this;
      }
      // emit an event, firing all bound callbacks. callbacks are passed the
      // same arguments as `emit` is, apart from the event name.
      function emit(events) {
        /* jshint validthis: true */
        var event, node, calls, tail, args, rest;
        if (!(calls = this._events)) {
          return this;
        }
        (events = events.split(/\s+/)).push(null);
        // save references to the current heads & tails
        while (events.length && (event = events.shift())) {
          if (!(node = calls[event])) {
            continue;
          }
          events.push({
            next: node.next,
            tail: node.tail
          });
        }
        // traverse each list, stopping when the saved tail is reached.
        rest = arr.slice.call(arguments, 1);
        while (node = events.pop()) {
          tail = node.tail;
          args = node.event ? [ node.event ].concat(rest) : rest;
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, args);
          }
        }
        return this;
      }
      manager.on = function() {
        var args = Array.prototype.slice.call(arguments);
        on.apply(manager, args);
      };
      manager.off = function() {
        var args = Array.prototype.slice.call(arguments);
        off.apply(manager, args);
      };
      manager.emit = function() {
        var args = Array.prototype.slice.call(arguments);
        emit.apply(manager, args);
      };
      return {
        on: manager.on,
        off: manager.off,
        emit: manager.emit
      };
    }();
    run_exports = function(constants, events) {
      // Enums for sitecues loading state
      var state = constants.READY_STATE;
      // This function is called when we are sure that no other library already exists in the page. Otherwise,
      // we risk overwriting the methods of the live library.
      function init(isOn) {
        // Events
        //Currently used on Chicago Lighthouse, we should discourage customer use of public event API
        //in preparation for changing it in the future
        sitecues.on = events.on;
        // Start listening for an event.
        sitecues.emit = events.emit;
        // Tell listeners about an event.
        sitecues.off = events.off;
        // Stop listening for an event.
        // Get info about the currently running sitecues client
        sitecues.status = getStatus;
        sitecues.getVersion = getVersion;
        sitecues.isOn = isOn;
        // Control BP expansion
        sitecues.expandPanel = expandPanel;
        sitecues.shrinkPanel = shrinkPanel;
        // Sitecues reset
        sitecues.reset = function() {};
        // noop unless page module is loaded (if not loaded, there is nothing to reset)
        //Loading state enumerations
        sitecues.readyStates = state;
        // 'Plant our flag' on this page.
        sitecues.exists = true;
      }
      function expandPanel() {
        !function(expandController) {
          expandController.expandPanel();
        }(run_bp_controller_expand_controller);
      }
      function shrinkPanel() {
        !function(shrinkController) {
          shrinkController.shrinkPanel();
        }(bp_expanded_controller_shrink_controller);
      }
      function getVersion() {
        return sitecues.version;
      }
      function getStatus() {
        var args = arguments;
        !function(statusFn) {
          statusFn.apply(this, args);
        }(status_status);
      }
      return {
        init: init
      };
    }(run_constants, run_events);
    run_data_map = function() {
      // This is a handlebars template!
      // It is generated from the contents of data folders via the build system
      // See task/extension/js.js -- generateDataMapFile()
      //noinspection JSUnresolvedVariable,JSUnresolvedVariable,JSUnresolvedVariable,JSUnresolvedVariable
      /* jshint ignore:start */
      function get(dataModuleName, callback) {
        if ("locale-data/de" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_de);
        }
        if ("locale-data/en-us" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_en_us);
        }
        if ("locale-data/en" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_en);
        }
        if ("locale-data/es" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_es);
        }
        if ("locale-data/fr" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_fr);
        }
        if ("locale-data/pl" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_pl);
        }
        if ("locale-data/sv" === dataModuleName) {
          !function(data) {
            callback(data);
          }(locale_data_sv);
        }
      }
      /* jshint ignore:end */
      return {
        get: get
      };
    }();
    run_locale = function(dataMap, Promise) {
      var mainBrowserLocale, translations = {}, DEFAULT_LOCALE = "en-us", LOCALE_DATA_PREFIX = "locale-data/", SUPPORTED_UI_LANGS = {
        de: 1,
        en: 1,
        es: 1,
        fr: 1,
        pl: 1,
        sv: 1
      }, // Countries which have localization files that are different from the default for that language
      // For example, en-us files use 'color' instead of the worldwide standard 'colour'
      COUNTRY_EXCEPTIONS = {
        "en-US": 1
      };
      // Get the language but not the regional differences
      // For example, return just 'en' but not 'en-US'.
      function getLanguageFromLocale(locale) {
        return locale.split("-")[0];
      }
      // The the full xx-XX code for the web page
      function getPageLocale() {
        var validDocLocale, docElem = document.documentElement, docLocales = [ getTranslationLocale(), docElem.lang, docElem.getAttribute("xml:lang"), getMetaTagLocale() ];
        docLocales.some(function(locale) {
          if (isValidLocale(locale)) {
            validDocLocale = locale;
            return true;
          }
        });
        return validDocLocale || mainBrowserLocale || DEFAULT_LOCALE;
      }
      function getCookies() {
        var nameValSplit, chunks = document.cookie.split("; "), cookies = {}, index = chunks.length;
        while (index--) {
          nameValSplit = chunks[index].split("=");
          cookies[nameValSplit[0]] = nameValSplit[1];
        }
        return cookies;
      }
      // TODO bing translator
      function getTranslationLocale() {
        var googtrans = getCookies().googtrans;
        // In format of /fromlang/tolang
        return googtrans && googtrans.substring(googtrans.lastIndexOf("/") + 1);
      }
      function isValidLocale(locale) {
        // Regex from http://stackoverflow.com/questions/3962543/how-can-i-validate-a-culture-code-with-a-regular-expression
        var VALID_LOCALE_REGEX = /^[a-z]{2,3}(?:-[A-Z]{2,3}(?:-[a-zA-Z]{4})?)?$/;
        return locale && locale.match(VALID_LOCALE_REGEX);
      }
      function getMetaTagLocale() {
        var metaLocale, META_LANG_SELECTOR = "meta[name=language],meta[http-equiv=language],meta[name=Content-Language],meta[http-equiv=Content-Language]", // TODO Once we kill off Firefox < 47 and Chrome < 49 we can do a case insensitive check:
        // 'meta[name=language i],meta[http-equiv=language i],meta[name=Content-Language i],meta[http-equiv=Content-Language i]',
        metaLocaleElement = document.querySelector(META_LANG_SELECTOR);
        if (metaLocaleElement) {
          metaLocale = metaLocaleElement.getAttribute("content").split(",")[0].trim();
          // Can be comma-separated
          // Validate the format of the attribute -- some docs online use invalid strings such as 'Spanish'
          return isValidLocale(metaLocale) && metaLocale;
        }
      }
      /**
   * Represents website language.
   * For example, returns 'en', 'de'
   * If there are country-specific translation exceptions, such as 'en-US', we strip the last part and return only 'en'
   * @returns String
   */
      function getLang() {
        var websiteLanguage = getPageLocale();
        return getLanguageFromLocale(websiteLanguage);
      }
      function getSupportedUiLang() {
        var lang = getLang();
        return SUPPORTED_UI_LANGS[lang] ? lang : DEFAULT_LOCALE;
      }
      // If document is in the same language as the browser, then
      // we should prefer to use the browser's country-specific version of that language.
      // This helps make sure UK users get a UK accent on all English sites, for example.
      // We now check all the preferred languages of the browser.
      // @param countriesWhiteList -- if provided, it is the list of acceptable fully country codes, e.g. en-US.
      // If not provided, all countries and langs are acceptable
      // @param langsWhiteList -- if provided, it is the list of acceptable languages.
      function swapToPreferredRegion(locale, countriesWhiteList, langsWhiteList) {
        var langWithCountry, langPrefix = getLanguageFromLocale(locale), prioritizedBrowserLocales = function() {
          var browserLocales = (navigator.languages || []).slice();
          // Put the mainBrowserLang at the start of the prioritized list of languages
          if (!browserLocales.length) {
            browserLocales = [ mainBrowserLocale ];
          }
          return browserLocales;
        }(), index = 0;
        function extendLangWith(extendCode) {
          if (extendCode.indexOf("-") > 0 && langPrefix === getLanguageFromLocale(extendCode)) {
            if (!countriesWhiteList || countriesWhiteList.hasOwnProperty(extendCode)) {
              return extendCode;
            }
            if (langsWhiteList[langPrefix]) {
              return langPrefix;
            }
          }
        }
        for (;index < prioritizedBrowserLocales.length; index++) {
          langWithCountry = extendLangWith(prioritizedBrowserLocales[index]);
          if (langWithCountry) {
            return langWithCountry;
          }
        }
        return locale;
      }
      // Return the translated text for the key
      function translate(key) {
        var lang = getLang(), text = translations[key];
        if ("undefined" === typeof text) {
          if (true) {
            console.log('Unable to get translation for text code: "' + key + '" and language: "' + lang + '".');
          }
          return "-";
        }
        return text;
      }
      // Globally replace all instances of the pattern {{keyname}} with the translation using that key
      // Key names can container lower case letters, numbers and underscores
      function localizeStrings(text) {
        var MATCH_KEY = /\{\{([a-z0-9\_]+)\}\}/g;
        return text.replace(MATCH_KEY, function(match, capture) {
          return translate(capture);
        });
      }
      /**
   * Translate a number
   * @param number  Number to translate
   * @param numDigits (optional)
   */
      function translateNumber(number, numDigits) {
        var lang = getLang();
        //Number.toLocaleString locale parameter is unsupported in Safari
        var translated = number.toLocaleString(lang);
        return numDigits ? translated.slice(0, numDigits + 1) : translated;
      }
      // The language of user interface text:
      // In most cases, just returns 'en', 'de', etc.
      // However, when there are special files for a country translation, returns a longer name like 'en-us' for the U.S.
      // The language is based on the page, but the country is based on the browser (if the lang is the same)
      function getUiLocale() {
        var langOnly = getSupportedUiLang();
        return swapToPreferredRegion(langOnly, COUNTRY_EXCEPTIONS, SUPPORTED_UI_LANGS).toLowerCase();
      }
      // The preferred language of the current browser
      function getBrowserLocale() {
        return mainBrowserLocale;
      }
      function getMainBrowserLocale() {
        return navigator.language || navigator.userLanguage || navigator.browserLanguage || DEFAULT_LOCALE;
      }
      function init() {
        return new Promise(function(resolve, reject) {
          mainBrowserLocale = getMainBrowserLocale();
          // On load fetch the translations only once
          var lang = getSupportedUiLang(), langModuleName = LOCALE_DATA_PREFIX + lang;
          dataMap.get(langModuleName, function(data) {
            translations = data;
            if (translations) {
              resolve();
            } else {
              // TODO solve this mystery error (this info should help)
              reject(new Error("Translation not found for " + lang));
            }
          });
        });
      }
      return {
        getLang: getLang,
        getBrowserLang: getBrowserLocale,
        getPageLocale: getPageLocale,
        getUiLocale: getUiLocale,
        getTranslationLocale: getTranslationLocale,
        isValidLocale: isValidLocale,
        swapToPreferredRegion: swapToPreferredRegion,
        translate: translate,
        localizeStrings: localizeStrings,
        translateNumber: translateNumber,
        init: init
      };
    }(run_data_map, Promise);
    run_metric_metric = function() {
      function noop() {}
      noop.send = function() {};
      return {
        init: noop,
        initViewInfo: noop,
        getMetricHistory: noop,
        BadgeHover: noop,
        Error: noop,
        Feedback: noop,
        KeyCommand: noop,
        LensOpen: noop,
        MouseShake: noop,
        OptionMenuOpen: noop,
        OptionMenuItemSelection: noop,
        PageClickFirst: noop,
        PageScrollFirst: noop,
        PageUnload: noop,
        PanelClick: noop,
        PanelClose: noop,
        PanelFocusMove: noop,
        SitecuesReady: noop,
        SliderSettingChange: noop,
        TtsRequest: noop,
        ZoomChange: noop
      };
    }();
    run_platform = function() {
      // Store the agent and platform variables for later use
      var agent, isInitialized, isRetinaDisplay, exports = {
        browser: null,
        os: null,
        canUseRetinaCursors: null,
        cssPrefix: null,
        transitionEndEvent: null,
        nativeZoom: null,
        isRetina: isRetina,
        isUnsupportedPlatform: false,
        platformWarning: null,
        init: init
      };
      // Is the current display a retina display?
      // Determine which browser is being used
      function getBrowserStr(agent) {
        return agent.indexOf(" MSIE") > 0 || agent.indexOf(" Trident") > 0 || agent.indexOf(" Edge") > 0 ? "IE" : agent.indexOf(" Firefox/") > 0 ? "Firefox" : agent.indexOf(" Chrome") > 0 ? "Chrome" : agent.indexOf(" Safari") > 0 ? "Safari" : agent.indexOf(" Opera/") > 0 || agent.indexOf(" Presto/") > 0 ? "Opera" : "";
      }
      // If a vendor prefix is needed for a CSS property, what would it be?
      function getCssPrefix(currBrowser) {
        return currBrowser.isWebKit ? "-webkit-" : currBrowser.isFirefox ? "-moz-" : currBrowser.isMS ? "-ms-" : "";
      }
      // Set globally accessible browser constants
      function getBrowser(agent) {
        var version, browserStr = getBrowserStr(agent), isMS = "IE" === browserStr, browser = {
          zoom: "zoom" in document.createElement("div").style,
          is: browserStr,
          isFirefox: "Firefox" === browserStr,
          //Evaluates true for Internet Explorer and Edge (there is a lot of overlap in browser specific logic)
          isMS: isMS,
          // Includes Edge
          isIE: isMS && version < 12,
          // Does not include Edge
          isEdge: isMS && version >= 12,
          isChrome: "Chrome" === browserStr,
          isOpera: "Opera" === browserStr,
          isSafari: "Safari" === browserStr,
          isWebKit: "Chrome" === browserStr || "Opera" === browserStr || "Safari" === browserStr
        };
        browser.version = version = getVersion(agent, browser);
        browser.isIE = isMS && version < 12;
        browser.isEdge = isMS && version >= 12;
        return browser;
      }
      // Set globally accessible version constants
      function getVersion(agent, browser) {
        var charIndex = -1;
        // If IE is being used, determine which version
        if (browser.isChrome) {
          charIndex = agent.indexOf("Chrome/");
          if (charIndex > 0) {
            charIndex += 7;
          }
        } else {
          if (browser.isSafari) {
            charIndex = agent.indexOf("Version/");
            if (charIndex > 0) {
              charIndex += 8;
            }
          } else {
            if (browser.isMS) {
              // Use MSIE XX.X
              charIndex = agent.indexOf("MSIE");
              if (charIndex < 0) {
                charIndex = agent.indexOf("Edge");
              }
              if (charIndex > 0) {
                charIndex += 5;
              }
            }
          }
        }
        if (charIndex < 0) {
          charIndex = agent.indexOf("rv:");
          if (charIndex > 0) {
            charIndex += 3;
          }
        }
        return charIndex < 0 ? 0 : parseInt(agent.substring(charIndex));
      }
      // Determine which operating system is being used
      function getOSStr(agent) {
        return agent.indexOf("Mac OS X ") > -1 ? "mac" : agent.indexOf("Windows NT") > -1 ? "win" : agent.indexOf("Linux") > -1 ? "linux" : "other";
      }
      // Set globally accessible operating system constants
      function getOS(agent) {
        var osStr = getOSStr(agent);
        var os = {
          is: osStr,
          isMac: "mac" === osStr,
          isWin: "win" === osStr,
          // Set globally accessible version constants
          versionString: function() {
            // If IE is being used, determine which version
            var charIndex = agent.indexOf("win" === osStr ? "Windows NT" : "Mac OS X "), UNKNOWN_VERSION = "0";
            if (charIndex === -1) {
              return UNKNOWN_VERSION;
            }
            var versionMatches = agent.slice(charIndex).replace(/^\D*/, "").replace("_", ".").match(/[\d\.]+/);
            return versionMatches ? versionMatches[0] : UNKNOWN_VERSION;
          }()
        };
        // Windows versions are weird:
        // 5.1, 5.2 = Windows XP
        // 5 = Windows Vista, Windows Server 2008
        // 6.1 = Windows 7
        // 6.2 = Windows 8
        // 6.3 = Windows 8.1
        // 10 = Windows 10
        // For more details see https://en.wikipedia.org/?title=Windows_NT
        os.majorVersion = parseInt(os.versionString);
        os.fullVersion = parseFloat(os.versionString);
        // Restore if needed
        // os.minorVersion = parseInt(platformModule.os.versionString.split(/\D/)[1]);
        return os;
      }
      // Retrieve and store the user's intentional amount of native browser zoom
      function getNativeZoom() {
        var browser = exports.browser, computedNativeZoom = 1;
        if (browser.isWebKit) {
          computedNativeZoom = outerWidth / innerWidth;
        } else {
          if (browser.isMS) {
            // Note: on some systems the default zoom is > 100%. This happens on our Windows 7 + IE10 Dell Latitude laptop
            // See http://superuser.com/questions/593162/how-do-i-change-the-ctrl0-zoom-level-in-ie10
            // This means the actual zoom may be 125% but the user's intentional zoom is only 100%
            // To get the user's actual zoom use screen.deviceXDPI / screen.logicalXDPI
            computedNativeZoom = screen.deviceXDPI / screen.systemXDPI;
          } else {
            if (browser.isFirefox) {
              // Since isRetina() is not 100% accurate, neither will this be
              computedNativeZoom = isRetina() ? devicePixelRatio / 2 : devicePixelRatio;
            }
          }
        }
        return computedNativeZoom;
      }
      // Retrieve and store whether the current window is on a Retina display
      function isRetina() {
        var browser = exports.browser, nativeZoom = exports.nativeZoom;
        if ("undefined" !== typeof isRetinaDisplay) {
          return isRetinaDisplay;
        }
        isRetinaDisplay = false;
        // Safari doesn't alter devicePixelRatio for native zoom
        if (browser.isSafari) {
          isRetinaDisplay = 2 === devicePixelRatio;
        } else {
          if (browser.isChrome) {
            isRetinaDisplay = 2 === Math.round(devicePixelRatio / nativeZoom);
          } else {
            if (browser.isFirefox) {
              // This is only a guess, unfortunately
              // The following devicePixelRatios can be either on a retina or not:
              // 2, 2.4000000953674316, 3
              // Fortunately, these would correspond to a relatively high level of zoom on a non-Retina display,
              // so hopefully we're usually right (2x, 2.4x, 3x)
              // We can check the Firefox zoom metrics to see if they are drastically different from other browsers.
              isRetinaDisplay = devicePixelRatio >= 2;
            }
          }
        }
        return isRetinaDisplay;
      }
      // Returns a string if the current OS/browser combo is not supported.
      // The reason string is human-readable description as to why the platform is not supported
      // TODO localize
      function getPlatformWarning(os, browser) {
        if (!os.isWin && !os.isMac) {
          return "Microsoft Windows or Mac OS X is required";
        }
        var version = browser.version;
        if (browser.isIE) {
          return 11 !== version && "for Internet Explorer, version 11 is required";
        }
        if (browser.isEdge) {
          return version < 13 && "for Microsoft Edge, version 13 or later is required";
        }
        if (browser.isFirefox) {
          return version < 34 && "for Firefox, version 34 or later is required";
        }
        if (browser.isSafari) {
          return version < 9 && "for Safari, version 9 or later is required";
        }
        if (browser.isChrome) {
          return version < 41 && "for Chrome, version 41 or later is required";
        }
        return "IE, Firefox, Chrome or Safari is required";
      }
      function isStorageUnsupported() {
        var TEST_KEY = "-sc-storage-test";
        if (0 === localStorage.length && 0 === sessionStorage.length) {
          try {
            sessionStorage.setItem(TEST_KEY, "");
            sessionStorage.removeItem(TEST_KEY);
          } catch (ex) {
            return true;
          }
        }
      }
      // return truthy if platform is supported
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        agent = navigator.userAgent || "";
        exports.browser = getBrowser(agent);
        exports.os = getOS(agent);
        exports.nativeZoom = getNativeZoom();
        var platformWarning = getPlatformWarning(exports.os, exports.browser);
        if (platformWarning) {
          throw new Error(platformWarning);
        }
        exports.isStorageUnsupported = isStorageUnsupported();
        exports.canUseRetinaCursors = exports.browser.isChrome;
        exports.cssPrefix = getCssPrefix(exports.browser);
        exports.transitionEndEvent = exports.browser.isWebKit ? "webkitTransitionEnd" : "transitionend";
        exports.featureSupport = {
          themes: !exports.browser.isMS
        };
        // Invalidate cached retina info on window resize, as it may have moved to another display.
        // When a window moves to another display, it can change whether we're on a retina display.
        // Kinda evil that we have a listener in this module, but it helps keep things efficient as we need this info cached.
        addEventListener("resize", function() {
          isRetinaDisplay = void 0;
        });
      }
      return exports;
    }();
    run_bp_constants = function() {
      var constants = {};
      // TODO don't repeat this in styles.js
      constants.IS_BADGE = "scp-is-badge";
      // BP is already badge and not animating
      constants.IS_PANEL = "scp-is-panel";
      // BP is already panel and not animating (used to be called scp-ready)
      constants.WANT_BADGE = "scp-want-badge";
      // BP is already badge or shrinking into one
      constants.WANT_PANEL = "scp-want-panel";
      // BP is already panel or expanding into one
      // IDs
      constants.SMALL_A_ID = "scp-small-A";
      constants.LARGE_A_ID = "scp-large-A";
      constants.SPEECH_ID = "scp-speech";
      constants.MAIN_ID = "scp-main";
      constants.MAIN_CONTENT_FILL_ID = "scp-main-content-fill";
      constants.MOUSEOVER_TARGET = "scp-mouseover-target";
      // Mousing over this element causes BP to expand
      constants.SVG_ID = "scp-svg";
      constants.BADGE_ID = "sitecues-badge";
      constants.BP_CONTAINER_ID = "scp-bp-container";
      // Speech
      constants.HEAD_ID = "scp-head";
      constants.SPEECH_LABEL_ID = "scp-speech-label";
      constants.ZOOM_LABEL_ID = "scp-zoom-label";
      constants.SPEECH_TARGET_ID = "scp-speech-target";
      constants.WAVE_1_ID = "scp-wave1";
      constants.WAVE_2_ID = "scp-wave2";
      constants.WAVE_3_ID = "scp-wave3";
      constants.VERT_DIVIDER_ID = "scp-vert-divider";
      constants.BOTTOM_TEXT_ID = "scp-bottom-text";
      constants.BOTTOM_MOUSETARGET_ID = "scp-bottom-mousetarget";
      constants.BOTTOM_MORE_ID = "scp-bottom-secondary";
      constants.CLOSE_BUTTON_ID = "scp-close-button";
      constants.ZOOM_VALUE_ID = "scp-zoom-value";
      constants.ZOOM_SLIDER_ID = "scp-zoom-slider-target";
      constants.ZOOM_SLIDER_BAR_ID = "scp-zoom-slider-bar";
      constants.ZOOM_SLIDER_THUMB_ID = "scp-zoom-slider-thumb";
      constants.SHOW_ID = "scp-show";
      constants.SECONDARY_ID = "scp-secondary";
      constants.MORE_BUTTON_GROUP_ID = "scp-more-button-group";
      constants.MORE_BUTTON_CONTAINER_ID = "scp-more-button-container";
      constants.SHADOW_ID = "scp-shadow";
      constants.OUTLINE_ID = "scp-focus-outline";
      constants.MAIN_OUTLINE_ID = "scp-main-outline";
      constants.MAIN_OUTLINE_BORDER_ID = "scp-outline-def";
      constants.MORE_OUTLINE_ID = "scp-secondary-outline";
      constants.BUTTON_MENU_ID = "scp-button-menu";
      constants.TIPS_BUTTON_ID = "scp-tips-button";
      constants.SETTINGS_BUTTON_ID = "scp-settings-button";
      constants.FEEDBACK_BUTTON_ID = "scp-feedback-button";
      constants.ABOUT_BUTTON_ID = "scp-about-button";
      constants.ABOUT_ROTATE_HELPER_ID = "scp-about-rotate-helper";
      constants.TIPS_LABEL_ID = "scp-tips-label";
      constants.SETTINGS_LABEL_ID = "scp-settings-label";
      constants.FEEDBACK_LABEL_ID = "scp-feedback-label";
      constants.ABOUT_LABEL_ID = "scp-about-label";
      constants.ABOUT_CONTENT_ID = "scp-about";
      constants.ABOUT_CONTENT_IMAGE_ID = "scp-logo-text";
      constants.FEEDBACK_CONTENT_ID = "scp-feedback";
      constants.FEEDBACK_INPUT_RECT = "scp-feedback-input-rect";
      constants.FEEDBACK_TEXTAREA = "scp-feedback-textarea";
      constants.FEEDBACK_SEND_BUTTON = "scp-feedback-send-button";
      // Looks like a button
      constants.FEEDBACK_SEND_LINK = "scp-feedback-send-link";
      // Actual active link child with click handler
      constants.RATING = "scp-rating";
      constants.RATING_STAR_CLASS = "scp-rating-star";
      constants.SETTINGS_CONTENT_ID = "scp-settings";
      constants.TIPS_CONTENT_ID = "scp-tips";
      constants.ARROWS_ID = "scp-arrows";
      constants.NEXT_ID = "scp-next-card";
      constants.PREV_ID = "scp-prev-card";
      constants.DEFAULT_BADGE_CLASS = "scp-default-badge";
      // Tips panel gadgets
      constants.DEMO_PAGE = "scp-demo-page";
      constants.DEMO_PAGE_CONTENTS = "scp-demo-page-contents";
      constants.DEMO_PARA = "scp-demo-para";
      constants.DEMO_MOUSE = "scp-demo-mouse";
      constants.DEMO_SLIDER_THUMB = "scp-demo-slider-thumb";
      constants.DEMO_ZOOM_PLUS = "scp-demo-zoom-plus";
      constants.DEMO_ZOOM_MINUS = "scp-demo-zoom-minus";
      constants.DEMO_LENS_SPACE = "scp-demo-lens-spacebar";
      constants.DEMO_SPEECH_SPACE = "scp-demo-speech-spacebar";
      // Settings panel gadgets
      constants.THEME_POWER_ID = "scp-theme-power-group";
      constants.THEME_TEXT_HUE_ID = "scp-theme-text-hue-group";
      constants.MOUSE_SIZE_ID = "scp-mouse-size";
      constants.HOVER_DELAY_NOMOVE_BADGE = 30;
      // If mouse stays still inside badge for this long, open
      constants.HOVER_DELAY_STAY_INSIDE_BADGE = 150;
      // If mouse stays inside badge or toolbar for this long, open
      constants.HOVER_DELAY_STAY_INSIDE_FIRST_TIME = 40;
      // First time users get more sensitive badge
      constants.MOUSELEAVE_DELAY_SHRINK_BP = 2e3;
      constants.TRANSFORMS = {
        PANEL: {},
        BADGE: {},
        ABOUT_ENABLED: {},
        SETTINGS_ENABLED: {},
        FEEDBACK_ENABLED: {},
        TIPS_ENABLED: {}
      };
      constants.TRANSFORMS.PANEL[constants.VERT_DIVIDER_ID] = {
        translateX: 44
      };
      constants.TRANSFORMS.BADGE[constants.VERT_DIVIDER_ID] = {
        translateX: -98
      };
      constants.TRANSFORMS.PANEL[constants.SMALL_A_ID] = {
        translateX: 27
      };
      constants.TRANSFORMS.BADGE[constants.SMALL_A_ID] = {
        translateX: 0
      };
      constants.TRANSFORMS.PANEL[constants.LARGE_A_ID] = {
        translateX: 27
      };
      constants.TRANSFORMS.BADGE[constants.LARGE_A_ID] = {
        translateX: -115
      };
      constants.TRANSFORMS.PANEL[constants.SPEECH_ID] = {
        translateX: 54
      };
      constants.TRANSFORMS.BADGE[constants.SPEECH_ID] = {
        translateX: -100
      };
      constants.TRANSFORMS.PANEL[constants.ZOOM_SLIDER_THUMB_ID] = {
        translateX: 44
      };
      constants.TRANSFORMS.BADGE[constants.ZOOM_SLIDER_THUMB_ID] = {
        translateX: 8
      };
      constants.TRANSFORMS.FAKE_BADGE_TRANSLATEX = 116;
      constants.TRANSFORMS.PANEL[constants.ZOOM_SLIDER_BAR_ID] = {
        translateX: 27,
        scaleX: 1,
        scaleY: 1
      };
      constants.TRANSFORMS.BADGE[constants.ZOOM_SLIDER_BAR_ID] = {
        translateX: 19,
        scaleX: .65,
        scaleY: 1
      };
      constants.TRANSFORMS[constants.SECONDARY_ID] = {
        translateY: -198
      };
      constants.TRANSFORMS[constants.MORE_BUTTON_CONTAINER_ID] = {};
      constants.TRANSFORMS[constants.TIPS_BUTTON_ID] = {
        translateX: 25
      };
      constants.TRANSFORMS[constants.SETTINGS_BUTTON_ID] = {
        translateX: 235
      };
      constants.TRANSFORMS[constants.FEEDBACK_BUTTON_ID] = {
        translateX: 465
      };
      constants.TRANSFORMS[constants.ABOUT_BUTTON_ID] = {
        translateX: 675
      };
      // Elements that are only shown when panel is expanded
      // Attributes
      constants.PANEL_CONTAINER_ATTRS = {
        id: constants.BP_CONTAINER_ID,
        // First role "application" tells screen reader to go into focus (not browse) mode
        // Second role "dialog" gives more detail
        role: "dialog",
        tabindex: -1,
        class: "scp-loading",
        "aria-label": "Sitecues"
      };
      constants.BADGE_ATTRS = {
        role: "button",
        tabindex: 0,
        "aria-busy": "false",
        "data-sc-reversible": "false"
      };
      constants.DEFAULT_TOOLBAR_ATTRS = {
        id: constants.BADGE_ID,
        class: "scp-toolbar"
      };
      // Labels
      constants.ZOOM_STATE_LABELS = {
        ZOOM_OFF: "zoom_off",
        PRE_ZOOM: "pre_zoom",
        POST_ZOOM: "post_zoom"
      };
      constants.SPEECH_STATE_LABELS = {
        ON: "on",
        OFF: "off"
      };
      constants.STRINGS = {
        BADGE_LABEL: "badge_label"
      };
      // Zoom
      constants.ZOOM_KEY_INCREMENT = .1;
      // When arrow key pressed zoom is changed by this amount
      constants.FAKE_ZOOM_AMOUNT = 2.2;
      // If sitecues was never used, badge pretends zoom is here, to enhance attractiveness
      // Other
      constants.EXPAND_ANIMATION_DURATION_MS = 1500;
      // Time it takes to expand from badge to panel -- no hovers during this time
      constants.SHRINK_ANIMATION_DURATION_MS = 750;
      // Time it takes to shrink panel to badge -- no hovers during this time
      constants.NO_INPUT_TIMEOUT = 7e3;
      // Show more button if no activity for this amount of time
      // TODO is this still needed? It's fixed in Firefox
      constants.FIREFOX_SLIDER_OFFSET = 69;
      // Hardcoded because of https://bugzilla.mozilla.org/show_bug.cgi?id=479058
      // TODO compute this ratio
      // It's used to set the slider thumb properly
      constants.LARGE_SLIDER_WIDTH = 256;
      constants.SMALL_SLIDER_WIDTH = 160;
      // Ideal panel size for correct formatting of all contents.
      // We may need to use a larger size if the badge was already large
      // In that case we will make up the extra size using transform scale, so as not to disturb the HTML formatting
      constants.IDEAL_PANEL_WIDTH = 506;
      constants.IDEAL_PANEL_HEIGHT = 148;
      // Amount toolbar space that will open badge
      constants.ACTIVE_TOOLBAR_WIDTH = 500;
      // Amount of pixels of whitespace at the top of the badge
      // (This whitespace exists for a reason -- it turns into the top border when the panel opens)
      constants.BADGE_VERTICAL_OFFSET = 2;
      // Common palettes
      constants.PALETTE_NAME_ADAPTIVE = "adaptive";
      constants.PALETTE_NAME_NORMAL = "normal";
      constants.PALETTE_NAME_REVERSE_BLUE = "reverse-blue";
      // Map legal full palette names to short names, used to create a class e.g. .scp-palette-rb
      constants.PALETTE_NAME_MAP = {
        normal: "-n",
        adaptive: "*",
        "reverse-blue": "-rb",
        "reverse-yellow": "-ry"
      };
      // Wave animation (on hover over TTS button)
      constants.ANIMATE_WAVES_OPACITY = [ [ .2, .4, .6, .8, .8, .6, .4, .2, .2, .2, .2, .4, .6, .8, .8, .6, .4, .2, .2, .2 ], // Wave 1
      [ .2, .2, .4, .6, .8, .8, .6, .4, .2, .2, .2, .2, .4, .6, .8, .8, .6, .4, .2, .4 ], // Wave 2
      [ .2, .2, .2, .4, .6, .8, .8, .6, .4, .2, .2, .2, .2, .4, .6, .8, .8, .6, .4, .6 ] ];
      constants.ANIMATE_WAVES_STEP_DURATION = 100;
      constants.BADGE_MODE = 0;
      constants.PANEL_MODE = 1;
      constants.SECONDARY_PANEL_DISABLED = 0;
      constants.SECONDARY_PANEL_ENABLED = 1;
      return constants;
    }();
    run_bp_model_state = function() {
      var data = {
        currentMode: 0,
        // 0 - 1, 0 is badge, 1 is panel, anything in between means its currently transitioning
        transitionTo: 0,
        // 0 or 1, 0 is badge, 1 is panel, it cannot be anything in between (doesn't seem to make sense to transition to anything other than the badge or panel state)
        isSecondaryPanel: false,
        // Are we currently in the secondary panel
        secondaryPanelTransitionTo: 0,
        scale: 1,
        // How much transform scale used on expanded BP
        isRealSettings: true,
        // Are we currently showing the actual settings or fake settings?
        isFirstBadgeUse: true,
        // Is this a first time user?
        secondaryPanelName: "button-menu",
        // 'button-menu', 'tips', 'settings', 'feedback', 'about'
        isSecondaryExpanding: false,
        // Is secondary panel currently expanding to accommodate new contents?
        isSecondaryExpanded: false,
        // Is secondary panel fully expanded?
        isStickyPanel: false,
        // Sticky panel is for debugging -- mouseout doesn't close the panel
        isClassicMode: false,
        // Use question mark if browser support is weak or site is incompatible with themes
        doSuppressHovers: false,
        // Suppress mouse hovers until next mousemove, because browser won't recompute them until then (useful for animations)
        isKeyboardMode: false,
        // Show focus in this mode, support tab navigation
        isOpenedWithScreenReader: false,
        // If opened with screen reader, be careful of spurious click events outside panel
        isMoreButtonVisible: false,
        // Should the more button be shown?
        isPageBadge: true,
        // Is set to false if default badge is inserted
        isToolbarBadge: false,
        // Set to true if using a badge toolbar. This may eventually become redundant with isPageBadge (the opposite of it) if we only use toolbar default badges.
        wasMouseInPanel: false,
        // Was the mouse inside the panel since last expansion
        paletteKey: "",
        // Current palette See BP_CONST.PALETTE_NAME_MAP for possible keys.
        defaultPaletteKey: "",
        // Palette to use if sitecues theme determines that default palette should be used based on the background behind the badge.
        isAdaptivePalette: false,
        // Is an adaptive palette name
        isShrinkingFromKeyboard: false,
        // Is the panel shrinking because of a keyboard command?
        isFeedbackSent: false,
        // Is the feedback sent?
        ratioOfSVGToVisibleBadgeSize: void 0
      };
      /*
  Public accessors.
   */
      /**
   * Get state model value specified by the property name given.
   * @param propName String
   * @returns {*}
   */
      function get(propName) {
        if (data.hasOwnProperty(propName)) {
          return data[propName];
        }
        if (true) {
          console.log("ERROR: Cannot get property with name " + propName + ".");
        }
      }
      /**
   * Set state model value specified by the property name given
   * @param propName String
   * @param propValue String or Number
   */
      function set(propName, propValue) {
        if (data.hasOwnProperty(propName)) {
          data[propName] = propValue;
        } else {
          if (true) {
            console.log("ERROR: Cannot set property with name " + propName + ".");
          }
        }
      }
      /*
  Some of the most popular getters are listed below.
   */
      function isPanel() {
        return 1 === data.currentMode;
      }
      function isBadge() {
        return 0 === data.currentMode;
      }
      function isPanelRequested() {
        return 1 === data.transitionTo;
      }
      function isExpanding() {
        return 1 === data.transitionTo && 1 !== data.currentMode;
      }
      function isSecondaryPanelRequested() {
        return 1 === data.secondaryPanelTransitionTo;
      }
      function isSecondaryFeaturePanel() {
        var panelName = getSecondaryPanelName();
        return panelName && "button-menu" !== panelName;
      }
      function isShrinking() {
        return 0 === data.transitionTo && 0 !== data.currentMode;
      }
      /**
   * Returns 'button-menu' or name of secondary panel
   * @returns {string}
   */
      function getSecondaryPanelName() {
        return data.secondaryPanelName;
      }
      function getPanelName() {
        if (isPanel() && isSecondaryPanelRequested()) {
          return data.secondaryPanelName;
        }
        return "main";
      }
      function isButtonMenu() {
        return isPanel() && "button-menu" === data.secondaryPanelName;
      }
      function turnOnRealSettings() {
        set("isRealSettings", true);
      }
      return {
        get: get,
        set: set,
        isPanel: isPanel,
        isBadge: isBadge,
        isPanelRequested: isPanelRequested,
        isExpanding: isExpanding,
        isSecondaryPanelRequested: isSecondaryPanelRequested,
        isSecondaryFeaturePanel: isSecondaryFeaturePanel,
        isShrinking: isShrinking,
        getSecondaryPanelName: getSecondaryPanelName,
        isButtonMenu: isButtonMenu,
        turnOnRealSettings: turnOnRealSettings,
        getPanelName: getPanelName
      };
    }();
    run_bp_helper = function(BP_CONST) {
      /**
   *** Getters ***
   */
      var elementByIdCache = {};
      function byId(id) {
        var result = elementByIdCache[id];
        if (!result) {
          result = document.getElementById(id);
          elementByIdCache[id] = result;
        }
        return result;
      }
      function invalidateId(id) {
        elementByIdCache[id] = void 0;
      }
      /**
   * getRect returns the bounding client rect for the given element.
   * It copies the values because this gets around Safari issue with where values otherwise appear undefined.
   * @param element
   * @returns {Object} rectangle
   */
      function getRect(element) {
        var rect = element.getBoundingClientRect();
        return {
          top: rect.top,
          bottom: rect.bottom,
          left: rect.left,
          right: rect.right,
          width: rect.width,
          height: rect.height
        };
      }
      /**
   * getRectById returns the bounding client rect for the given ID.
   * It copies the values because this gets around Safari issue with where values otherwise appear undefined.
   * @param id
   * @returns {Object} rectangle
   */
      function getRectById(id) {
        return getRect(byId(id));
      }
      /**
   *** Setters ***
   */
      // Leave this method here rather than take it out to 'util / common' to avoid extra modules deps.
      // In the end, we only want to load badge on the page w/o any other modules.
      // Important note: do not use this function to set inline styles on original (non-Sitecues) elements
      function setAttributes(element, attrs) {
        for (var attrName in attrs) {
          if (attrs.hasOwnProperty(attrName)) {
            element.setAttribute(attrName, attrs[attrName]);
          }
        }
      }
      function getCurrentSVGElementTransforms() {
        var result = {};
        function mapTranslate(id) {
          var transformAttrValue = byId(id).getAttribute("transform") || "";
          result[id] = {
            translateX: getNumberFromString(transformAttrValue) || 0
          };
        }
        // Everything except slider
        mapTranslate(BP_CONST.SMALL_A_ID);
        mapTranslate(BP_CONST.LARGE_A_ID);
        mapTranslate(BP_CONST.SPEECH_ID);
        mapTranslate(BP_CONST.VERT_DIVIDER_ID);
        mapTranslate(BP_CONST.ZOOM_SLIDER_THUMB_ID);
        // Slider bar is special because it stretches
        var sliderBar = byId(BP_CONST.ZOOM_SLIDER_BAR_ID), // translate(19) scale(.65, 1) -> ['translate(19)' , '(.65, 1)']
        sliderBarTransforms = sliderBar.getAttribute("transform").split("scale"), splitter = sliderBarTransforms[1].indexOf(",") >= 0 ? "," : " ", // IE fix
        sliderBarScale = sliderBarTransforms[1].split(splitter), sliderBarScaleX = sliderBarScale[0], sliderBarScaleY = sliderBarScale.length > 1 ? sliderBarScale[1] : sliderBarScaleX;
        result[BP_CONST.ZOOM_SLIDER_BAR_ID] = {
          translateX: getNumberFromString(sliderBarTransforms[0]),
          scaleX: getNumberFromString(sliderBarScaleX),
          scaleY: getNumberFromString(sliderBarScaleY)
        };
        return result;
      }
      function getNumberFromString(str) {
        return +str.match(/[0-9\.\-]+/);
      }
      // Fix for events in SVG in IE:
      // IE sometimes gives us the <defs> element for the event, and we need the <use> element
      function getEventTarget(evt) {
        return evt.target.correspondingUseElement || evt.target;
      }
      function cancelEvent(evt) {
        evt.returnValue = false;
        evt.preventDefault();
        evt.stopImmediatePropagation();
        evt.stopPropagation();
        return false;
      }
      //Edge can't handle text anchors during transformations, so we manually fix the x position of text within SVGs
      // A text anchor in SVG allows text to be centered, right-justified, etc.
      //TODO: Remove this when Edge fixes its support for text anchors, see SC-3434
      function fixTextAnchors(svg) {
        var elementsWithAnchors = svg.parentElement.querySelectorAll("[text-anchor]");
        Array.prototype.forEach.call(elementsWithAnchors, function(element) {
          var anchor = element.getAttribute("text-anchor"), x = parseFloat(element.getAttribute("x")), textWidthInPixels = element.getComputedTextLength();
          function setX(val) {
            var DECIMAL_PLACES = 2;
            element.setAttribute("x", val.toFixed(DECIMAL_PLACES));
          }
          if ("middle" === anchor) {
            setX(x - textWidthInPixels / 2);
          } else {
            if ("end" === anchor) {
              setX(x - textWidthInPixels);
            }
          }
          element.removeAttribute("text-anchor");
        });
      }
      // This will roughly help us group similar types of element clicks
      function getAriaOrNativeRole(elem) {
        var tag, role = elem.getAttribute("role");
        if (!role) {
          // No role: use tag name
          tag = elem.localName;
          if ("input" === tag) {
            // Tag name is input, use @type
            role = elem.getAttribute("type");
          } else {
            if ("g" === tag || "div" === tag) {
              // Tag name is g|div, use 'group'
              role = "group";
            }
          }
        }
        return role;
      }
      return {
        byId: byId,
        invalidateId: invalidateId,
        getRect: getRect,
        getRectById: getRectById,
        setAttributes: setAttributes,
        getCurrentSVGElementTransforms: getCurrentSVGElementTransforms,
        getNumberFromString: getNumberFromString,
        getEventTarget: getEventTarget,
        cancelEvent: cancelEvent,
        fixTextAnchors: fixTextAnchors,
        getAriaOrNativeRole: getAriaOrNativeRole
      };
    }(run_bp_constants);
    run_ab_test_ab_test = function() {
      function noop() {}
      return {
        init: noop,
        get: noop
      };
    }();
    run_bp_view_markup_finalizer = function(locale) {
      function removeHash(loc) {
        return loc.replace(/\#.*/, "");
      }
      // Relative URLs must be full URLS that a different base doesn't mess them up!
      // Without this fix, markup such as xlink:href="#foo" or filter="url(#foo)" will not work in Firefox
      // or recent Chrome, when the source document uses a base.
      // Even if the base points to the default base, we still need to convert hashes, otherwise a page
      // such as http://wokiss.pl/szkolenia.html will have an invisible badge in some browsers.
      // Note: the base can be set via <base> tag or http header.
      function convertRelativeUrlsToAbsolute(text) {
        var MATCH_URLS = /(href="|url\()(?:#)/g, pageUrlMinusHash = removeHash(document.location.href);
        return text.replace(MATCH_URLS, function(totalMatch, attributeName) {
          return attributeName + pageUrlMinusHash + "#";
        });
      }
      return function(markup) {
        var withAllAbsoluteUrls = convertRelativeUrlsToAbsolute(markup), localized = locale.localizeStrings(withAllAbsoluteUrls);
        return localized;
      };
    }(run_locale);
    run_bp_view_styles = function(helper, platform, site) {
      var isInitialized, palette, hasCustomPalette, customBadgePalette, doWebKitPrefix, BASE_CSS, isAnimationDebuggingOn = false, MAX_ZINDEX = 2147483647, BASE_SHEET_ID = "sitecues-js-bp-css", HIDE_IN_PRINT_MEDIA = // Turn off toolbar, dimmer, lens and zoom
      // TODO needs more work to reset body width if page sets it to something different
      "@media print { .scp-toolbar, #scp-bp-container, #sitecues-background-dimmer, #sitecues-hlb-wrapper { display: none !important; } body { transform: none !important; width: auto !important; } }";
      function toCSS(jsonObject) {
        var styles = HIDE_IN_PRINT_MEDIA;
        var isTransformPrefixNeeded = void 0 === document.createElement("p").style.transform;
        for (var selector in jsonObject) {
          if (jsonObject.hasOwnProperty(selector)) {
            styles += selector + " {\n";
            for (var attribute in jsonObject[selector]) {
              if (jsonObject[selector].hasOwnProperty(attribute)) {
                var value = jsonObject[selector][attribute];
                if (isTransformPrefixNeeded) {
                  if ("transform" === attribute || "transition" === attribute || "transform-origin" === attribute) {
                    // TEMPORARY DEBUGGING CODE
                    if (true && isAnimationDebuggingOn && "transition" === attribute) {
                      value = value.replace(".", "");
                    }
                    if (doWebKitPrefix) {
                      attribute = "-webkit-" + attribute;
                      value = value.replace("transform", "-webkit-transform");
                    }
                  }
                }
                styles += "  " + attribute + ": " + value + ";\n";
              }
            }
            styles += "}\n";
          }
        }
        return styles;
      }
      function initBaseCss() {
        BASE_CSS = {
          /**
             General CSS rules for panel
      
             Basic structure of panel:
             <sc #scp-bp-container>
             <sc #scp-close-button>
             <sc .scp-feature-content>
             <svg #scp-svg>
             <defs>
             <g #scp-main>
             #scp-zoom-slider
             #scp-speech›
             ...
             <g #scp-secondary>     // Secondary panel that slides down
             <g .scp-feature-content>
             <g .scp-tips> etc.
             <sc-cards>
             <sc-card>
             <sc-card>
             ...
      
             Classes important for CSS:
             - On #scp-bp-container
             .scp-is-badge: BP is badge
             .scp-is-panel: BP is panel
             .scp-want-badge: BP is badge or shrinking into one
             .scp-want-panel: BP is panel or expanding into one
             .scp-is-panel-only  // Only display in panel mode or when becoming panel
             .scp-keyboard: Keyboard mode
             - Elsewhere:
             .scp-secondary-only   // Only display in more panel
             .scp-feature-content // Only display in feature panel (reachable for more panel)
             .scp-hand-cursor: show a hand (aka pointer) cursor over this element
             .scp-hidden-target: a click target that is hidden (e.g. a rect that covers more area than the visible part of the target)
      
      
             ARIA roles:
             - dialog, button, checkbox (speech button), slider, link, presentation (means don't expose to screen reader)
             ARIA modes:
             - Used for CSS: aria-checked, aria-disabled
             - Not used for CSS: aria-activedescendant (focused item ID), aria-valuenow, aria-valuemin, aria-valuemax, aria-label, aria-labelledby
             */
          "#scp-bp-container,#scp-bp-container textarea": {
            // We used to do #scp-bp-container *, but this could be dangerously slow
            "box-sizing": "content-box !important"
          },
          /***************** Loading/badge  ****************/
          // If there is an old badge image, do not show it -- we will show new BP-based badge in place of it
          "img#sitecues-badge, #sitecues-badge>img": {
            visibility: "hidden !important",
            opacity: "0 !important"
          },
          // When panel is closed, we use position: absolute
          // When open, we use position: fixed
          "#sitecues-badge>#scp-bp-container": {
            position: "absolute"
          },
          // Fade in the badge when it appears
          "#scp-bp-container": {
            position: "fixed",
            direction: "ltr !important",
            "z-index": MAX_ZINDEX,
            transition: "opacity 1.5s",
            "transform-origin": "0 0",
            "text-align": "left",
            // To prevent style pollution found on http://codecanyon.net/
            //          'will-change': 'transform',   // Removing helps Chrome not get blurry on sitecues.com after zoom
            outline: 0,
            // don't show default dotted focus outline
            "-webkit-user-select": "none",
            "-moz-user-select": "none",
            "-ms-user-select": "none"
          },
          "#scp-svg": {
            direction: "ltr !important",
            "max-width": "none",
            overflow: "hidden",
            position: "absolute"
          },
          // The new badge is hidden until sitecues is loaded
          // The old badge is visible until sitecues is loaded
          '#scp-bp-container.scp-loading,#sitecues-badge[aria-busy="false"]>img': {
            opacity: "0 !important",
            // We force the <img> placeholder to have a display of block so the wrapper height
            // is the same as the <img> height.  vertical-align:top was tried, tested, but
            // it did not work on faast.org.  Below is a link to information about the problem
            // and solutions.
            // http://stackoverflow.com/questions/11447707/div-container-larger-than-image-inside
            display: "block"
          },
          "#scp-bp-container:not(.scp-loading)": {
            opacity: "1 !important"
          },
          // .scp-toolbar means it's a toolbar
          ".scp-toolbar": {
            position: "fixed !important",
            top: 0,
            left: 0,
            width: "100%",
            height: "38px !important",
            margin: "0 !important",
            // Prevent page style pollution
            "box-sizing": "border-box",
            "box-shadow": "1px 1px 15px 0 rgba(9, 9, 9, .5)",
            padding: "6px 0 8px calc(50% - 66px)",
            "background-color": customBadgePalette.toolbar || "#f7fcff",
            // Ensure our own theme engine doesn't turn the toolbar dark
            "z-index": MAX_ZINDEX,
            direction: "ltr !important"
          },
          ".scp-toolbar > #scp-bp-container": {
            "background-color": "transparent !important",
            margin: "0 !important"
          },
          /* Subtle, but helps the badge appear vertically centered */
          ".scp-toolbar > #scp-bp-container > #scp-svg": {
            position: "absolute",
            top: "-1px"
          },
          // Move the body down by the height of the toolbar
          "html[data-sitecues-toolbar]": {
            "padding-top": "38px !important"
          },
          /********** Transform animation speed **********/
          // TODO: Transitions are pretty efficient for opacity, but it may be worth trading
          //       that for simplicity (using JS animations for EVERYTHING).
          "#scp-main > *, .scp-wave": {
            transition: "fill .2s, opacity .2s"
          },
          "#scp-bottom-text": {
            transition: "opacity 1s",
            visibility: "hidden"
          },
          ".scp-is-panel text": {
            "font-family": "Arial",
            "font-size": "29px",
            "font-weight": "bold"
          },
          /* Text label animation for main panel labels */
          /* The problem with the text scale transition is jerkiness, so for now we delay text labels until panel is large */
          /* One way to fix this might be to render text into a canvas element, or maybe there's another font that doesn't do this */
          ".scp-is-panel #scp-bottom-text": {
            visibility: "visible !important",
            opacity: "1 !important"
          },
          /************** Shadow *********************/
          "#scp-shadow": {
            position: "absolute",
            top: "-437px",
            width: "513px",
            height: "564px",
            "background-image": "url(data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20820%20902%22%20preserveAspectRatio%3D%22xMinYMin%22%3E%3Cdefs%3E%3Cfilter%20id%3D%22shadowblur%22%3E%20%3CfeGaussianBlur%20in%3D%22SourceGraphic%22%20stdDeviation%3D%225%22%2F%3E%3C%2Ffilter%3E%3C%2Fdefs%3E%3Cpath%20filter%3D%22url%28%23shadowblur%29%22%20d%3D%22m808%2C888c0%2C6%20-5%2C11%20-11%2C11H11m797%2C-11v-888%22%20stroke%3D%22%23222%22%20stroke-width%3D%222%22%20fill%3D%22none%22%2F%3E%3C%2Fsvg%3E)"
          },
          "#scp-shadow-container": {
            display: "none",
            opacity: 0,
            "pointer-events": "none"
          },
          ".scp-want-panel #scp-shadow-container": {
            transition: "opacity 1s",
            display: "block"
          },
          ".scp-is-panel #scp-shadow-container": {
            opacity: 1
          },
          /************ Small vs. large  *************/
          ".scp-want-panel > #scp-svg": {
            opacity: "1 !important"
          },
          ".scp-want-panel:not(.scp-is-panel) .scp-hand-cursor": {
            "pointer-events": "none"
          },
          ".scp-want-panel .scp-panel-only": {
            // element is visible in the large state of the badge-panel
            opacity: "1 !important"
          },
          ".scp-want-panel #scp-mouseover-target": {
            display: "none"
          },
          /**************** Waves ************************/
          ".scp-wave,.scp-head": {
            "pointer-events": "none"
          },
          /* Waves use gray off state if not hovering and showing real settings (not first time badge) */
          '.scp-realsettings #scp-speech[aria-checked="false"]:not(.scp-dim-waves) > .scp-wave': {
            /* First time we're small we always show on state because it's more inviting. However, going from small to large the first time, we're going from fake on to real off. Transition gently, don't draw attention to that. */
            fill: "#aaa"
          },
          ".scp-dim-waves> #scp-wave1": {
            opacity: ".3"
          },
          ".scp-dim-waves > #scp-wave2": {
            opacity: ".38"
          },
          ".scp-dim-waves > #scp-wave3": {
            opacity: ".44"
          },
          /******************* More **********************/
          ".scp-classic-true #scp-more-arrow": {
            display: "none"
          },
          ".scp-classic-false #scp-question": {
            display: "none"
          },
          "#scp-more-button-opacity": {
            opacity: 0,
            "pointer-events": "all"
          },
          ".scp-transition-opacity-fast": {
            transition: "opacity 0.4s",
            opacity: 1
          },
          "#scp-secondary, .scp-secondary-feature": {
            display: "none"
          },
          /******** Mouse targets must be hidden but still able to handle events *************/
          ".scp-hidden-target": {
            opacity: 0
          },
          /*************** Focus **************************/
          /* Do not use outline because it ends up being larger than the visible content, at least in Firefox */
          "#sitecues-badge:focus,#scp-bp-container:focus,#scp-bp-container *:focus": {
            outline: "0 !important"
          },
          '#sitecues-badge[aria-expanded="false"]:focus > .scp-is-badge #scp-badge-focus-rect': {
            stroke: "rgba(82, 168, 236, 0.8)",
            "stroke-width": "24px"
          },
          "#scp-focus-outline": {
            "box-shadow": "0 0 4px 6px rgba(82,168,236,0.8)",
            "border-radius": "4px",
            display: "none",
            position: "absolute",
            "pointer-events": "none",
            "z-index": 99999
          },
          /*** Firefox focus rules, since getBoundingClientRect() is broken for SVG */
          // Firefox focus for SVG
          '.scp-is-panel [data-show-focus="stroke-child"]:not([data-own-focus-ring]) rect,.scp-is-panel [data-show-focus="stroke-child"]:not([data-own-focus-ring])>.scp-hidden-target': {
            stroke: "rgba(82,168,236,.8)",
            "stroke-width": "8px",
            opacity: 1,
            display: "block",
            fill: "transparent",
            "z-index": -1,
            filter: "url(#scp-focusblur)"
          },
          // Firefox focus for HTML
          '.scp-is-panel [data-show-focus="box-shadow"]:not([data-own-focus-ring])': {
            "box-shadow": "0 0 10px 3px rgb(82,168,236)"
          },
          ".scp-is-panel.scp-keyboard:not(.scp-secondary-expanding) > #scp-focus-outline[data-show]": {
            display: "block"
          },
          // The feedback text area has its own focus ring so that it can show behind the feedback button :/ !
          "#scp-feedback-input-rect[data-show-focus]": {
            // Using id selector which is faster than [data-own-focus-ring][data-show-focus]
            stroke: "rgba(82,168,236,.8)",
            "stroke-width": "6px",
            filter: "url(#scp-focusblur)",
            "-webkit-filter": "url(#scp-focusblur)"
          },
          /*************** Clipping rules for badge **************************/
          // When the badge is fully collapsed, we clip it so that the invisible parts
          // of the SVG do not take mouse events.
          // The clipping is computed in placement.js
          // This rule undoes the placement.js clipping when the BP is not currently fully collapsed.
          "#scp-bp-container:not(.scp-is-badge)": {
            clip: "auto !important"
          },
          // ---- Badge colors (normal or object-based palette) ----
          // For instructions on setting up a palette, see https://equinox.atlassian.net/wiki/display/EN/sitecues+config+options
          "#scp-head": {
            fill: customBadgePalette.head || "#000"
          },
          ".scp-A-button": {
            fill: customBadgePalette.A || "#000"
          },
          "#scp-zoom-slider-thumb": {
            fill: customBadgePalette.sliderThumb || "#447AC4"
          },
          "#scp-zoom-slider-bar": {
            fill: customBadgePalette.sliderBar || "#383838"
          },
          "#scp-wave1": {
            fill: customBadgePalette.wave1On || "#80A9F8"
          },
          "#scp-wave2": {
            fill: customBadgePalette.wave2On || "#6B9AE0"
          },
          "#scp-wave3": {
            fill: customBadgePalette.wave3On || "#447AC4"
          },
          // ----- Pre-packaged palettes -----
          // .scp-palette-n  = palette: 'normal'
          // .scp-palette-rb = palette: 'reverse-blue'
          // .scp-palette-ry = palette: 'reverse-yellow'
          // -- Reverse blue ---
          ".scp-palette-rb #scp-zoom-slider-thumb": {
            fill: "#447AC4"
          },
          ".scp-palette-rb #scp-wave1": {
            fill: "#80A9F8"
          },
          ".scp-palette-rb #scp-wave2": {
            fill: "#6B9AE0"
          },
          ".scp-palette-rb #scp-wave3": {
            fill: "#447AC4"
          },
          ".scp-palette-rb .scp-A-button, .scp-palette-rb #scp-head, .scp-palette-rb #scp-zoom-slider-bar": {
            fill: "#fff"
          },
          ".scp-palette-rb.scp-toolbar": {
            "background-color": "#080300"
          },
          // -- Reverse yellow ---
          ".scp-palette-ry #scp-wave1": {
            fill: "#FFE460"
          },
          ".scp-palette-ry #scp-wave2": {
            fill: "#FFCC00"
          },
          ".scp-palette-ry #scp-wave3": {
            fill: "#FDAC00"
          },
          ".scp-palette-ry #scp-zoom-slider-thumb": {
            fill: "#FFCD00"
          },
          ".scp-palette-ry .scp-A-button, .scp-palette-ry #scp-head, .scp-palette-ry #scp-zoom-slider-bar": {
            fill: "#fff"
          },
          ".scp-palette-ry.scp-toolbar": {
            "background-color": "#080300"
          },
          // -- Expanded panel colors --
          // Panel must go back to normal colors when expanded
          // This is currently true for all palettes
          ".scp-want-panel .scp-A-button, .scp-want-panel #scp-head, .scp-want-panel  #scp-zoom-slider-bar": {
            fill: "#000"
          },
          ".scp-want-panel #scp-zoom-slider-thumb": {
            fill: "#447AC4"
          },
          ".scp-want-panel #scp-wave1": {
            fill: "#80A9F8"
          },
          ".scp-want-panel #scp-wave2": {
            fill: "#6B9AE0"
          },
          ".scp-want-panel #scp-wave3": {
            fill: "#447AC4"
          },
          ".scp-is-panel .scp-A-button:hover": {
            fill: "#447AC4"
          },
          ".scp-is-panel #scp-zoom-slider-thumb:hover": {
            fill: "#6B9AE0"
          },
          // General way of showing the content only if sitecues-badge is also shown.
          // Note: the page must also have the following rule:
          // .sitecues-only { visibility: hidden; opacity: 0; }
          ".sitecues-only": {
            visibility: "visible",
            opacity: 1
          }
        };
      }
      function createStyleSheet(sheetId, cssDefs) {
        var sheet = document.createElement("style");
        sheet.id = sheetId;
        sheet.innerHTML = toCSS(cssDefs);
        document.head.appendChild(sheet);
      }
      function init() {
        palette = site.get("palette");
        hasCustomPalette = "object" === typeof palette;
        customBadgePalette = hasCustomPalette && palette.badge || {};
        doWebKitPrefix = false;
        initBaseCss();
        if (!isInitialized) {
          isInitialized = true;
          createStyleSheet(BASE_SHEET_ID, BASE_CSS);
        }
      }
      if (true) {
        sitecues.toggleSlowBPAnimations = function() {
          isAnimationDebuggingOn = !isAnimationDebuggingOn;
          document.head.removeChild(helper.byId(BASE_SHEET_ID));
          createStyleSheet(BASE_SHEET_ID, BASE_CSS);
        };
      }
      return {
        init: init
      };
    }(run_bp_helper, run_platform, run_conf_site);
    run_bp_view_svg = function(finalizer, styles) {
      /*jshint multistr: true */
      var svg = '<sc id="scp-focus-outline" role="presentation"></sc><sc id="scp-shadow-container" role="presentation" style="position:absolute;width:513px;height:630px;overflow:hidden">  <sc id="scp-shadow"></sc></sc><svg id="scp-svg" role="group" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 810 300" preserveAspectRatio="xMinYMin" data-sc-reversible="false" data-metric="panel"><defs>  <g id="scp-small-A-def">    <path d="m37 .2l23 62h-14l-5 -14h-23l-5 14h-14l23 -62h14zm1 38l-9 -23h0l-8 23h16z"/>    <rect class="scp-hidden-target scp-hand-cursor" x="-22" y="-35" width="102" height="134"/>  </g>  <g id="scp-large-A-def">    <path d="m54 0l33 89h-20l-7 -20h-33l-7 20h-20l34 -89h20zm1 55l-11 -32h0l-12 33h23z"/>    <rect class="scp-hidden-target scp-hand-cursor" x="-22" y="-20" width="140" height="132"/>  </g>  <path id="scp-zoom-slider-bar-def" d="m278 3v27c0 2 -1 3 -3 3h-273c-2 0 -3 -1 -3 -3v-6c0 -1 1 -2 2 -3l273 -22c1 0 3 1 3 3z"/>  <path id="scp-zoom-slider-thumb-def" d="m11,64l-10,-15v-41c0,-2 3,-7 5,-7h15c1,0 5,3 5,7v41l-10,15c0,0 -2.5,2 -5,0"/>  <path id="scp-head-def" d="m76 45c0 1 2 4 -2 5c-1 0 -2 .5 -4 .5c-1 0 -2 1 -1 2c0 1 0 2 -2 3c1 0 2 0 2 1c0 1 -1 1 -1 3c0 1 3 5 2 8c0 3 -10 2 -20 2c0 0 -3 11 10 13c7 1 14 7 14 16h-74c0 -5 0 -12 8 -14c0 0 14 -5 14 -14c1 -13 -9 -17 -11 -27c-5 -21 6 -39 29 -39c8 0 13 2 15 4c10 5 12 16 12 22c0 3 -2 6 .5 8c8 6 8 6 9 7z"/>  <path id="scp-wave1-def" d="m105 26c0 0 26 25 1 52c-3 3 -9 2 -11 1c-2 -1 -4 -4 -2 -6c0 0 17 -18 0 -41c-1 -2 0 -5 2 -6c2 -1 8 -2 11 1z"/>  <path id="scp-wave2-def" d="m134 14c37 41 0 74 0 74c-3 3 -9 2 -11 1c-2 -1 -4 -4 -2 -6c27 -35 0 -64 0 -64l0 0c-1 -2 0 -5 2 -6c2 -1 9 -1 11 1z"/>  <path id="scp-wave3-def" d="m167 2c0 0 48 47 0 97c-3 3 -9 2 -11 1c-2 -1 -3 -5 -2 -6c36 -47 0 -87 0 -87c-1 -2 0 -5 2 -6c2 -1 9 -2 11 1z"/>  <g id="scp-bottom-def">    <rect x="0" y="134" width="808" stroke="#C0BFBF" stroke-width="1" height="1" fill="none"/>    <path transform="translate(0,1)" d="M806,186c0,6-5,11-11,11H12C6,196,1,192,1,187v-42 c0-6,0-11,0-11h806c0,0,0,5,0,11V186" fill="#EEE"/>  </g>  <path id="scp-outline-def" d="M 808 187c0 6-5 11-11 11H11.5 c-6 0-11-5-11-11V0c0 0 5 0 11 0h786c6 0 11 0 11 0V187" stroke="#999" stroke-width="1.5"/>  <g id="scp-rating-star-def">    <path d="M30 45L48 54L44 35L59 21L39 18L30 0L21 18L1 21L16 35L12 54L30 45"/>    <rect class="scp-hidden-target scp-hand-cursor" width="66" height="62"/>  </g>  <filter id="scp-focusblur">    <feGaussianBlur in="SourceGraphic" stdDeviation="2.5"/>  </filter>  <path id="scp-arrow" d="m18,-1.9c-1.3,1.4 -15.6,15 -15.6,15c-.7,.7 -1.7,1.2 -2.7,1.2c-1,0 -1.89999,-.4 -2.7,-1.2c0,0 -14.2,-13.6 -15.6,-15c-1.3,-1.4 -1.4,-3.9 0,-5.3c1.4,-1.5 3.5,-1.6 5.2,0l13,12.5l13,-12.5c1.8,-1.6 3.8,-1.5 5.2,0c1.3,1.8 1.3,4 0,5.3l.2,0z"/></defs><rect id="scp-badge-bg" fill="white" stroke-width="0" x="0" y="0" width="630" height="124" opacity="0"/><rect id="scp-badge-focus-rect" fill="transparent" stroke-width="0" x="10" y="10" width="620" height="114" rx="15" ry="15" filter="url(#scp-focusblur)"/><g id="scp-main" aria-label="{{sitecues_main_panel}}">  <rect id="scp-main-content-fill" role="presentation" fill="white" stroke-width="0" x="1" y="1" width="806" height="134" class="scp-panel-only" opacity="0"/>  <use id="scp-small-A" xlink:href="#scp-small-A-def" y="48" role="button" aria-label="{{zoom_out}}" class="scp-A-button"/>  <g id="scp-zoom-slider-bar" role="slider" aria-valuemin="1" aria-valuemax="3" aria-valuenow="1" aria-labelledby="scp-zoom-label" data-thumb-mover="scp-zoom-slider-thumb">    <use xlink:href="#scp-zoom-slider-bar-def" x="80" y="60"/>    <rect id="scp-zoom-slider-target" role="presentation" class="scp-hidden-target scp-hand-cursor" x="80" y="44" width="280" height="67"/>  </g>  <use id="scp-zoom-slider-thumb" class="scp-hand-cursor" xlink:href="#scp-zoom-slider-thumb-def" role="presentation" aria-controls="scp-zoom-slider-bar" y="48" x="60"/>  <use id="scp-large-A" xlink:href="#scp-large-A-def" x="380" y="21" role="button" aria-label="{{zoom_in}}" class="scp-A-button"/>  <line id="scp-vert-divider" class="scp-panel-only" opacity="0" stroke="#888" stroke-width="2" x1="500" y1="31" x2="500" y2="99"/>  <g id="scp-speech" role="checkbox" aria-checked="false" aria-label="{{speech}}"> <!-- ARIA Toggle button not working well with NVDA screen reader -->    <use id="scp-head" role="presentation" xlink:href="#scp-head-def" x="530" y="11"/>    <use id="scp-wave1" role="presentation" xlink:href="#scp-wave1-def" class="scp-wave" x="530" y="11"/>    <use id="scp-wave2" role="presentation" xlink:href="#scp-wave2-def" class="scp-wave" x="530" y="11"/>    <use id="scp-wave3" role="presentation" xlink:href="#scp-wave3-def" class="scp-wave" y="11" x="530"/>    <rect id="scp-speech-target" role="presentation" x="530" y="5" width="193" height="115" class="scp-hidden-target scp-hand-cursor"/>  </g>  <g id="scp-bottom" class="scp-panel-only" opacity="0">    <use id="scp-bottom-mousetarget" role="presentation" xlink:href="#scp-bottom-def"/>    <g id="scp-bottom-text" role="presentation" opacity="0">      <text id="scp-zoom-label" x="25" y="178"><tspan id="scp-zoom-value" role="presentation">{{zoom_off}}</tspan></text>      <text id="scp-speech-label" x="581" y="178" data-x-start="581" data-x-end="795">        {{speech}} {{off}}      </text>    </g>    <rect opacity="0" x="0" y="195" width="808" height="64"/>  </g></g><g id="scp-secondary-anchor" role="presentation" /><use id="scp-main-outline" role="presentation" xlink:href="#scp-outline-def" class="scp-panel-only" fill="none" opacity="0"/><g id="scp-more-button-opacity" role="presentation" transform="translate(400,198)">  <g id="scp-more-button-container" role="presentation">    <g id="scp-more-button-group" data-hover="scale(1.2)" class="scp-hand-cursor" role="button" aria-label="{{more_features}}">      <circle fill="#FFF" stroke="#777" stroke-width="5" stroke-miterlimit="10" cx="0" cy="0" r="34"/>      <use id="scp-more-arrow" role="presentation" fill="#777" xlink:href="#scp-arrow"/>      <path id="scp-question" role="presentation" fill="#777" stroke="#777" stroke-width="2" d="M0,-16c-3.4 0-6 1-7.5 2.6-1.6 1.6-2.2 3.6-2.4 5.1l4 .5c.2-1 .5-2 1.2-2.8 .8-.8 2-1.5 4.6-1.5 2.6 0 4.1 .5 4 1.4 .8 .7 1.1 1.6 1.1 2.6 0 3.3-1.4 4.2-3.4 6-2 1.8-4.6 4.3-4.6 9v1h4v-1c0-3.3 1.2-4.2 3.2-6 2-1.8 4.8-4.3 4.8-9 0-2-.7-4.1-2.4-5.6-1.7-1.6-4.3-2.4-7.6-2.4zm-2.8 28v4h4v-4h-4z"></path>      <circle cx="0" cy="0" r="36" class="scp-hidden-target"/>    </g>  </g></g><rect id="scp-mouseover-target" role="presentation" x="-100" y="-40" width="820" height="200" opacity="0"/></svg><sc id="scp-html-secondary-anchor" role="presentation" style="display:none"></sc>';
      // Hack to make sure innerHTML doesn't remove any important last element
      return function() {
        styles.init();
        return finalizer(svg);
      };
    }(run_bp_view_markup_finalizer, run_bp_view_styles);
    mini_core_native_global = {
      Map: Map,
      setTimeout: setTimeout.bind(window),
      JSON: JSON,
      bindFn: window.Function.prototype.bind
    };
    run_util_array_utility = function() {
      var findPolyfill = Array.prototype.find || function(predicate) {
        if (!this) {
          throw new TypeError("Array.prototype.find called on null or undefined");
        }
        if ("function" !== typeof predicate) {
          throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return value;
          }
        }
      };
      var findIndexPolyfill = Array.prototype.findIndex || function(predicate) {
        if (!this) {
          throw new TypeError("Array.prototype.findIndex called on null or undefined");
        }
        if ("function" !== typeof predicate) {
          throw new TypeError("predicate must be a function");
        }
        var list = Object(this);
        var length = list.length;
        var thisArg = arguments[1];
        var value;
        for (var i = 0; i < length; i++) {
          value = list[i];
          if (predicate.call(thisArg, value, i, list)) {
            return i;
          }
        }
        return -1;
      };
      function find(arrayLike, fn, thisArg) {
        return findPolyfill.call(from(arrayLike), fn, thisArg);
      }
      function findIndex(arrayLike, fn, thisArg) {
        return findIndexPolyfill.call(from(arrayLike), fn, thisArg);
      }
      // Return an array with the members of arr1 that aren't in arr2, and the members of arr2 that aren't in arr1
      // NOTE: if elements aren't unique in an array, they will be repeated in the difference
      function symmetricDifference(arr1, arr2) {
        var difference, array1 = from(arr1), array2 = from(arr2);
        if (array1.length) {
          difference = array2.filter(function(member) {
            if ("undefined" !== typeof member) {
              var index = array1.indexOf(member);
              if (index !== -1) {
                array1.splice(index, 1);
                return false;
              }
              return true;
            }
          });
          difference = difference.concat(array1);
        } else {
          difference = array2;
        }
        return difference;
      }
      // returns the members of array1 that aren't present in array2
      function difference(arr1, arr2) {
        var array1 = from(arr1), array2 = from(arr2);
        return array1.filter(function(member) {
          return array2.indexOf(member) === -1;
        });
      }
      // Takes any number of arrays and returns the union of all sets, i.e. an array with the unique members of each array
      function union() {
        var set = new Set(), arrays = from(arguments), arrayCount = arrays.length;
        for (var i = 0; i < arrayCount; i++) {
          var array = arrays[i], arraySize = array.length;
          for (var j = 0; j < arraySize; j++) {
            set.add(array[j]);
          }
        }
        return fromSet(set);
      }
      // Returns an array with elements that are in all of the passed arrays
      function intersection() {
        var arrays = arguments, i = arrays.length;
        return Array.prototype.filter.call(arrays[0], function(elem) {
          while (--i) {
            var arr = arrays[i];
            if (arr.indexOf(elem) === -1) {
              return false;
            }
          }
          return true;
        });
      }
      // Only add element if it isn't currently in the array. Return original array
      function addUnique(arr, element) {
        if (arr.indexOf(element) === -1) {
          arr.push(element);
        }
        return arr;
      }
      // Returns a new array with only the unique elements in @arr
      function unique(original) {
        var results = [], i = original.length;
        while (i--) {
          if (results.indexOf(original[i]) === -1) {
            results.unshift(original[i]);
          }
        }
        return results;
      }
      // Removes all elements matching @element from the @array, returns a new array
      function remove(array, element) {
        var index;
        do {
          index = array.indexOf(element);
          if (index !== -1) {
            array.splice(index, 1);
          }
        } while (index !== -1);
        return array;
      }
      function fromSet(set) {
        var arr = [];
        set.forEach(function(member) {
          arr.push(member);
        });
        return arr;
      }
      function from(arrayLike) {
        return Array.prototype.slice.call(arrayLike, 0);
      }
      function wrap(data) {
        return Array.isArray(data) ? data : [ data ];
      }
      return {
        remove: remove,
        addUnique: addUnique,
        unique: unique,
        symmetricDifference: symmetricDifference,
        difference: difference,
        union: union,
        intersection: intersection,
        fromSet: fromSet,
        from: from,
        wrap: wrap,
        find: find,
        findIndex: findIndex
      };
    }();
    run_inline_style_inline_style = function(nativeGlobal, arrayUtil, objectUtil) {
      var proxyMap, kebabCaseCache, assignmentDictionary, assignmentRecords, lastStyleMap, intendedStyleMap, updateTimer, styleParser, // Arbitrarily long timeout between updating the intended style.
      // This isn't an especially well tuned number, we just don't need it to update very often
      UPDATE_TIMEOUT = 300, cssNumbers = {
        "animation-iteration-count": true,
        "column-count": true,
        "fill-opacity": true,
        "flex-grow": true,
        "flex-shrink": true,
        "font-weight": true,
        "line-height": true,
        opacity: true,
        order: true,
        orphans: true,
        widows: true,
        "z-index": true,
        zoom: true
      };
      // This function replicates jQuery's coercion of numeric style values to unit strings when appropriate
      function fixUnits(property, value) {
        return "number" === typeof value && 0 !== value && !cssNumbers[property] ? value + "px" : value;
      }
      function arrayAssignment(element, styleInfo, styleField) {
        var property = toKebabCase(styleInfo[0]);
        element[styleField].setProperty(property, fixUnits(property, styleInfo[1]), styleInfo[2] || "");
      }
      function objectAssignment(element, styleInfo, styleField) {
        Object.keys(styleInfo).forEach(function(prop) {
          var property = toKebabCase(prop);
          element[styleField].setProperty(property, fixUnits(property, styleInfo[prop]));
        });
      }
      function stringAssignment(element, styleInfo, styleField) {
        element[styleField].cssText = styleInfo;
      }
      // @param elmts     : the elements to apply inline styles to
      // @param styleInfo : accepts a string, array or object in the following formats:
      /*
   * { property : value, ... }
   * 'property: value; ...'
   * ['property', 'value', 'importance']
   * */
      // @param callback  : if a callback is defined, instead of inserting a style proxy for each element, cache their intended styles, apply our style values,
      // run the callback function, and then restore the intended styles. By doing this in a synchronous block we can guarantee that no other scripts will have an opportunity
      // to assign a new value
      function overrideStyle(elmts, styleInfo) {
        var assignmentFn = getAssignmentFunction(styleInfo), elements = arrayUtil.wrap(elmts);
        elements.forEach(function(element) {
          var currentStyles = getCurrentStyles(element);
          if (isStyleProxied(element)) {
            updateLastStyles(element, styleInfo, currentStyles);
          } else {
            lastStyleMap.set(element, objectUtil.assign({}, currentStyles));
            intendedStyleMap.set(element, objectUtil.assign({}, currentStyles));
            insertStyleProxy(element);
          }
          assignmentFn(element, styleInfo, "_scStyle");
        });
      }
      function toKebabCase(str) {
        var memoizedValue = kebabCaseCache[str];
        if ("string" !== typeof memoizedValue) {
          memoizedValue = kebabCaseCache[str] = str.replace(/([A-Z])/g, function(g) {
            return "-" + g[0].toLowerCase();
          });
        }
        return memoizedValue;
      }
      function getIntendedStyle(element, property) {
        updateIntendedStyles();
        var intendedStyle = intendedStyleMap.get(element);
        if (!property) {
          // Return the cached intended styles, or undefined
          return intendedStyle;
        }
        if (!intendedStyle) {
          // If we haven't cached an inline value, return the current value
          return getStyle(element)[property];
        }
        var propObj = intendedStyle[property];
        return propObj ? propObj.value : "";
      }
      function getCurrentStyles(element) {
        return parseCss(getCssText(element));
      }
      function getLastStyles(element) {
        updateIntendedStyles();
        return lastStyleMap.get(element);
      }
      function getStyleType(styleInfo) {
        return Array.isArray(styleInfo) ? "array" : typeof styleInfo;
      }
      function getAssignmentFunction(styleInfo) {
        return assignmentDictionary[getStyleType(styleInfo)];
      }
      function setStyle(elmts, styleInfo) {
        var assignmentFn = getAssignmentFunction(styleInfo), elements = arrayUtil.wrap(elmts);
        elements.forEach(function(element) {
          assignmentFn(element, styleInfo, "style");
        });
      }
      function removeProperty(element, property) {
        getStyle(element).removeProperty(toKebabCase(property));
      }
      function clearStyle(element) {
        element.removeAttribute("style");
      }
      // This function exists mainly because we need a linting rule against /.style[^\w]/ to ensure that other modules do not interact directly
      // with elements' style object directly.
      /* NOTE: It is important to use `setStyle` to set style values for `original elements`, defined as elements in the DOM that were not
  * inserted by Sitecues. Though this method can return the style object of an element for conveniently reading and writing from
  * Sitecues elements, it must NOT be used to get the style object of original elements for the intention of setting style values */
      function getStyle(element) {
        var styleProperty = getDirectStyleProperty(element);
        return element[styleProperty];
      }
      function queueAssignmentRecord(element, styleInfo) {
        assignmentRecords.push({
          element: element,
          styleInfo: styleInfo
        });
        if (!updateTimer) {
          updateTimer = nativeGlobal.setTimeout(function() {
            updateIntendedStyles();
          }, UPDATE_TIMEOUT);
        }
      }
      // when we override a proxied element, we need to update the last style cache
      // for element, saving the current field values before the overriding values are assigned
      // Fields that are untouched by this new override retain their existing last value
      function updateLastStyles(element, styleInfo, currentStyles) {
        var lastStyles = getLastStyles(element), styleType = getStyleType(styleInfo), styleObj = getStyle(element);
        function updateProperty(prop) {
          var property = toKebabCase(prop);
          saveStyleValue(styleObj, property, lastStyles);
        }
        switch (styleType) {
         case "array":
          updateProperty(styleInfo[0]);
          break;

         case "object":
          Object.keys(styleInfo).forEach(updateProperty);
          break;

         case "string":
          lastStyles = currentStyles;
        }
        lastStyleMap.set(element, lastStyles);
      }
      function updateIntendedStyles() {
        assignmentRecords.forEach(function(record) {
          var cssObject, element = record.element, styleInfo = record.styleInfo, // cssText was assigned in this case
          isCssOverwritten = "string" === typeof styleInfo, intendedStyle = isCssOverwritten ? {} : intendedStyleMap.get(element) || {}, lastStyles = isCssOverwritten ? {} : lastStyleMap.get(element) || {};
          if (isCssOverwritten) {
            cssObject = parseCss(styleInfo);
          } else {
            // This gives us kebab-case property names
            cssObject = parseCss(stringifyCss(styleInfo));
          }
          Object.keys(cssObject).forEach(function(property) {
            var declaration = cssObject[property];
            intendedStyle[property] = objectUtil.assign({}, declaration);
            // We don't want a reversion to the `last styles`, the inline values of an element cached before its latest override, to clobber
            // dynamic updates to its intended styles.
            lastStyles[property] = objectUtil.assign({}, declaration);
          });
          intendedStyleMap.set(element, intendedStyle);
          lastStyleMap.set(element, lastStyles);
        });
        assignmentRecords = [];
        clearTimeout(updateTimer);
        updateTimer = null;
      }
      function restoreLast(element, props) {
        var lastStyles = getLastStyles(element);
        // Styles only need to be restored if we have overridden them.
        if (!lastStyles) {
          return;
        }
        var style = getStyle(element), properties = arrayUtil.wrap(props).map(toKebabCase);
        properties.forEach(function(property) {
          restoreStyleValue(style, property, lastStyles);
        });
      }
      // @param property must be kebab case in order to look up the cached styles
      function restoreStyleValue(style, property, cachedStyles) {
        var value, priority, declaration = cachedStyles[property];
        if (declaration && declaration.value) {
          value = declaration.value;
          priority = declaration.priority;
          style.setProperty(property, value, priority);
        } else {
          style.removeProperty(property);
        }
      }
      // @param property must be kebab case in order to look up the cached styles
      function saveStyleValue(style, property, cachedStyles) {
        var value = style.getPropertyValue(property) || "", priority = style.getPropertyPriority(property) || "";
        cachedStyles[property] = {
          value: value,
          priority: priority
        };
      }
      /*
  * If this function is called with an undefined `props` parameter, de-proxy the element's style property
  * */
      function restore(element, props) {
        var properties, style = getStyle(element), intendedStyle = getIntendedStyle(element);
        // Styles only need to be restored if we have overridden them.
        if (!intendedStyle) {
          return;
        }
        if (props) {
          properties = arrayUtil.wrap(props).map(toKebabCase);
          properties.forEach(function(property) {
            restoreStyleValue(style, property, intendedStyle);
          });
          // Only restore the specified properties
          return;
        }
        var cssText = stringifyCss(intendedStyle);
        if (cssText) {
          style.cssText = cssText;
        } else {
          clearStyle(element);
        }
        delete element.style;
        delete element._scStyle;
        delete element._scStyleProxy;
      }
      function styleProxyGetter(property) {
        /*jshint validthis: true */
        // TODO: We should return a proxied version of setProperty / removeProperty
        if ("function" === typeof this._scStyle[property]) {
          return this._scStyle[property].bind(this._scStyle);
        }
        return this._scStyle[property];
      }
      function styleProxySetter(property, value) {
        /*jshint validthis: true */
        var record = {};
        record[property] = value;
        queueAssignmentRecord(this, record);
        this._scStyle[property] = value;
      }
      // This inserts a proxy to catch intended style changes set by other scripts, allowing those intended
      // styles to be re-applied after Sitecues styles are removed.
      function insertStyleProxy(element) {
        var proxy = proxyMap.get(element);
        if (element.style === proxy) {
          return;
        }
        if (!proxy) {
          proxy = createProxy(element);
        }
        element._scStyle = element.style;
        element._scStyleProxy = proxy;
        Object.defineProperty(element, "style", {
          configurable: true,
          // note : get & set function declarations / expressions de-optimize their containing
          // function. Don't put more in this function than needs to happen
          get: function() {
            return element._scStyleProxy;
          },
          // element.style = cssText is equivalent to element.style.cssText = cssText
          set: function(cssText) {
            queueAssignmentRecord(element, cssText);
            element._scStyle.cssText = cssText;
          }
        });
      }
      function createProxy(element) {
        var styleChain = element.style, styleProxy = {}, proxiedProperties = {};
        function interceptProperty(property) {
          if (proxiedProperties[property]) {
            return;
          }
          var boundGetter = nativeGlobal.bindFn.call(styleProxyGetter, element, property), boundSetter = nativeGlobal.bindFn.call(styleProxySetter, element, property);
          proxiedProperties[property] = true;
          Object.defineProperty(styleProxy, property, {
            get: boundGetter,
            set: boundSetter
          });
        }
        while (styleChain) {
          Object.getOwnPropertyNames(styleChain).forEach(interceptProperty);
          styleChain = Object.getPrototypeOf(styleChain);
        }
        proxyMap.set(element, styleProxy);
        return styleProxy;
      }
      function isStyleProxied(element) {
        return element.style === element._scStyleProxy;
      }
      function getDirectStyleProperty(element) {
        return isStyleProxied(element) ? "_scStyle" : "style";
      }
      function getCssText(element) {
        return getStyle(element).cssText;
      }
      function stringifyCss(cssObject) {
        styleParser.cssText = "";
        Object.keys(cssObject).forEach(function(prop) {
          var value, priority, //setProperty only takes kebab-case
          property = toKebabCase(prop), propertyData = cssObject[prop];
          if (propertyData && "object" === typeof propertyData) {
            value = cssObject[prop].value;
            priority = cssObject[prop].priority;
          } else {
            value = propertyData;
            priority = "";
          }
          styleParser.setProperty(property, value, priority);
        });
        return styleParser.cssText;
      }
      // Returns an object keyed with style properties to a property data object containing value and priority
      // @return { property : { value : foo, priority : 'important' } }
      function parseCss(cssText) {
        var cssObj = {};
        styleParser.cssText = cssText;
        for (var i = 0; i < styleParser.length; i++) {
          var property = styleParser[i];
          saveStyleValue(styleParser, property, cssObj);
        }
        return cssObj;
      }
      function init() {
        // element -> intended css object
        intendedStyleMap = new WeakMap();
        // element -> last css object
        lastStyleMap = new WeakMap();
        // element -> style proxy object
        proxyMap = new WeakMap();
        assignmentRecords = [];
        styleParser = document.createElement("div").style;
        assignmentDictionary = {
          array: arrayAssignment,
          object: objectAssignment,
          string: stringAssignment
        };
        kebabCaseCache = {};
      }
      getStyle.override = overrideStyle;
      getStyle.set = setStyle;
      getStyle.restore = restore;
      getStyle.restoreLast = restoreLast;
      getStyle.removeProperty = removeProperty;
      getStyle.clear = clearStyle;
      getStyle.getIntendedStyle = getIntendedStyle;
      getStyle.init = init;
      return getStyle;
    }(mini_core_native_global, run_util_array_utility, run_util_object_utility);
    run_bp_view_badge_placement = function(state, BP_CONST, helper, platform, events, inlineStyle) {
      var currentBPParent, badgeElement, badgeGeometry, bpElement, svgElement, isInitialized, // The width/height of the <SVG>
      // Note: this currently stays the same in badge vs panel sizes even though the panel stretches,
      // because of transparent space to the right/bottom of the visible BP
      svgAspectRatio, SHOULD_FIX_USE_ELEMENTS, BADGE_PARENT = BP_CONST.BADGE_MODE, HTML_PARENT = BP_CONST.PANEL_MODE, badgeRect = {}, currentZoom = 1, documentElement = document.documentElement;
      // Allow animations just before panel expands
      function disableAnimations() {
        svgElement.removeAttribute("class");
      }
      // Reparent panel container to badgeElement so that page badge grows and moves
      // in-place inside the page where it is attached.
      // Also, position and size the bpContainer and set height and width of the SVG
      function switchToBadgeParent() {
        var styles = {
          tranform: ""
        };
        // Remove transform/translate so that badge is fully returned to origin state
        inlineStyle.set(bpElement, styles);
        badgeElement.appendChild(bpElement);
        currentBPParent = BADGE_PARENT;
        repositionBPOverBadge();
        fitSVGtoBadgeRect();
      }
      // Reparent panel container to <html> so that panel stays constant size and position during zooming/panning
      function switchToHtmlParent() {
        if (bpElement.parentElement === documentElement) {
          return;
        }
        // HTML_PARENT
        // Case 3. Insert outside body (as a child of <html>)
        documentElement.insertBefore(bpElement, documentElement.childNodes[0]);
        currentBPParent = HTML_PARENT;
        // The BP must be positioned over the #sitecues-badge
        repositionBPOverBadge();
        fitSVGtoBadgeRect();
      }
      // Edge and IE11 on Windows 10 fix
      // Once the BP is moved, these browsers are not re-recognizing the @xlink:href on <use> elements
      // if they are moved. However, toggling a space in front of the attribute value fixes the issue.
      function fixUseElementsInIE() {
        if (SHOULD_FIX_USE_ELEMENTS) {
          var useElement, useElements = svgElement.getElementsByTagName("use"), numUseElements = useElements.length, useIndex = 0;
          for (;useIndex < numUseElements; useIndex++) {
            useElement = useElements[useIndex];
            // Toggle space in front of href attribute to get
            // IE to 'wake up' and understand it again
            var href = useElement.getAttribute("xlink:href"), newHref = " " === href.charAt(0) ? href.substr(1) : " " + href;
            useElement.setAttribute("xlink:href", newHref);
          }
        }
      }
      // Move the BP object so that the top, left sits exactly over the badge rectangle top, left
      // This is only called when the BP is small (about to expand or finished collapsing)
      function repositionBPOverBadge() {
        // Current badge rectangle in screen coordinates
        var newBadgeRect = helper.getRect(badgeElement), // Get the amount of zoom being applied to the badge
        appliedZoom = getAppliedBPZoom(), badgeComputedStyle = window.getComputedStyle(badgeElement), // Adjust for padding
        paddingLeft = getPadding("Left"), paddingTop = getPadding("Top"), isToolbarBadge = state.get("isToolbarBadge");
        function getPadding(property) {
          return parseFloat(badgeComputedStyle["padding" + property]) * appliedZoom;
        }
        // Used for setting the bpContainer left, top, width, and height
        function setBPProperty(prop) {
          var styles = {};
          styles[prop] = badgeRect[prop] / appliedZoom + "px";
          inlineStyle.set(bpElement, styles);
        }
        // If the badge is currently dimensionless, use the cached badge dimensions
        if (rectHasNoArea(newBadgeRect)) {
          // We saved the badge rect when it was a child of the documentElement, so we multiply by the current zoom
          newBadgeRect.height = badgeGeometry.cachedRect.height * appliedZoom;
          newBadgeRect.width = badgeGeometry.cachedRect.width * appliedZoom;
        }
        if (currentBPParent === BADGE_PARENT) {
          // Not a toolbar badge and in body (inside of #sitecues-badge)
          // It's already inside of the #sitecues-badge, which is in the right place on the page,
          // and we only need transform translate to move it from there for padding and vertical offset.
          // By being a child of #sitecues-badge, it will automatically be positioned within that.
          newBadgeRect.left = 0;
          newBadgeRect.top = 0;
        }
        // Adjust for top whitespace in SVG badge (it's there because it turns into an outline on expansion)
        if (!isToolbarBadge) {
          newBadgeRect.top -= BP_CONST.BADGE_VERTICAL_OFFSET;
        }
        badgeRect.left = newBadgeRect.left + paddingLeft;
        badgeRect.top = newBadgeRect.top + paddingTop;
        // A toolbar badge's size remains the same for the lifetime of the page, so we use the cached version of size in that case
        if (!badgeRect.width || !isToolbarBadge) {
          badgeRect.width = newBadgeRect.width - paddingLeft - getPadding("Right");
          badgeRect.height = newBadgeRect.height - paddingTop - getPadding("Bottom");
        }
        // Set left and top for positioning.
        setBPProperty("width");
        setBPProperty("height");
        var styles = {
          top: 0,
          left: 0,
          transform: "translate(" + badgeRect.left / appliedZoom + "px," + badgeRect.top / appliedZoom + "px)"
        };
        inlineStyle.set(bpElement, styles);
      }
      // This makes the collapsed svg large enough so that even with
      // all the whitespace it stretches to cover the badge
      // So it should be the actual svg width / badge width
      function fitSVGtoBadgeRect() {
        var svgWidth = badgeRect.width * getRatioOfSVGToVisibleBadgeSize(badgeRect) / getAppliedBPZoom(), svgHeight = svgWidth / svgAspectRatio;
        inlineStyle.set(svgElement, {
          width: svgWidth + "px",
          height: svgHeight + "px"
        });
        // Do not animate the adjustment of the SVG to fit the size of the badge
        // We only animate large-scale size changes (badge->panel or panel->badge)
        disableAnimations();
        // Oh, IE (Edge, we know you're still really IE).
        fixUseElementsInIE();
      }
      function getWaveHeight() {
        return helper.getRectById(BP_CONST.WAVE_3_ID).height;
      }
      function getRatioOfSVGToVisibleBadgeSize(badgeRect) {
        // This is the ratio of the height allotted by the badge to the visible height.
        // It is what we need to multiply the SVG height by to get the final desired height.
        var ratioOfSVGToVisibleBadgeSize = state.get("ratioOfSVGToVisibleBadgeSize");
        if (ratioOfSVGToVisibleBadgeSize) {
          return ratioOfSVGToVisibleBadgeSize;
        }
        // First get the height for the third wave in the speech button, useful for measurements
        // It is the tallest and rightmost element
        var waveHeight, badgeRectWidth = badgeRect.width;
        // Set default height and width, because this normalizes cross browser inconsistencies
        // for SVG sizing.  Basically, if no height or width are set explicitly, then the viewBox
        // attribute effects the values of the boundingClient height and width of the SVG in Chrome,
        // but not IE.  Therefore, setting these values allows getRatioOfSVGToVisibleBadgeSize() to return the proper
        // values no matter the browser.
        inlineStyle.set(svgElement, {
          width: badgeRectWidth + "px",
          height: badgeRectWidth / svgAspectRatio + "px"
        });
        waveHeight = getWaveHeight() || badgeGeometry.waveHeight;
        ratioOfSVGToVisibleBadgeSize = badgeRect.height / waveHeight;
        state.set("ratioOfSVGToVisibleBadgeSize", ratioOfSVGToVisibleBadgeSize);
        return ratioOfSVGToVisibleBadgeSize;
      }
      function addClipRectStyleFix() {
        var badgeRect = helper.getRect(badgeElement), // A magic number to fix SC-2759.  Underlying issue is probably
        // rectangle calculations are a bit off...
        // TODO: Figure out why we are using magic numbers
        EXTRA_PIXELS_HEIGHT = 5, EXTRA_PIXELS_WIDTH = 10;
        if (rectHasNoArea(badgeRect)) {
          badgeRect = badgeGeometry.cachedRect;
        }
        inlineStyle(bpElement).clip = "rect(0," + (badgeRect.width + EXTRA_PIXELS_WIDTH) + "px," + (badgeRect.height + EXTRA_PIXELS_HEIGHT) + "px,0)";
      }
      function onZoomChange(zoomLevel) {
        currentZoom = zoomLevel;
      }
      function getAppliedBPZoom() {
        var isBPInBody = state.get("isPageBadge") && currentBPParent === BADGE_PARENT;
        return isBPInBody ? currentZoom : 1;
      }
      function executeWhileElementIsRendered(element, fn) {
        var isReparented, inlineTransform = inlineStyle(element).transform, nextSibling = element.nextSibling, parent = element.parentElement, rect = helper.getRect(element);
        // If the element isn't displayed, translate it out of the viewport and attach it to the document element.
        // This way we can be confident that an ancestor of the element isn't hiding it
        // This doesn't guarantee that a stylesheet isn't hiding the element, but it is sufficient for our current purposes
        if (rectHasNoArea(rect)) {
          inlineStyle(element).transform = "translate(-99999px,-99999px)";
          documentElement.appendChild(element);
          isReparented = true;
        }
        fn();
        if (isReparented) {
          inlineStyle(element).transform = inlineTransform;
          if (nextSibling) {
            parent.insertBefore(element, nextSibling);
          } else {
            parent.appendChild(element);
          }
        }
      }
      // This method caches the dimensions of the badge, and if it is not currently visible
      // temporarily appends the badge directly to the document element to prevent its ancestors from hiding it.
      // This ensures that we have a fallback size reference when we need to reposition the bp SVG.
      // Otherwise, if we collapse the panel when the badge element has no area
      // the panel will disappear entirely!
      function initBadgeGeometry() {
        badgeElement.appendChild(bpElement);
        events.emit("bp/did-insert-bp-element");
        executeWhileElementIsRendered(badgeElement, function() {
          var cachedRect = helper.getRect(badgeElement), contentBox = Object.create(cachedRect), computedStyle = getComputedStyle(badgeElement), paddingTop = parseFloat(computedStyle.paddingTop), paddingBottom = parseFloat(computedStyle.paddingBottom), paddingRight = parseFloat(computedStyle.paddingRight), paddingLeft = parseFloat(computedStyle.paddingLeft);
          contentBox.width -= paddingLeft + paddingRight;
          contentBox.height -= paddingTop + paddingBottom;
          inlineStyle.set(bpElement, {
            width: contentBox.width,
            height: contentBox.height
          });
          inlineStyle.set(svgElement, {
            width: contentBox.width + "px",
            height: contentBox.width / svgAspectRatio + "px"
          });
          badgeGeometry = {
            cachedRect: cachedRect,
            waveHeight: getWaveHeight()
          };
        });
      }
      function rectHasNoArea(rect) {
        return !rect.width || !rect.height;
      }
      /**
   * [init initializes the placement of the bpElement, svgElement, and badgeElement]
   * @param  {[DOM element]} badge       [Either placeholder or badge we create with ID 'sitecues-badge']
   * @param  {[DOM element]} bpContainer [SVG container <div> with ID 'scp-bp-container']
   * @param  {[DOM element]} svg         [SVG with ID 'scp-svg']
   */
      function init(badge, bpContainer, svg) {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        SHOULD_FIX_USE_ELEMENTS = platform.browser.isMS && platform.os.majorVersion >= 10;
        // Compute the aspect ratio (the width:height ratio required for the <svg>)
        var viewBoxRect = svg.viewBox.baseVal;
        // Set module scoped variables.
        badgeElement = badge;
        bpElement = bpContainer;
        svgElement = svg;
        svgAspectRatio = viewBoxRect.width / viewBoxRect.height;
        //Store initial badge dimensions and SVG scale while we know they're available
        initBadgeGeometry();
        // Initially, BP must always be contained by #sitecues-badge
        switchToBadgeParent();
        // For some reason, without this fix elements around the badge
        // do not get mouse events because the sizing of something is off.
        // See SC-2759.
        addClipRectStyleFix();
        // Listen for change events for page badges
        if (state.get("isPageBadge")) {
          // Page badges must switch back and forth dynamically
          events.on("bp/will-expand", switchToHtmlParent);
          events.on("bp/did-shrink", switchToBadgeParent);
          events.on("zoom", onZoomChange);
        } else {
          window.addEventListener("resize", repositionBPOverBadge);
        }
      }
      return {
        init: init
      };
    }(run_bp_model_state, run_bp_constants, run_bp_helper, run_platform, run_events, run_inline_style_inline_style);
    run_bp_view_size_animation = function(state, BP_CONST, helper, platform, events, nativeGlobal, inlineStyle) {
      var // Linear looks better for collapse animation
      animationStartTime, animationId, panelScaleFromBadge, badgeScaleFromPanel, // The stable target badge width
      targetBadgeWidth, requestFrameFn = window.requestAnimationFrame, cancelFrameFn = window.cancelAnimationFrame, expandEasingFn = function(t) {
        return --t * t * t + 1;
      }, // https://gist.github.com/gre/1650294
      collapseEasingFn = function(t) {
        return t;
      }, MINIMUM_DISTANCE_FROM_EDGE = 20, MINIMUM_DISTANCE_FROM_EDGE_TOP = 2, // More forgiving on top side because of toolbar
      ZOOM_MIN = 1, ZOOM_RANGE = 2, // What we're transitioning from and to
      // Note that if you exit/enter the panel in the middle of animation you can
      // end up transitioning as badge -> badge, or panel -> panel
      currentlyTransitioningFrom = BP_CONST.BADGE_MODE, currentlyTransitioningTo = null, // Not currently transitioning to anything
      // The minimum amount we want to increase the badge size
      // when transitioning to the panel.  Basically, the panel
      // should be BP_CONST.IDEAL_PANEL_WIDTH by BP_CONST.IDEAL_PANEL_HEIGHT
      // or 1.2x the size of the badge.
      MINIMUM_PANEL_SIZE_INCREASE = 1.2, transformElementId = BP_CONST.BP_CONTAINER_ID, // Amount of zoom currently applied to the badge
      currentZoom = 1, // Convenience methods
      byId = helper.byId, getRect = helper.getRect;
      function isToolbarBadge() {
        return state.get("isToolbarBadge");
      }
      function getSvgElement() {
        return byId(BP_CONST.SVG_ID);
      }
      function getBadgeElement() {
        return byId(BP_CONST.BADGE_ID);
      }
      /**
   * getDifferenceObject builds and returns an object that represents the differences
   * between two objects.  The two objects must contain only numbers or objects as values
   * for properties.
   *
   * @example
   *
   *      PARAM 1               PARAM 2                 OUTPUT
   *
   *    {                     {                      {
   *      'a': 4,              'a': 10,                'a': 6,
   *      'b': {       =>       'b': {          =      'b': {
   *        'c': 1                'c': 5                 'c': 4
   *      }                     }                      }
   *    }                     }                      }
   *
   * @param  {Object} obj1 [Object whose values are numbers or objects]
   * @param  {Object} obj2 [Object whose values are numbers or objects]
   * @return {Object}      [Object whose values are numbers or objects]
   */
      function getDifferenceObject(obj1, obj2) {
        var obj1Prop, obj2Prop, result = {};
        for (var prop in obj1) {
          if (obj1.hasOwnProperty(prop)) {
            obj1Prop = obj1[prop];
            obj2Prop = obj2[prop];
            if ("number" === typeof obj1Prop) {
              result[prop] = obj2Prop - obj1Prop;
            } else {
              result[prop] = getDifferenceObject(obj1Prop, obj2Prop);
            }
          }
        }
        return result;
      }
      /**
   * getPossibleOutlineRects returns the visible panel rectangle to be.  This is useful in our
   * calculation for determining where the panel should be animated to when expanding.
   * The actual containers of the UI (and even the UI to some degree) are much larger
   * than what the appearance suggests.
   * @param  {number} targetDimensions The target width and height for the SVG_ID element.
   * @return {Object}           The bounding client rect of the MAIN_OUTLINE_ID element after
   *                            panel expansion.
   */
      function getPossibleOutlineRects(targetDimensions) {
        var possibleOutlineRects, currentSVGWidth = helper.getRectById(BP_CONST.SVG_ID).width, targetSVGWidth = targetDimensions.width, increaseFactor = targetSVGWidth / currentSVGWidth, currentOutlineRect = helper.getRectById(BP_CONST.MAIN_OUTLINE_ID), remainingTime = 1 - state.get("currentMode");
        if (isToolbarBadge()) {
          // Centered toolbar gets centered expansion treatment
          possibleOutlineRects = {
            center: getScaledRect(currentOutlineRect, .68 * remainingTime, 0, increaseFactor)
          };
        } else {
          possibleOutlineRects = {
            "25%0%": getScaledRect(currentOutlineRect, .25 * remainingTime, 0, increaseFactor),
            topLeft: getScaledRect(currentOutlineRect, 0, 0, increaseFactor),
            "75%0%": getScaledRect(currentOutlineRect, .75 * remainingTime, 0, increaseFactor),
            topRight: getScaledRect(currentOutlineRect, 1, 0, increaseFactor),
            botRight: getScaledRect(currentOutlineRect, 0, 1, increaseFactor),
            botLeft: getScaledRect(currentOutlineRect, 1, 1, increaseFactor)
          };
        }
        return possibleOutlineRects;
      }
      /**
   * getScaledRect scales a rectangle from an origin
   * @param  {Object} rect    Rectangle
   * @param  {number} originX  0 - 1
   * @param  {number} originY  0 - 1
   * @param  {number} scale    How much we scale the rectangle
   * @return {Object}         Rectangle
   */
      function getScaledRect(rect, originX, originY, scale) {
        var scaledWidth = rect.width * scale, scaledHeight = rect.height * scale, resultRect = {};
        resultRect.left = rect.left - scaledWidth * originX / 2;
        resultRect.top = rect.top - scaledHeight * originY / 2;
        resultRect.width = scaledWidth;
        resultRect.height = scaledHeight;
        resultRect.right = resultRect.left + scaledWidth;
        resultRect.bottom = resultRect.top + scaledHeight;
        return resultRect;
      }
      function isRectLeftOfViewport(rect) {
        return rect.left < MINIMUM_DISTANCE_FROM_EDGE;
      }
      function isRectRightOfViewport(rect) {
        return rect.right > window.innerWidth - MINIMUM_DISTANCE_FROM_EDGE;
      }
      function isRectAboveViewport(rect) {
        return rect.top < MINIMUM_DISTANCE_FROM_EDGE_TOP;
      }
      function isRectBelowViewport(rect) {
        return rect.bottom > window.innerHeight - MINIMUM_DISTANCE_FROM_EDGE;
      }
      /**
   * [isRectOutsideViewport determines if the provided rectangle will be outside the viewport]
   * @param  {[Object]} rect [Bounding Client Rectangle]
   * @return {[Boolean]}     [True if rect is outside viewport]
   */
      function isRectOutsideViewport(rect) {
        return isRectLeftOfViewport(rect) || isRectRightOfViewport(rect) || isRectAboveViewport(rect) || isRectBelowViewport(rect);
      }
      /**
   * [moveRectIntoViewport returns a rectangle that is guarenteed to be within the viewport]
   * @param  {Object} rect [Rectangle]
   * @return {Object}      [Rectangle]
   */
      function moveRectIntoViewport(rect) {
        if (isRectLeftOfViewport(rect)) {
          rect.left = MINIMUM_DISTANCE_FROM_EDGE;
        }
        if (isRectAboveViewport(rect)) {
          rect.top = MINIMUM_DISTANCE_FROM_EDGE;
        }
        if (isRectRightOfViewport(rect)) {
          rect.left = window.innerWidth - rect.width - 2 * MINIMUM_DISTANCE_FROM_EDGE;
        }
        if (isRectBelowViewport(rect)) {
          rect.top = window.innerHeight - rect.height - 2 * MINIMUM_DISTANCE_FROM_EDGE;
        }
        return rect;
      }
      /**
   * [getTargetSize computes and returns the size of whatever we are animating to]
   * @return {Object} [width and height]
   */
      function getTargetSize() {
        return state.isPanelRequested() ? getTargetPanelSize() : getTargetBadgeSize();
      }
      function getTargetPanelSize() {
        var svgRect = getRect(getSvgElement()), portionRemaining = 1 - state.get("currentMode"), newPanelWidth = Math.max(BP_CONST.IDEAL_PANEL_WIDTH, svgRect.width * MINIMUM_PANEL_SIZE_INCREASE * portionRemaining), newPanelHeight = newPanelWidth * BP_CONST.IDEAL_PANEL_HEIGHT / BP_CONST.IDEAL_PANEL_WIDTH;
        return {
          width: newPanelWidth,
          height: newPanelHeight
        };
      }
      function getAspectRatio() {
        var viewBoxRect = getSvgElement().viewBox.baseVal;
        return viewBoxRect.width / viewBoxRect.height;
      }
      function getAppliedBadgeZoom() {
        return state.get("isPageBadge") ? currentZoom : 1;
      }
      function getTargetBadgeSize() {
        if (!targetBadgeWidth || !state.get("isToolbarBadge")) {
          targetBadgeWidth = getTargetBadgeWidth(getAppliedBadgeZoom());
        }
        return {
          width: targetBadgeWidth,
          height: targetBadgeWidth / getAspectRatio()
        };
      }
      function getTargetBadgeWidth(zoomMult) {
        var badgeElement = getBadgeElement(), badgeRect = getRect(badgeElement), badgeComputedStyles = window.getComputedStyle(badgeElement), extraWidth = (parseFloat(badgeComputedStyles.paddingLeft) + parseFloat(badgeComputedStyles.paddingRight)) * zoomMult, badgeRectWidth = badgeRect.width - extraWidth;
        return badgeRectWidth * state.get("ratioOfSVGToVisibleBadgeSize");
      }
      /**
   * [getTargetBadgePosition computes and returns the desired badge position]
   * @return {Object} [top and left]
   */
      function getTargetBadgePosition() {
        var top, left, FUDGE_FACTOR = -.5, // This makes it  not jerk to a new spot, not sure why
        isPageBadge = state.get("isPageBadge"), badgeElement = getBadgeElement(), badgeComputedStyles = window.getComputedStyle(badgeElement), badgeRect = getRect(badgeElement), completedZoom = currentZoom, paddingTop = parseFloat(badgeComputedStyles.paddingTop), paddingLeft = parseFloat(badgeComputedStyles.paddingLeft);
        // Badge implemented by customer
        if (isPageBadge) {
          top = badgeRect.top + paddingTop * completedZoom - BP_CONST.BADGE_VERTICAL_OFFSET + FUDGE_FACTOR;
          left = badgeRect.left + paddingLeft * completedZoom + FUDGE_FACTOR;
        } else {
          top = paddingTop;
          left = paddingLeft;
        }
        return {
          top: Math.ceil(top),
          left: Math.ceil(left)
        };
      }
      /**
   * [getTargetPosition gets all desired outline boundlingClientRects based on the
   * current SVG_ID height and width.  It checks if any of them would be inside the
   * viewport.  The first that does is the boundingClientRect of the outlineRect.]
   * @param  {Object} targetDimensions [Height and width of the SVG_ID]
   * @return {Object}                  [top and left]
   */
      function getTargetPanelPosition() {
        var rect, currentRect, resultRect, targetSize = getTargetSize(), outlineRects = getPossibleOutlineRects(targetSize);
        if (isToolbarBadge()) {
          return outlineRects.center;
        }
        for (rect in outlineRects) {
          if (outlineRects.hasOwnProperty(rect)) {
            currentRect = outlineRects[rect];
            if (!isRectOutsideViewport(currentRect)) {
              resultRect = currentRect;
              if (true) {
                console.log("Panel position using origin: " + rect);
              }
              break;
            }
          }
        }
        // Must animate into the viewport.
        if (!resultRect) {
          if (true) {
            console.log("Panel position forced into viewport.");
          }
          resultRect = moveRectIntoViewport(outlineRects.topLeft);
        }
        return resultRect;
      }
      function getTargetTransformPosition() {
        if (state.isPanelRequested()) {
          return getTargetPanelPosition();
        }
        return getTargetBadgePosition();
      }
      /**
   * [getTargetSVGElementTransforms returns the transforms for multiple SVG elements]
   * @return {Object} [Keys are the IDs for SVG elements, Values are their transforms]
   */
      function getTargetSVGElementTransforms() {
        function copyObj(obj) {
          return nativeGlobal.JSON.parse(nativeGlobal.JSON.stringify(obj));
        }
        var isPanelRequested = state.isPanelRequested(), transforms = isPanelRequested ? BP_CONST.TRANSFORMS.PANEL : BP_CONST.TRANSFORMS.BADGE, sliderWidth = isPanelRequested ? BP_CONST.LARGE_SLIDER_WIDTH : BP_CONST.SMALL_SLIDER_WIDTH, percentage = (currentZoom - ZOOM_MIN) / ZOOM_RANGE, result = copyObj(transforms);
        result[BP_CONST.ZOOM_SLIDER_THUMB_ID].translateX += percentage * sliderWidth;
        return result;
      }
      // TODO just move this right into the SVG? Why not just have it in the markup
      function firstTimeRender() {
        var SLIDER_BAR_ID = BP_CONST.ZOOM_SLIDER_BAR_ID, SLIDER_THUMB_ID = BP_CONST.ZOOM_SLIDER_THUMB_ID, badgeTransforms = BP_CONST.TRANSFORMS.BADGE, TRANSFORM_STRING = "transform", TRANSLATE_STRING = "translate(", SCALE_STRING = "scale(", CLOSING_PAREN = ") ", sliderBarTransforms = badgeTransforms[SLIDER_BAR_ID], sliderBarTransform = sliderBarTransforms.translateX + CLOSING_PAREN + SCALE_STRING + sliderBarTransforms.scaleX + "," + sliderBarTransforms.scaleY, isRealSettings = state.get("isRealSettings"), sliderThumbTranslateX = isRealSettings ? badgeTransforms[SLIDER_THUMB_ID].translateX : BP_CONST.TRANSFORMS.FAKE_BADGE_TRANSLATEX;
        function getTranslateX(id) {
          return badgeTransforms[id].translateX;
        }
        function setTransform(id, value) {
          byId(id).setAttribute(TRANSFORM_STRING, TRANSLATE_STRING + (value || getTranslateX(id)) + CLOSING_PAREN);
        }
        setTransform(BP_CONST.SMALL_A_ID);
        setTransform(BP_CONST.LARGE_A_ID);
        setTransform(BP_CONST.SPEECH_ID);
        setTransform(BP_CONST.VERT_DIVIDER_ID);
        setTransform(SLIDER_BAR_ID, sliderBarTransform);
        setTransform(SLIDER_THUMB_ID, sliderThumbTranslateX);
      }
      function getCurrentTransformPosition() {
        var transformValues, translateLeft, translateTop, transform = inlineStyle(byId(transformElementId)).transform, position = {};
        if ("none" === transform || "" === transform) {
          position.left = 0;
          position.top = 0;
        } else {
          transformValues = transform.split(",");
          translateLeft = transformValues[0];
          translateTop = transformValues[1].split("scale")[0];
          position.left = helper.getNumberFromString(translateLeft);
          position.top = helper.getNumberFromString(translateTop);
        }
        return position;
      }
      function getCurrentSize() {
        var svgRect = getRect(getSvgElement());
        return {
          width: svgRect.width,
          height: svgRect.height
        };
      }
      function getCurrentScale() {
        var transformValues, transformStyle = inlineStyle(byId(transformElementId)).transform;
        if (transformStyle.indexOf("scale") !== -1) {
          transformValues = transformStyle.split("scale");
          return helper.getNumberFromString(transformValues[1]);
        }
        return 1;
      }
      function setSize(size, crispFactor) {
        inlineStyle.set(getSvgElement(), {
          // Height and Width
          width: size.width * crispFactor + "px",
          height: size.height * crispFactor + "px"
        });
      }
      function setTransform(left, top, transformScale) {
        inlineStyle(byId(transformElementId)).transform = "translate(" + left + "px , " + top + "px) scale(" + transformScale + ")";
      }
      /**
   * [setSVGElementTransforms sets the transform attribute of all SVG elements that need to
   * be translated and scaled]
   * @param {Object} startingSVGElementTransforms  [Object representing the translation and
   *                                                  scale of the SVG elements before any animation]
   * @param {Object} svgElementTransformDifference [Object representing the difference elements
   *                                                  must translate and scale]
   * @param {Float}  animationTime                 [0 - 1, the fraction the animation is at]
   */
      function setSVGElementTransforms(startingSVGElementTransforms, svgElementTransformDifference, animationTime) {
        var translateX, transformStr, scaleX, scaleY, currentStartingValue, currentDifferenceValue, id;
        for (id in startingSVGElementTransforms) {
          if (startingSVGElementTransforms.hasOwnProperty(id)) {
            currentStartingValue = startingSVGElementTransforms[id];
            currentDifferenceValue = svgElementTransformDifference[id];
            translateX = currentStartingValue.translateX + currentDifferenceValue.translateX * animationTime;
            transformStr = "translate(" + translateX + ")";
            if (currentStartingValue.scaleX) {
              scaleX = currentStartingValue.scaleX + currentDifferenceValue.scaleX * animationTime;
              scaleY = currentStartingValue.scaleY + currentDifferenceValue.scaleY * animationTime;
              transformStr += " scale(" + scaleX + "," + scaleY + ")";
            }
            byId(id).setAttribute("transform", transformStr);
          }
        }
      }
      //  https://equinox.atlassian.net/wiki/display/EN/BP2%3A+Implementation+Details
      function getTargetScale(endingSizeToStartingSizeRatio, crispFactor) {
        var scalingFunction, isPanelRequested = state.isPanelRequested(), BADGE_TO_PANEL = 0, TWEEN_TO_PANEL_CRISPED = 1, TWEEN_TO_PANEL_UNCRISPED = 2, PANEL_TO_BADGE = 3, TWEEN_TO_BADGE_CRISPED = 4, TWEEN_TO_BADGE_UNCRISPED = 5;
        if (isPanelRequested) {
          if (state.isBadge()) {
            scalingFunction = BADGE_TO_PANEL;
          } else {
            if (currentlyTransitioningFrom === BP_CONST.PANEL_MODE) {
              scalingFunction = TWEEN_TO_PANEL_UNCRISPED;
            }
            if (currentlyTransitioningFrom === BP_CONST.BADGE_MODE) {
              scalingFunction = TWEEN_TO_PANEL_CRISPED;
            }
          }
        } else {
          if (state.isPanel()) {
            scalingFunction = PANEL_TO_BADGE;
          } else {
            if (currentlyTransitioningFrom === BP_CONST.PANEL_MODE) {
              scalingFunction = TWEEN_TO_BADGE_UNCRISPED;
            }
            if (currentlyTransitioningFrom === BP_CONST.BADGE_MODE) {
              scalingFunction = TWEEN_TO_BADGE_CRISPED;
            }
          }
        }
        switch (scalingFunction) {
         case BADGE_TO_PANEL:
          panelScaleFromBadge = endingSizeToStartingSizeRatio / crispFactor;
          return panelScaleFromBadge;

         case TWEEN_TO_PANEL_CRISPED:
          return panelScaleFromBadge;

         case TWEEN_TO_PANEL_UNCRISPED:
          return 1;

         case PANEL_TO_BADGE:
          badgeScaleFromPanel = endingSizeToStartingSizeRatio;
          return badgeScaleFromPanel;

         case TWEEN_TO_BADGE_CRISPED:
          return getCurrentScale() * endingSizeToStartingSizeRatio;

         case TWEEN_TO_BADGE_UNCRISPED:
          return badgeScaleFromPanel;
        }
      }
      /**
   * performAnimation begins the animation. We must animate the following:
   *   - position
   *   - size
   *   - transforms (translateX and scale)
   */
      function performAnimation() {
        var startingScale, endingScale, scaleDifference, startCrispFactor, isPanelRequested = state.isPanelRequested(), startingPosition = getCurrentTransformPosition(), startingSize = getCurrentSize(), startingSVGElementTransforms = helper.getCurrentSVGElementTransforms(), endingPosition = getTargetTransformPosition(), endingSize = getTargetSize(), endingSVGElementTransforms = getTargetSVGElementTransforms(), positionDifference = getDifferenceObject(startingPosition, endingPosition), svgElementTransformDifference = getDifferenceObject(startingSVGElementTransforms, endingSVGElementTransforms), fullAnimationDuration = isPanelRequested ? BP_CONST.EXPAND_ANIMATION_DURATION_MS : BP_CONST.SHRINK_ANIMATION_DURATION_MS, percentEnlarged = state.get("currentMode"), percentAnimationComplete = isPanelRequested ? percentEnlarged : 1 - percentEnlarged;
        function animationTick() {
          var timeSinceFirstAnimationTick = Date.now() - animationStartTime, animationEasingFn = isPanelRequested ? expandEasingFn : collapseEasingFn, normalizedAnimationTime = Math.min(1, animationEasingFn(timeSinceFirstAnimationTick / fullAnimationDuration)), currentMode = isPanelRequested ? normalizedAnimationTime : 1 - normalizedAnimationTime, isAnimationEnding = 1 === normalizedAnimationTime;
          state.set("currentMode", currentMode);
          // Don't set width and height of <svg>, but instead use scale transform
          // To quote from http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/
          // To achieve silky smooth animations you need to avoid work, and the best way to do that is to only change properties
          // that affect compositing -- transform and opacity.
          setTransform(startingPosition.left + positionDifference.left * normalizedAnimationTime, startingPosition.top + positionDifference.top * normalizedAnimationTime, startingScale + scaleDifference * normalizedAnimationTime);
          setSVGElementTransforms(startingSVGElementTransforms, svgElementTransformDifference, normalizedAnimationTime);
          if (isAnimationEnding) {
            // The final size must be IDEAL_PANEL_WIDTH x IDEAL_PANEL_HEIGHT
            // We use scale to make up the difference so that all HTML BP content is also sized properly (not just SVG)
            var currentSize = getCurrentSize(), ratioFromIdealSize = isPanelRequested ? BP_CONST.IDEAL_PANEL_WIDTH / currentSize.width : 1;
            setSize(getCurrentSize(), ratioFromIdealSize);
            setTransform(startingPosition.left + positionDifference.left * normalizedAnimationTime, startingPosition.top + positionDifference.top * normalizedAnimationTime, isPanelRequested ? 1 / ratioFromIdealSize : 1);
            endAnimation();
            return;
          }
          animationId = requestFrameFn(animationTick);
        }
        // Chrome is affected by the size of the source of what's scaled
        // It ends up being faster when the source is smaller, but less crisp
        function getStartCrispFactor() {
          if (false) {
            return 1;
          }
          return platform.isRetina() ? 1.5 : 3;
        }
        if (isPanelRequested && state.isBadge()) {
          startCrispFactor = getStartCrispFactor();
          setSize(startingSize, startCrispFactor);
          setTransform(startingPosition.left, startingPosition.top, 1 / startCrispFactor);
        }
        startingScale = getCurrentScale();
        endingScale = getTargetScale(endingSize.width / startingSize.width, startCrispFactor);
        scaleDifference = endingScale - startingScale;
        // The animation start time will be NOW minus how long the previous animation duration.
        animationStartTime = Date.now() - percentAnimationComplete * fullAnimationDuration;
        animationId = requestFrameFn(animationTick);
      }
      function endAnimation() {
        var isPanelRequested = state.isPanelRequested();
        cancelAnimation();
        getBadgeElement().setAttribute("aria-expanded", isPanelRequested);
        state.set("currentMode", currentlyTransitioningTo);
        currentlyTransitioningFrom = currentlyTransitioningTo;
        currentlyTransitioningTo = null;
        events.emit(isPanelRequested ? "bp/did-expand" : "bp/did-shrink");
        !function(view) {
          view.update();
        }(run_bp_view_view);
      }
      function cancelAnimation() {
        cancelFrameFn(animationId);
      }
      function onZoomChange(zoomLevel) {
        currentZoom = zoomLevel;
      }
      function animate() {
        if (currentlyTransitioningTo === state.get("transitionTo")) {
          // Already where we've been requested to be
          // This prevents us from starting a new animation of the same kind when we've already started one
          return;
        }
        if (state.isExpanding() || state.isShrinking()) {
          // There is room to animate, not already at the size limit of where we're transitioning to
          performAnimation();
        }
        currentlyTransitioningTo = state.get("transitionTo");
      }
      function init() {
        firstTimeRender();
        events.on("bp/will-expand bp/will-shrink", cancelAnimation);
        events.on("zoom/begin", function() {
          animationStartTime = 0;
        });
        events.on("zoom", onZoomChange);
      }
      return {
        init: init,
        animate: animate
      };
    }(run_bp_model_state, run_bp_constants, run_bp_helper, run_platform, run_events, mini_core_native_global, run_inline_style_inline_style);
    run_bp_view_panel_panel_classes = function(BP_CONST, state) {
      /**
   *** Getters ***
   */
      // These classes add styles based on the current state of the panel
      function getViewClasses() {
        var classBuilder = "", isSecondary = state.isSecondaryPanelRequested();
        // Is or will be secondary panel
        // In enlarged view we always show the real settings.
        // See badge.js for more about real vs fake settings.
        classBuilder += " scp-realsettings";
        if (state.isPanel()) {
          // *** scp-panel ***
          // The panel is fully enlarged and ready to accept mouse input
          classBuilder += " " + BP_CONST.IS_PANEL;
        }
        // *** scp-want-panel ***
        // Sets larger panel sizes on everything.
        // It can take time to take effect because of the animation properties.
        classBuilder += " " + BP_CONST.WANT_PANEL + (isSecondary ? " scp-want-secondary" : " " + BP_CONST.MAIN_ID);
        if (state.get("isKeyboardMode")) {
          // *** scp-keyboard ***
          // Keyboard mode is enabled and therefore current focus outline must be visible
          classBuilder += " scp-keyboard";
        }
        classBuilder += " scp-classic-" + state.get("isClassicMode");
        return classBuilder + getSecondaryPanelClasses();
      }
      /*
     A feature panel is a special panel that is triggered from the secondary panel. It can be one of four things right now:
     Settings
     Tips
     Feedback
     About
  
     These can only be shown when the panel is large.
     */
      // TODO Ideally this belongs in the bp-secondary/ folder only if isSecondaryPanel, but since require() is async it wouldn't really be worth it
      function getSecondaryPanelClasses() {
        var panelName = state.getSecondaryPanelName(), className = " scp-panel-" + panelName;
        if (state.get("isSecondaryPanel")) {
          className += " scp-is-secondary";
          if (state.get("isFeedbackSent")) {
            className += " scp-feedback-sent";
          }
        }
        if (state.get("isSecondaryExpanding")) {
          className += " scp-secondary-expanding";
        }
        return className;
      }
      return {
        getViewClasses: getViewClasses
      };
    }(run_bp_constants, run_bp_model_state);
    run_bp_view_badge_badge_classes = function(BP_CONST, state) {
      /**
   *** Public ***
   */
      function getPaletteClass() {
        var paletteKey = state.get("paletteKey"), paletteName = BP_CONST.PALETTE_NAME_MAP[paletteKey || "normal"];
        return " scp-palette" + paletteName;
      }
      function getViewClasses() {
        var classBuilder = BP_CONST.WANT_BADGE;
        if (state.isBadge()) {
          classBuilder += " " + BP_CONST.IS_BADGE;
        }
        if (true) {
          // *** scp-realsettings ***
          // Show the real settings for the badge (not the fake ones)
          // Why it's used:
          // The initial badge is easier-to-see, more attractive and more inviting when speech is on and zoom is
          // somewhere in the middle. Therefore the initial badge uses fake settings.
          // However, once the user has ever expanded the badge or used sitecues we show the real settings.
          classBuilder += " scp-realsettings";
        }
        return classBuilder;
      }
      return {
        getViewClasses: getViewClasses,
        getPaletteClass: getPaletteClass
      };
    }(run_bp_constants, run_bp_model_state);
    run_history_change_events = function(nativeGlobal) {
      var listeners, origPath;
      function getPath() {
        return document.location.pathname;
      }
      function trigger() {
        var index = 0, newPath = getPath(), numListeners = listeners.length;
        for (index; index < numListeners; index++) {
          listeners[index](origPath, newPath);
        }
        origPath = newPath;
      }
      function triggerIfPathChanged() {
        var currPath = getPath();
        if (origPath !== currPath) {
          trigger();
        }
      }
      function onClick() {
        nativeGlobal.setTimeout(triggerIfPathChanged, 0);
      }
      function on(fn) {
        if (!listeners) {
          listeners = [];
          origPath = getPath();
          // The popstate event is fired when the user uses the browser's back/forward command
          // Unfortunately this is not fired when the user clicks on a link that causes a JS-based history change
          // via the history API
          window.addEventListener("popstate", trigger);
          // Listening to click and then checking for the a location change
          // allows us to notice history changes via pushState()
          // See http://stackoverflow.com/questions/4570093/how-to-get-notified-about-changes-of-the-history-via-history-pushstate
          // The click event is also fired for links triggered via Enter key
          // We must to click via capturing listener in case page cancels
          window.addEventListener("click", onClick, true);
        }
        listeners.push(fn);
      }
      function off(fn) {
        var index = listeners.indexOf(fn);
        if (index >= 0) {
          listeners = listeners.splice(index, 1);
        }
      }
      return {
        on: on,
        off: off
      };
    }(mini_core_native_global);
    run_bp_view_view = function(BP_CONST, helper, bpSVG, placement, state, pref, sizeAnimation, locale, site, panelClasses, badgeClasses, events, historyChange, inlineStyle) {
      var bpContainer, badgeElement, svgElement, byId = helper.byId;
      /*
   *** Private ***
   */
      function getBpContainerElement() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      // The bpContainer lives just inside the badge placeholder, contains all the visible BP content, and can change size
      function createBpContainer() {
        // Create the svg container
        var bpContainerElem = document.createElement("sc");
        // Set attributes
        helper.setAttributes(bpContainerElem, BP_CONST.PANEL_CONTAINER_ATTRS);
        bpContainerElem.innerHTML = bpSVG();
        return bpContainerElem;
      }
      // Can get SVG element whether currently attached to document or not
      function getSVGElement(bpContainer) {
        // Don't use helper.byId() because the element isn't inserted in DOM yet.
        return bpContainer.querySelector("#" + BP_CONST.SVG_ID);
      }
      // Update accessibility attributes
      function updateAria(isPanel) {
        // Let the user know that the button is expandable
        badgeElement.setAttribute("aria-expanded", isPanel);
        // Hide the inner contents of the button when it's just a button
        getBpContainerElement().setAttribute("aria-hidden", !isPanel);
      }
      // If the settings are not undefined it means sitecues has been turned on before
      function hasSitecuesEverBeenOn() {
        return pref.isSitecuesUser();
      }
      // Insert badge label into an element (using aria-label didn't work as NVDA cut off the label text at 100 characters)
      // The badge label will be absolutely positioned offscreen in order to not affect layout
      function addLabel(badgeOrToolbarElement) {
        var badgeLabelElement = document.createElement("sc");
        badgeLabelElement.innerHTML = locale.translate(BP_CONST.STRINGS.BADGE_LABEL);
        inlineStyle.set(badgeLabelElement, {
          position: "absolute",
          left: "-9999px"
        });
        badgeOrToolbarElement.appendChild(badgeLabelElement);
      }
      /**
   *** Public ***
   */
      // Rerender the panel with the current model (state).
      // isNewPanel is true when a new view is shown within the panel (different widgets are present)
      function update(isNewSubpanel) {
        // Get the view classes that will create the desired appearance
        var isOrWillBePanel = state.isPanelRequested(), classes = isOrWillBePanel ? panelClasses.getViewClasses() : badgeClasses.getViewClasses();
        // This will cause the CSS to update
        bpContainer.setAttribute("class", classes);
        if (!isOrWillBePanel) {
          updateBadgePalette();
        }
        // If we are expanding or contracting, aria-expanded is true (enables CSS and communicates with screen readers)
        updateAria(isOrWillBePanel);
        // Animate to new size (only if new state requires a different size)
        sizeAnimation.animate();
        // Fire new panel event if appropriate
        if (isNewSubpanel) {
          events.emit("bp/did-open-subpanel");
        }
      }
      function updateBadgePalette() {
        var currentBadgeClassAttr = badgeElement.getAttribute("class") || "", newBadgeClassAttr = currentBadgeClassAttr.replace(/scp-palette-[a-z]+/, "") + " " + badgeClasses.getPaletteClass();
        badgeElement.setAttribute("class", newBadgeClassAttr);
      }
      // Location of page has changed via history API.
      // We must update our hashes so that they are not pointing to the wrong place,
      // otherwise the badge/panel will show up empty (SC-3797)
      function updateSvgHashes(oldPath, newPath) {
        function updateAttribute(element, attribute) {
          var oldValue = element.getAttribute(attribute), newValue = oldValue.replace(oldPath + "#", newPath + "#");
          element.setAttribute(attribute, newValue);
        }
        function updateElements(selector, attribute) {
          var elements = svgElement.querySelectorAll(selector), index = elements.length;
          while (index--) {
            updateAttribute(elements[index], attribute);
          }
        }
        updateElements("use", "xlink:href");
        updateElements("a", "href");
        updateElements("[filter]", "filter");
      }
      // This function augments the badge placement element, which is passed in.
      // This is an element that will have <svg> and other markup inserted inside of it.
      //
      // It binds the permanent event handlers. It positions the elements so they appear directly over
      // the websites placeholder.  It sets the SVG height and width so that it visually covers the
      // placeholder/badgeElement.  It binds event handlers to append the BPContainer to <html> or
      // the badgeElement (switching parent).
      function init(badgePlacementElem) {
        // Create the container and insert the SVG
        badgeElement = badgePlacementElem;
        bpContainer = createBpContainer();
        svgElement = getSVGElement(bpContainer);
        historyChange.on(updateSvgHashes);
        // Real settings or fake initial settings?
        if (false) {
          // Use fake settings if undefined -- user never used sitecues before.
          // This will be turned off once user interacts with sitecues.
          state.set("isRealSettings", site.get("alwaysRealSettings") || hasSitecuesEverBeenOn());
        }
        // Set attributes
        helper.setAttributes(badgeElement, BP_CONST.BADGE_ATTRS);
        // Label it
        addLabel(badgeElement);
        // Append the container to the badgeElement and fit to the space available
        placement.init(badgeElement, bpContainer, svgElement);
        // Get size animations ready so that the badge can gracefully grow into a panel
        sizeAnimation.init();
        // Set badge classes. Render the badge. Render slider.
        update();
      }
      return {
        init: init,
        update: update
      };
    }(run_bp_constants, run_bp_helper, run_bp_view_svg, run_bp_view_badge_placement, run_bp_model_state, run_conf_preferences, run_bp_view_size_animation, run_locale, run_conf_site, run_bp_view_panel_panel_classes, run_bp_view_badge_badge_classes, run_events, run_history_change_events, run_inline_style_inline_style);
    run_dom_events = function() {
      var isPassiveSupported = false;
      function getThirdParam(opts) {
        opts = opts || {};
        var isCapturing = false !== opts.capture, isPassive = false !== opts.passive;
        if (isPassiveSupported) {
          return {
            capture: isCapturing,
            passive: isPassive
          };
        }
        return isCapturing;
      }
      function on(target, type, fn, opts) {
        target.addEventListener(type, fn, getThirdParam(opts));
      }
      function off(target, type, fn, opts) {
        target.removeEventListener(type, fn, getThirdParam(opts));
      }
      function once(target, type, fn, opts) {
        var finalOpts = getThirdParam(opts);
        target.addEventListener(type, fn, finalOpts);
      }
      function init() {
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              isPassiveSupported = true;
            }
          });
          window.addEventListener("test", null, opts);
        } catch (e) {}
      }
      return {
        on: on,
        // Note: use { passive: false } if you ever need to cancel the event!
        once: once,
        off: off,
        init: init
      };
    }();
    run_bp_controller_expand_controller = function(BP_CONST, state, helper, metric, abTest, pref, site, view, events, domEvents, nativeGlobal) {
      // How long we wait before expanding BP
      var hoverIfNoMoveTimer, // If mouse stays still inside badge, open
      hoverIfStayInsideTimer, // If mouse stays inside badge pr toolbar, open
      isInitialized, sensitivity, // We ignore the first mouse move when a window becomes active, otherwise badge opens
      // if the mouse happens to be over the badge/toolbar
      doIgnoreNextMouseMove = true, DEFAULT_SENSITIVITY = 1;
      /* How much more or less sensitive is the badge than usual, e.g. 1.5 = 50% more sensitive */
      function getBadgeElement() {
        return helper.byId(BP_CONST.BADGE_ID);
      }
      function isInBadgeArea(evt, badgeRect) {
        return evt.clientX >= badgeRect.left && evt.clientX <= badgeRect.right && evt.clientY >= badgeRect.top && evt.clientY <= badgeRect.bottom;
      }
      function getVisibleBadgeRect() {
        return helper.getRect(helper.byId(BP_CONST.MOUSEOVER_TARGET));
      }
      // When window is newly activated, ignore the automatic first mousemove that is generated
      // that may happen to be over the badge/toolbar. Require that the user intentionally moves to the toolbar.
      function onWindowFocus() {
        doIgnoreNextMouseMove = true;
      }
      // Logic to determine whether we should begin to expand panel
      function onMouseMove(evt) {
        if (doIgnoreNextMouseMove) {
          doIgnoreNextMouseMove = false;
          return;
        }
        if (state.isExpanding()) {
          return;
        }
        cancelHoverIfNoMoveTimer();
        // Is the event related to the visible contents of the badge?
        // (as opposed to the hidden areas around the badge)
        var badgeRect = getVisibleBadgeRect();
        if (!isInBadgeArea(evt, badgeRect)) {
          return;
        }
        // Check if shrinking and need to reopen
        if (state.isShrinking()) {
          changeModeToPanel();
          // User changed their mind -- reverse course and reopen
          return;
        }
        // Set timers to open the badge if the user stays inside of it
        // We use two timers so that if the user actually stops, the badge opens faster (more responsive feeling)
        // Hover if no move -- start a new timer every time mouse moves
        hoverIfNoMoveTimer = nativeGlobal.setTimeout(changeModeToPanel, getHoverDelayNoMove());
        if (!hoverIfStayInsideTimer) {
          hoverIfStayInsideTimer = nativeGlobal.setTimeout(changeModeToPanel, getHoverDelayStayInside());
        }
      }
      function getSensitivity() {
        return sensitivity;
      }
      function getHoverDelayNoMove() {
        return BP_CONST.HOVER_DELAY_NOMOVE_BADGE / sensitivity;
      }
      function getHoverDelayStayInside() {
        // First interaction is most sensitive
        if (abTest.get("extraSensitiveBadgeNewUser") && isFirstInteraction()) {
          return BP_CONST.HOVER_DELAY_STAY_INSIDE_FIRST_TIME;
        }
        // Second or later interaction
        return BP_CONST.HOVER_DELAY_STAY_INSIDE_BADGE / sensitivity;
      }
      function isFirstInteraction() {
        // Once the badge opens the first time, we show the actual zoom and tts states
        // Before that, we don't show real settings (we show a zoom of about 2 and TTS on)
        return !state.get("isRealSettings");
      }
      /*
   Show panel according to settings.
   */
      function expandPanel(isOpenedWithHover) {
        if (state.isPanel()) {
          return;
        }
        var isFirstBadgeUse = isFirstInteraction();
        state.set("isFirstBadgeUse", isFirstBadgeUse);
        // Will stay true throught this use of the badge
        setPanelExpandedState(isOpenedWithHover);
        events.emit("bp/will-expand");
        new metric.BadgeHover({
          isFirstBadgeUse: isFirstBadgeUse
        }).send();
        view.update();
      }
      function ensureFutureRealSettings() {
        // Use real settings on next page load
        // Save zoom level so that Sitecues does not see this as a first time user
        if (!pref.has("zoom")) {
          pref.set("zoom", 1);
        }
      }
      function setPanelExpandedState(isOpenedWithHover) {
        state.set("isSecondaryExpanded", false);
        // Only main panel expanded, not secondary
        state.set("wasMouseInPanel", isOpenedWithHover);
        state.set("transitionTo", BP_CONST.PANEL_MODE);
        state.turnOnRealSettings();
        ensureFutureRealSettings();
      }
      function changeModeToPanel(isOpenedWithKeyboard) {
        cancelHoverTimers();
        if (!state.get("isShrinkingFromKeyboard")) {
          // Don't re-expand while trying to close via Escape key
          expandPanel(!isOpenedWithKeyboard);
        }
      }
      function cancelHoverTimers() {
        cancelHoverIfNoMoveTimer();
        cancelHoverIfStayInsideTimer();
      }
      function cancelHoverIfNoMoveTimer() {
        clearTimeout(hoverIfNoMoveTimer);
        hoverIfNoMoveTimer = 0;
      }
      function cancelHoverIfStayInsideTimer() {
        clearTimeout(hoverIfStayInsideTimer);
        hoverIfStayInsideTimer = 0;
      }
      // When a click happens on the badge, it can be from one of two things:
      // - A fake click event pushed by a screen reader when the user presses Enter -- in this case we should expand the panel
      // - An actual click in the whitespace around the panel (before they moused over the visible area) -- we should ignore these
      //   so that clicks around the panel don't accidentally open it.
      function clickToOpenPanel(evt) {
        if (state.isBadge()) {
          var badgeElem = helper.byId(BP_CONST.BADGE_ID), isBadgeFocused = document.activeElement === badgeElem, target = evt.target, isChildClicked = target && target.parentNode === badgeElem, badgeRect = getVisibleBadgeRect(), isClickInVisibleBadgeRect = isInBadgeArea(evt, badgeRect);
          if (!isClickInVisibleBadgeRect) {
            // Click is in the toolbar, outside of visible badge
            // Focus should be in the document, otherwise HLB won't work (confusing)
            if (isBadgeFocused) {
              document.body.focus();
            }
            // Don't focus badge
            evt.preventDefault();
            return false;
          } else {
            if (isBadgeFocused || isChildClicked) {
              // Screen reader pseudo-click
              // Click is in visible area and badge has focus --
              // * or *
              // Click in invisible child -- only screen readers can do this -- NVDA does it
              // Go ahead and open the panel in focus/keyboard mode
              // First ensure it has focus (it didn't in second case)
              badgeElem.focus();
              // Opened with click means opened with keyboard in screen reader
              nativeGlobal.setTimeout(function() {
                changeModeToPanel(true);
                // Set screen reader flag for the life of this page view
                state.set("isOpenedWithScreenReader", true);
              }, 0);
            } else {
              // Actual click -- not fake screen reader click, so no need to focus
              changeModeToPanel();
            }
          }
        }
      }
      function processBadgeActivationKeys(evt) {
        var ENTER = 13, SPACE = 32;
        if (state.isBadge() && (evt.keyCode === ENTER || evt.keyCode === SPACE) && evt.target === getBadgeElement()) {
          evt.preventDefault();
          changeModeToPanel(true);
        }
      }
      function didExpand() {
        !function(bpExpanded) {
          bpExpanded.init();
        }(bp_expanded_bp_expanded);
      }
      function didZoom() {
        !function(sliderController) {
          state.turnOnRealSettings();
          sliderController.init();
          view.update();
        }(bp_expanded_controller_slider_controller);
      }
      function didChangeSpeech(isOn) {
        !function(ttsButton) {
          // Update the TTS button view on any speech state change
          state.turnOnRealSettings();
          ttsButton.init();
          ttsButton.updateTTSStateView(isOn);
          view.update();
        }(bp_expanded_view_tts_button);
      }
      /*
   Private functions.
   */
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          sensitivity = site.get("badgeSensitivity") || DEFAULT_SENSITIVITY;
          var badgeElement = getBadgeElement();
          domEvents.on(badgeElement, "keydown", processBadgeActivationKeys, {
            passive: false
          });
          domEvents.on(badgeElement, "mousedown", clickToOpenPanel, {
            passive: false
          });
          domEvents.on(badgeElement, "mousemove", onMouseMove);
          domEvents.on(badgeElement, "mouseleave", cancelHoverTimers);
          domEvents.on(window, "focus", onWindowFocus);
          events.on("bp/did-expand", didExpand);
          events.on("zoom", didZoom);
          events.on("speech/did-change", didChangeSpeech);
          // Turn on TTS button if the setting is on
          if (pref.get("ttsOn")) {
            didChangeSpeech(true);
          }
          if (true) {
            sitecues.toggleStickyPanel = function() {
              var isSticky = !state.get("isStickyPanel");
              state.set("isStickyPanel", isSticky);
              return isSticky;
            };
          }
        }
      }
      return {
        init: init,
        getSensitivity: getSensitivity,
        expandPanel: expandPanel
      };
    }(run_bp_constants, run_bp_model_state, run_bp_helper, run_metric_metric, run_ab_test_ab_test, run_conf_preferences, run_conf_site, run_bp_view_view, run_events, run_dom_events, mini_core_native_global);
    run_bp_model_classic_mode = function(site, platform) {
      var CLASSIC_SITES = {};
      function isClassicBrowser() {
        // Edge is too, at least for now
        return platform.browser.isEdge;
      }
      function isClassicSite() {
        var classicPref = site.get("classicMode");
        if ("undefined" !== typeof classicPref) {
          return classicPref;
        }
        return CLASSIC_SITES[site.getSiteId()];
      }
      function isClassicMode() {
        return Boolean(isClassicSite() || isClassicBrowser());
      }
      return isClassicMode;
    }(run_conf_site, run_platform);
    run_bp_view_palette = function(state, site, BP_CONST, Promise) {
      // badgeFileName is optional, and used in the case of old <img> badge placeholders.
      // In that case the filename defines which palette to use, e.g. sitecues-badge-reverse-blue.png
      // If no badge file name, check the site preferences for a palette
      // Otherwise use the default palette.
      // Custom palettes are a different story ...
      function getSimplePaletteType(badgeFileName) {
        var paletteName = badgeFileName || site.get("palette") || "", paletteMap = BP_CONST.PALETTE_NAME_MAP, fullNames = Object.keys(paletteMap), index = 0;
        // Check for a string because site.get('palette')
        // returns an Object if a custom palette is used.
        if ("string" === typeof paletteName) {
          for (;index < fullNames.length; index++) {
            var fullName = fullNames[index];
            if (paletteName.indexOf(fullName) >= 0) {
              return fullNames[index];
            }
          }
        }
        return "";
      }
      // initialize the badge color palette support
      // @badgeFileName is optional -- provided when the badge is from an <img>, which clues us into the palette
      function init(badgeFileName) {
        var paletteKey = getSimplePaletteType(badgeFileName);
        // Handle 'adaptive' palette
        if (paletteKey === BP_CONST.PALETTE_NAME_ADAPTIVE) {
          if (true) {
            // Toolbars don't adapt to theme changes -- 'adaptive' is not valid in tat case
            paletteKey = BP_CONST.PALETTE_NAME_NORMAL;
          } else {
            return new Promise(function(resolve) {
              !function(bpAdaptive) {
                state.set("defaultPaletteKey", BP_CONST.PALETTE_NAME_NORMAL);
                bpAdaptive.initAdaptivePalette();
                resolve();
              }(bp_adaptive_bp_adaptive);
            });
          }
        }
        state.set("defaultPaletteKey", paletteKey);
        state.set("paletteKey", paletteKey);
        return Promise.resolve();
      }
      return {
        init: init
      };
    }(run_bp_model_state, run_conf_site, run_bp_constants, Promise);
    run_bp_view_badge_page_badge = function(baseView, palette, Promise, inlineStyle) {
      // Make sure the badge has non-static positioning to make it easy to place
      // the position: absolute sc-bp-container inside of it
      function ensureNonStaticPositioning(badge) {
        var existingPositionCss = getComputedStyle(badge).position;
        if ("static" === existingPositionCss) {
          inlineStyle(badge).position = "relative";
        }
      }
      function initBadgeView(badge, badgeFileName) {
        return palette.init(badgeFileName).then(function() {
          ensureNonStaticPositioning(badge);
          baseView.init(badge);
        });
      }
      function init(origBadgeElem) {
        return new Promise(function(resolve) {
          if ("img" !== origBadgeElem.localName) {
            // Normal placeholder badge
            return resolve({
              badgeElem: origBadgeElem
            });
          }
          !function(imagePlaceHolder) {
            var newBadge = imagePlaceHolder.init(origBadgeElem);
            resolve({
              badgeElem: newBadge,
              origSrc: origBadgeElem.src
            });
          }(bp_img_placeholder_bp_img_placeholder);
        }).then(function(badgeInfo) {
          return initBadgeView(badgeInfo.badgeElem, badgeInfo.origSrc);
        });
      }
      return {
        init: init
      };
    }(run_bp_view_view, run_bp_view_palette, Promise, run_inline_style_inline_style);
    run_bp_bp = function(events, expandController, state, helper, BP_CONST, site, classicMode, pageBadgeView, Promise, nativeGlobal, inlineStyle) {
      /*
   *** Public methods ***
   */
      // The htmlContainer has all of the SVG inside of it, and can take keyboard focus
      var docElem, badgeView, hasFixedBody = false, byId = helper.byId;
      /**
   *** Start point ***
   */
      function getBadgeElement() {
        return byId(BP_CONST.BADGE_ID);
      }
      function isToolbarUIRequested() {
        return "toolbar" === site.get("uiMode");
      }
      /**
   * initializeBPFeature is the main initialization function that is run when the
   * BP feature is ready to be enabled.  It creates the necessary elements,
   * renders them, and emits events for the rest of the application too
   */
      function initBPView() {
        if (false) {
          var badgePlaceholderElem = getBadgeElement();
          // Get site's in-page placeholder badge or create our own
          if (badgePlaceholderElem) {
            badgeView = pageBadgeView;
            return pageBadgeView.init(badgePlaceholderElem);
          }
        }
        // Toolbar mode requested or no badge (toolbar is default)
        // Note: cannot use require().then because we use AMD clean in the extension
        return new Promise(function(resolve) {
          !function(toolbarView) {
            badgeView = toolbarView;
            badgeView.init().then(resolve);
          }(bp_toolbar_badge_bp_toolbar_badge);
        });
      }
      function initBPFeature() {
        return initBPView().then(function() {
          expandController.init();
          events.on("zoom/begin", function() {
            if (!hasFixedBody) {
              fixDimensionsOfBody();
              hasFixedBody = true;
            }
          });
          return getViewInfo();
        });
      }
      /*
                           ********  INITIALIZATION **********
  
        - Immediately initialize if the any of the following are true:
          - If the document is interactive and the customer does not use the <img>
          - If the document is complete
        - If we can't immediately initialize, add the appropriate event listener
          - If the customer uses the <img>, attach a load event listener to the <img>
          - If the customer does NOT use the <img>, attach a readystatechange event listener to the document.
    */
      function isDocReady() {
        if (!document.body) {
          // Pages that contain parsing errors may not have a body --
          // don't load Sitecues unless there is a body
          return false;
        }
        var readyState = document.readyState;
        return "complete" === readyState || "interactive" === readyState;
      }
      // Init BP if the badge is ready and the document is 'interactive'|'complete'
      // Return true if BP initialized
      function docReady() {
        if (isDocReady()) {
          return Promise.resolve();
        }
        return new Promise(function(resolve) {
          function onReadyStateChange() {
            if (isDocReady()) {
              resolve();
              document.removeEventListener("readystatechange", onReadyStateChange);
            }
          }
          document.addEventListener("readystatechange", onReadyStateChange);
        });
      }
      function badgeReady() {
        // If badge is already in the DOM, we can already init
        var badgeElem = getBadgeElement();
        if (badgeElem) {
          return Promise.resolve();
        }
        // No badge yet -- wait until doc is interactive or complete
        return docReady();
      }
      // The toolbar gets to init earlier than a site-provided badge
      // It's safe to init as soon as the <body> is available
      function bodyReady() {
        var CHECK_BODY_INTERVAL = 250;
        return new Promise(function(resolve) {
          function checkBody() {
            if (document.body) {
              resolve();
            } else {
              nativeGlobal.setTimeout(checkBody, CHECK_BODY_INTERVAL);
            }
          }
          checkBody();
        });
      }
      // Classic mode is where the ? shows up instead of the down pointing arrow
      // TODO remove one day, we hope
      function initClassicMode() {
        state.set("isClassicMode", classicMode());
        sitecues.toggleClassicMode = function() {
          state.set("isClassicMode", !state.get("isClassicMode"));
        };
      }
      //It's possible that the transformations we apply to the body disrupt absolutely positioned elements
      //contained by the initial containing block. This is a hacky solution to the problem, but it is much cheaper
      //than analyzing the page and manually repositioning absolute elements.
      //TODO: Check client site CNIB's absolutely positioned elements if this gets changed
      function fixDimensionsOfBody() {
        var body = document.body, bodyStyle = getComputedStyle(body), docStyle = getComputedStyle(docElem), botMargin = parseFloat(bodyStyle.marginBottom), topMargin = bodyStyle.marginTop, leftMargin = bodyStyle.marginLeft, rightMargin = bodyStyle.marginRight;
        if (parseFloat(bodyStyle.height) < parseFloat(docStyle.height)) {
          inlineStyle.override(body, {
            height: docStyle.height
          });
        }
        if (0 !== botMargin) {
          //marginBottom doesn't override bottom margins that are set with the shorthand 'margin' style,
          //so we get all the margins and set our own inline shorthand margin
          inlineStyle.override(body, {
            margin: topMargin + " " + rightMargin + " 0px " + leftMargin
          });
        }
      }
      function getViewInfo() {
        var badgeElem = document.getElementById("sitecues-badge"), rect = badgeElem ? badgeElem.getBoundingClientRect() : {};
        if (!rect.height) {
          return {
            isBadgeHidden: true
          };
        }
        var isToolbar = state.get("isToolbarBadge"), hasCustomPalette = "object" === typeof site.get("palette"), viewInfo = {
          badgePalette: hasCustomPalette ? "custom" : state.get("defaultPaletteKey") || BP_CONST.PALETTE_NAME_NORMAL
        };
        if (isToolbar) {
          viewInfo.isToolbar = true;
        } else {
          viewInfo.badgeHeight = Math.round(rect.height);
          viewInfo.badgeTop = Math.round(rect.top - window.pageYOffset);
          viewInfo.badgeLeft = Math.round(rect.left - window.pageXOffset);
        }
        viewInfo.sensitivity = expandController.getSensitivity();
        return viewInfo;
      }
      /**
   * init()
   *
   * @return Promise
   *
   * Looks for the badge element, or wait for it to load, and insert and display the BP based on it's position.
   *    When this is called:
   * There are many cases for badge markup or config, and we also can't be sure exactly when this function is called
   * in the lifetime of the document.
   *
   * Conditions required before we create and display BP -- any of the following:
   *   1. site.get('uiMode') = 'toolbar' AND document.body is available
   *   2. Page readyState is 'interactive' AND badge element is found (also loaded if it was an <img>)
   *   3. Page readyState is 'complete' (will use a toolbar if no badge element is found at this point)
   *
   * BP config/setup cases:
   *   1. Toolbar config (e.g. sitecues everywhere) -- allowed to load early
   *   2. Empty badge placeholder <div id="sitecues-badge"> (normal in-page customer case)
   *   3. Badge image present <img id="sitecues-badge"> (old-school, these are deprecated)
   *     a) Already loaded
   *     b) Need to wait for <img>
   *   4. Missing badge and document not complete -- need to wait to see if badge shows up
   *   5. Missing badge and document complete (causes toolbar)
   */
      function init() {
        docElem = document.documentElement;
        // Get whether the BP will run in classic mode (still needed for MS Edge)
        initClassicMode();
        // ---- Look for toolbar config ----
        if (isToolbarUIRequested()) {
          // Case 1: toolbar config -- no need to wait for badge placeholder
          if (true) {
            console.log("Early initialization of toolbar.");
          }
          return bodyReady().then(initBPFeature);
        }
        // ---- Look for badge, fall back to toolbar if necessary ----
        // Page may still be loading -- check if the badge is available
        return badgeReady().then(initBPFeature);
      }
      return {
        init: init
      };
    }(run_events, run_bp_controller_expand_controller, run_bp_model_state, run_bp_helper, run_bp_constants, run_conf_site, run_bp_model_classic_mode, run_bp_view_badge_page_badge, Promise, mini_core_native_global, run_inline_style_inline_style);
    run_modifier_key_state = function(domEvents, constants) {
      var isCtrlKeyDownNow = false, CTRL_KEY_CODE = constants.KEY_CODE.CTRL;
      function onKeyDown(event) {
        if (event.keyCode === CTRL_KEY_CODE) {
          isCtrlKeyDownNow = true;
        }
      }
      function onKeyUp(event) {
        if (event.keyCode === CTRL_KEY_CODE) {
          isCtrlKeyDownNow = false;
        }
      }
      function isCtrlKeyDown() {
        return isCtrlKeyDownNow;
      }
      function init() {
        domEvents.on(window, "keydown", onKeyDown);
        domEvents.on(window, "keyup", onKeyUp);
      }
      return {
        init: init,
        isCtrlKeyDown: isCtrlKeyDown
      };
    }(run_dom_events, run_constants);
    run_shake_constants = {
      SESSION_SHAKE_COUNT_KEY: "-sc-mouseshake-count",
      MOUSE_POSITIONS_ARRAY_SIZE: 12,
      // Number of mouse positions stored
      MIN_DIR_SWITCHES_FOR_SHAKE: 2,
      // How many vertical/horizontal direction switches required to be considered a shake
      MIN_SHAKE_DIST: 3,
      // Minimum pixels moved to begin a mouse shake
      MAX_DIST_NON_SHAKE_AXIS: 30,
      // Max pixels moved on axis not being shaken (vertical/horizontal)
      MIN_SHAKE_VIGOR_DECREASE: 4,
      // Minimum speed of shake decrease
      MAX_SHAKE_VIGOR_DECREASE: 32,
      // Maximum speed of shake decrease
      SHAKE_DECREASE_MULTIPLIER: 6,
      // Magic value for shake decreases based on mouse speed
      SHAKE_INCREASE_POWER: 1.2,
      // Magic value for exponential shake increase based on mouse speed
      MAX_SHAKE_VIGOR_INCREASE: 100,
      // Max shake increase (out of total possible MAX_SHAKE_VIGOR)
      MAX_SHAKE_VIGOR: 400,
      // Max total shake vigor
      MIN_MOVE_SIZE_FOR_SHAKE: 3,
      // Pixel-size for irrelevant mousemove
      MS_BETWEEN_SHAKE_EVENTS: 50,
      // ms between internal shake events
      MAX_TIME_BETWEEN_MOVES: 100,
      // if more ms than this since last mouse move, reset
      METRIC_THRESHOLD_SHAKE_PERCENT_RESET: 10,
      // Shake percent must dip below this amount before firing again
      METRIC_THRESHOLD_SHAKE_PERCENT_FIRE: 50
    };
    run_shake_shake = function(metric, domEvents, constants, platform, nativeGlobal) {
      var lastShakeTimeout, mousePositionsQueue = [], lastShakeVigor = 0, lastShakeVigorPercent = 0, canFireMetricAgain = true, MIN_DIR_SWITCHES_FOR_SHAKE = constants.MIN_DIR_SWITCHES_FOR_SHAKE, MOUSE_POSITIONS_ARRAY_SIZE = constants.MOUSE_POSITIONS_ARRAY_SIZE, MIN_SHAKE_DIST = constants.MIN_SHAKE_DIST, MAX_DIST_NON_SHAKE_AXIS = constants.MAX_DIST_NON_SHAKE_AXIS, MAX_SHAKE_VIGOR = constants.MAX_SHAKE_VIGOR, MIN_SHAKE_VIGOR_DECREASE = constants.MIN_SHAKE_VIGOR_DECREASE, MAX_SHAKE_VIGOR_DECREASE = constants.MAX_SHAKE_VIGOR_DECREASE, SHAKE_DECREASE_MULTIPLIER = constants.SHAKE_DECREASE_MULTIPLIER, SHAKE_INCREASE_POWER = constants.SHAKE_INCREASE_POWER, MAX_SHAKE_VIGOR_INCREASE = constants.MAX_SHAKE_VIGOR_INCREASE, MIN_MOVE_SIZE_FOR_SHAKE = constants.MIN_MOVE_SIZE_FOR_SHAKE, MAX_TIME_BETWEEN_MOVES = constants.MAX_TIME_BETWEEN_MOVES, METRIC_THRESHOLD_SHAKE_PERCENT_FIRE = constants.METRIC_THRESHOLD_SHAKE_PERCENT_FIRE, METRIC_THRESHOLD_SHAKE_PERCENT_RESET = constants.METRIC_THRESHOLD_SHAKE_PERCENT_RESET;
      function reset() {
        mousePositionsQueue = [];
        clearTimeout(lastShakeTimeout);
        if (lastShakeVigor > 0) {
          lastShakeVigor = lastShakeVigorPercent = 0;
          fireNotifications(0);
        }
      }
      function onMouseLeave(evt) {
        if (evt.target === document.documentElement) {
          reset();
        }
      }
      function getMovementSummary() {
        var prevMove = mousePositionsQueue[0], xDir = mousePositionsQueue[1].x > prevMove.x ? 1 : -1, yDir = mousePositionsQueue[1].y > prevMove.y ? 1 : -1, totalDist = 0, xDirectionSwitches = 0, yDirectionSwitches = 0, distanceRequirement = lastShakeVigor ? 0 : MIN_SHAKE_DIST, minX = prevMove.x, minY = prevMove.y, maxX = minX, maxY = minY;
        mousePositionsQueue.slice(1).forEach(function(currMove) {
          var x = currMove.x, y = currMove.y, xDelta = x - prevMove.x, xDist = Math.abs(xDelta), yDelta = y - prevMove.y, yDist = Math.abs(yDelta), xDirection = xDist < distanceRequirement ? 0 : xDist / xDelta, yDirection = yDist < distanceRequirement ? 0 : yDist / yDelta;
          totalDist += xDist + yDist;
          // Calculate horizontal direction switches
          if (xDirection === -xDir) {
            ++xDirectionSwitches;
            xDir = xDirection;
          }
          // Calculate vertical direction switches
          if (yDirection === -yDir) {
            ++yDirectionSwitches;
            yDir = yDirection;
          }
          if (x < minX) {
            minX = x;
          } else {
            if (x > maxX) {
              maxX = x;
            }
          }
          if (y < minY) {
            minY = y;
          } else {
            if (y > maxY) {
              maxY = y;
            }
          }
          prevMove = currMove;
        });
        return {
          xSwitches: xDirectionSwitches,
          ySwitches: yDirectionSwitches,
          totalXDist: maxX - minX,
          totalYDist: maxY - minY
        };
      }
      function getShakeVigorIncrease() {
        var isShakeX, isShakeY, movementSummary = getMovementSummary(mousePositionsQueue);
        function isMouseShake() {
          if (lastShakeVigor) {
            // Was already shaking -- make it easy to keep it going
            return movementSummary.xSwitches >= MIN_DIR_SWITCHES_FOR_SHAKE || movementSummary.ySwitches >= MIN_DIR_SWITCHES_FOR_SHAKE;
          }
          // Possible new shake -- be more stringent
          isShakeX = movementSummary.xSwitches >= MIN_DIR_SWITCHES_FOR_SHAKE;
          isShakeY = movementSummary.ySwitches >= MIN_DIR_SWITCHES_FOR_SHAKE;
          if (isShakeX && isShakeY) {
            // Horizontal AND vertical shake => is a shake
            return true;
          }
          if (isShakeX) {
            // Horizontal only -- require small total vertical movement
            return movementSummary.totalYDist < MAX_DIST_NON_SHAKE_AXIS;
          }
          if (isShakeY) {
            // Vertical only -- require small total horizontal movement
            return movementSummary.totalXDist < MAX_DIST_NON_SHAKE_AXIS;
          }
        }
        if (isMouseShake()) {
          var distanceFactor = Math.max(movementSummary.totalXDist, movementSummary.totalYDist);
          return Math.min(Math.pow(distanceFactor, SHAKE_INCREASE_POWER), MAX_SHAKE_VIGOR_INCREASE);
        }
      }
      function getShakeVigorDecrease(lastDistance) {
        // Shake factor shrinks back down as mouse moves (faster as speed increases)
        var unboundedResult = lastDistance * SHAKE_DECREASE_MULTIPLIER, boundedResult = Math.max(Math.min(unboundedResult, MAX_SHAKE_VIGOR_DECREASE), MIN_SHAKE_VIGOR_DECREASE);
        return boundedResult;
      }
      function processMouseMove(x, y, t) {
        // Add move to queue
        var currMove = {
          x: x,
          y: y,
          t: t
        }, numMoves = mousePositionsQueue.length, lastMove = numMoves > 0 && mousePositionsQueue[numMoves - 1];
        mousePositionsQueue.push(currMove);
        var shakeVigorPercent, lastDistance = lastMove ? getDistanceBetweenMoves(currMove, lastMove) : 0, shakeVigor = getShakeVigor(numMoves, lastDistance);
        if (shakeVigor !== lastShakeVigor) {
          shakeVigorPercent = Math.round(100 * shakeVigor / MAX_SHAKE_VIGOR);
          fireNotifications(shakeVigorPercent);
          lastShakeVigor = shakeVigor;
          lastShakeVigorPercent = shakeVigorPercent;
        }
        // Shift oldest item out of moves queue
        if (lastMove && numMoves > MOUSE_POSITIONS_ARRAY_SIZE) {
          mousePositionsQueue.shift();
        }
      }
      function onMouseMove(evt) {
        var x = evt.screenX, y = evt.screenY, t = evt.timeStamp, numMoves = mousePositionsQueue.length, lastMove = numMoves > 0 && mousePositionsQueue[numMoves - 1];
        if (lastMove && t - lastMove.t > MAX_TIME_BETWEEN_MOVES) {
          mousePositionsQueue = [];
        }
        nativeGlobal.setTimeout(function() {
          processMouseMove(x, y, t);
        }, 0);
      }
      // Rough approximation for faster math
      function getDistanceBetweenMoves(move1, move2) {
        return Math.abs(move2.x - move1.x) + Math.abs(move2.y - move1.y);
      }
      function getShakeVigor(numMoves, lastDistance) {
        var shakeVigor, isShakeIncreaseAllowed = numMoves >= MOUSE_POSITIONS_ARRAY_SIZE && (lastShakeVigor || lastDistance >= MIN_MOVE_SIZE_FOR_SHAKE), shakeVigorIncrease = isShakeIncreaseAllowed && getShakeVigorIncrease(), shakeVigorDelta = shakeVigorIncrease || -getShakeVigorDecrease(lastDistance);
        shakeVigor = lastShakeVigor + shakeVigorDelta;
        if (shakeVigor < 0) {
          return 0;
        } else {
          if (shakeVigor > MAX_SHAKE_VIGOR) {
            return MAX_SHAKE_VIGOR;
          }
        }
        return Math.floor(shakeVigor);
      }
      function fireNotifications(shakeVigorPercent) {
        // Internal change event
        // TODO add back once we use it
        // if (!lastShakeTimeout) {
        // lastShakeTimeout = nativeGlobal.setTimeout(function() {
        //   fireShakeVigorChange(shakeVigorPercent);
        // }, constants.MS_BETWEEN_SHAKE_EVENTS);
        // }
        // Debugging
        // Too noisy for main build
        // if (SC_DEV) {
        //   console.log('Shake value: ' + shakeVigorPercent);
        // }
        // Metric
        // Fires only when it goes over the threshold, to limit network requests
        if (shakeVigorPercent >= METRIC_THRESHOLD_SHAKE_PERCENT_FIRE && canFireMetricAgain) {
          canFireMetricAgain = false;
          nativeGlobal.setTimeout(function() {
            fireShakeVigorMetric(shakeVigorPercent);
          }, 0);
        } else {
          if (shakeVigorPercent < METRIC_THRESHOLD_SHAKE_PERCENT_RESET) {
            canFireMetricAgain = true;
          }
        }
      }
      function fireShakeVigorMetric(shakeVigorPercent) {
        var details = {
          vigor: shakeVigorPercent,
          sessionCount: incrementSessionShakes()
        };
        if (true) {
          console.log("Mouse shake metric fired: ", JSON.stringify(details));
        }
        new metric.MouseShake(details).send();
      }
      function incrementSessionShakes() {
        if (!platform.isStorageUnsupported) {
          var numShakes = sessionStorage.getItem(constants.SESSION_SHAKE_COUNT_KEY) || 0;
          ++numShakes;
          sessionStorage.setItem(constants.SESSION_SHAKE_COUNT_KEY, numShakes);
          return numShakes;
        }
      }
      // Add back once we use it
      // function fireShakeVigorChange(shakeVigorPercent) {
      //   lastShakeTimeout = 0;
      //   events.emit('run/mouseshake', shakeVigorPercent);
      // }
      function init() {
        domEvents.on(document, "mousemove", onMouseMove);
        domEvents.on(document, "mouseleave", onMouseLeave);
      }
      return {
        init: init
      };
    }(run_metric_metric, run_dom_events, run_shake_constants, run_platform, mini_core_native_global);
    run_run = function(Promise, pref, id, site, urls, exports, locale, metric, platform, bp, CORE_CONST, events, domEvents, modifierKeyState, abTest, shake, inlineStyle) {
      var areZoomEnhancementsInitialized, isZoomInitialized, isSpeechInitialized, isZoomOn, isSpeechOn, isKeyReleased, isKeyHandlingInitialized, wasSitecuesEverOn, startSitecuesLoad, isSitecuesOn = false, // Keys that can init sitecues
      INIT_CODES = CORE_CONST.INIT_CODES, // Enums for sitecues loading states
      state = CORE_CONST.READY_STATE;
      function performInitialLoadZoom(initialZoom) {
        !function(zoomMod) {
          zoomMod.init();
          zoomMod.performInitialLoadZoom(initialZoom);
        }(page_zoom_zoom);
      }
      function initZoomEnhancingFeatures() {
        !function(hpan, positioner, focus, cursor) {
          hpan.init();
          positioner.initFromZoom();
          focus.init();
          cursor.init();
        }(page_hpan_hpan, page_positioner_positioner, page_focus_focus, page_cursor_cursor);
      }
      function initSpeech() {
        !function(page, audio) {
          page.init();
          audio.init();
        }(audio_audio, page_page);
      }
      function initSitecuesOn() {
        !function(page, highlight, keys, moveKeys) {
          page.init();
          highlight.init();
          keys.init();
          moveKeys.init();
        }(page_page, page_highlight_highlight, page_keys_keys, page_highlight_move_keys);
      }
      function initThemes() {
        !function(page, theme, focus, keys) {
          page.init();
          theme.init();
          focus.init();
          keys.init();
        }(page_page, theme_theme, page_focus_focus, page_keys_keys);
      }
      function initMouse() {
        !function(page, cursor, keys) {
          page.init();
          cursor.init();
          keys.init();
        }(page_page, page_cursor_cursor, page_keys_keys);
      }
      // Init features that require *either* zoom or speech to be on
      function onFeatureSettingChange() {
        var isOn = isZoomOn || isSpeechOn;
        if (isOn !== isSitecuesOn) {
          isSitecuesOn = isOn;
          events.emit("sitecues/did-toggle", isSitecuesOn);
        }
        if (isOn && !wasSitecuesEverOn) {
          initSitecuesOn();
          wasSitecuesEverOn = true;
        }
      }
      function onZoomChange(zoomLevel) {
        isZoomOn = zoomLevel > 1;
        onFeatureSettingChange();
        if (isZoomOn && !areZoomEnhancementsInitialized) {
          initZoomEnhancingFeatures();
          areZoomEnhancementsInitialized = true;
        }
      }
      function firePageVisitedMetric() {
        var initDetails = {
          startSitecuesLoad: startSitecuesLoad,
          startSitecuesInteractive: getCurrentTime(),
          // TODO These should be moved into the page-visited metric that moved to the minicore
          // startPageLoad: performance.timing.responseEnd - fetchStartTime,
          // startPageInteractive: performance.timing.domInteractive - fetchStartTime,
          nativeZoom: platform.nativeZoom,
          isRetina: platform.isRetina(),
          isStorageUnsupported: platform.isStorageUnsupported
        };
        new metric.SitecuesReady(initDetails).send();
      }
      function getCurrentTime() {
        return Math.floor(performance.now());
      }
      function onSitecuesReady() {
        firePageVisitedMetric();
        sitecues.readyState = state.COMPLETE;
        //Freeze readyState on load
        Object.defineProperty(sitecues, "readyState", {
          writable: false
        });
        if ("function" === typeof sitecues.onReady) {
          sitecues.onReady.call(sitecues);
        }
        Object.defineProperty(sitecues, "readyState", {
          writable: false
        });
        // Do not allow reassignment, e.g. sitecues.readyState = 0;
        createPageCssHook();
      }
      // Page can make any special badge callouts visible when data-sitecues-active="desktop"
      function createPageCssHook() {
        document.documentElement.setAttribute("data-sitecues-active", "desktop");
      }
      // Initialize page feature listeners
      // This means: if a setting or event changes that requires some modules, we load and initialize the modules
      function initPageFeatureListeners() {
        // -- Zoom --
        // Previously saved values
        var initialZoom = pref.get("zoom");
        if (initialZoom > 1) {
          performInitialLoadZoom(initialZoom);
        }
        // Monitor any runtime changes
        events.on("zoom", onZoomChange);
        // -- Speech --
        pref.bindListener("ttsOn", function(isOn) {
          isSpeechOn = isOn;
          onFeatureSettingChange();
          if (isOn && !isSpeechInitialized) {
            initSpeech();
            isSpeechInitialized = true;
          }
        });
        // -- Themes --
        if (platform.featureSupport.themes) {
          pref.bindListener("themeName", function(themeName) {
            if (themeName) {
              initThemes();
            }
          });
        }
        // -- Mouse --
        pref.bindListener("mouseSize", function(mouseSize) {
          if (mouseSize) {
            // If undefined we use the default as set by the zoom module
            initMouse();
          }
        });
        pref.bindListener("mouseHue", function(mouseHue) {
          if (mouseHue <= 1) {
            // if undefined || > 1, mouse hue is ignored, and we keep the default mouse hue
            initMouse();
          }
        });
        // -- Keys --
        // Init keys module if sitecues was off but key is pressed that might turn it on
        if (!isKeyHandlingInitialized) {
          // Keys are not be initialized, therefore,
          // we add our lightweight keyboard listener that only
          // checks for a few keys like  +, - or alt+'
          window.addEventListener("keydown", onPossibleTriggerKeyPress);
        }
        if (!isZoomInitialized) {
          window.addEventListener("wheel", onPossibleScreenPinch);
        }
        modifierKeyState.init();
        shake.init();
        onSitecuesReady();
      }
      function isInitializerKey(event) {
        var keyCode = event.keyCode;
        return INIT_CODES.indexOf(keyCode) >= 0;
      }
      // Check for keys that can trigger sitecues, such as cmd+, cmd-, alt+'
      function onPossibleTriggerKeyPress(event) {
        if (isInitializerKey(event)) {
          if (event.ctrlKey || event.metaKey || event.altKey) {
            // Don't allow default behavior of modified key, e.g. native zoom
            event.preventDefault();
            event.stopImmediatePropagation();
          }
          isKeyReleased = false;
          window.addEventListener("keyup", onKeyUp);
          !function(keys) {
            keys.init(event, isKeyReleased);
          }(page_keys_keys);
        }
      }
      // Ctrl + wheel events (screen pinch) can trigger sitecues
      function onPossibleScreenPinch(event) {
        if (event.ctrlKey) {
          // Don't allow default behavior of screen pinch, e.g. native zoom
          event.preventDefault();
          event.stopImmediatePropagation();
          !function(zoomMod) {
            // TODO IE11: TypeError: Unable to get property 'init' of undefined or null reference
            // {"eventId":"10e771ce-97a8-4d53-985a-c4912485032a","serverTs":1463756071982,"clientIp":"10.235.39.83","siteKey":"s-0000ee0c","isTest":false,"userId":null,"clientData":{"scVersion":"4.0.73-RELEASE","metricVersion":12,"sessionId":"5fd5d275-5204-4e45-af83-c134e3c7bce8","pageViewId":"ceb79818-a1bf-47ec-8b3e-6b3419796adc","siteId":"s-0000ee0c","userId":"6f90e948-9980-4e19-87e0-9ec50958db05","pageUrl":"https://www.eeoc.gov/eeoc/publications/ada-leave.cfm","browserUserAgent":"Mozilla/5.0 (Windows NT 6.1; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET CLR 1.1.4322; InfoPath.3; .NET4.0C; .NET4.0E; Tablet PC 2.0; rv:11.0) like Gecko","isClassicMode":false,"clientLanguage":"en-US","source":"page","isTester":false,"name":"error","clientTimeMs":1463756071497,"zoomLevel":1,"ttsState":false,"details":{"message":"Unable to get property 'init' of undefined or null reference","stack":"TypeError: Unable to get property 'init' of undefined or null reference\n   at Anonymous function (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:128:442)\n   at W (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:8:256)\n   at O (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:9:31)\n   at Anonymous function (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:10:28)\n   at k (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:20:460)\n   at Anonymous function (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:21:72)\n   at Anonymous function (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:19:226)\n   at Anonymous function (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:19:204)\n   at a (https://js.sitecues.com/l/s;id=s-0000ee0c/js/sitecues.js:19:94)"}}}
            zoomMod.init(event);
          }(page_zoom_zoom);
        }
      }
      function onKeyUp(event) {
        if (isInitializerKey(event)) {
          isKeyReleased = true;
        }
      }
      function onZoomInitialized() {
        isZoomInitialized = true;
        window.removeEventListener("wheel", onPossibleScreenPinch);
      }
      function onKeyHandlingInitialized() {
        isKeyHandlingInitialized = true;
        window.removeEventListener("keydown", onPossibleTriggerKeyPress);
        window.removeEventListener("keyup", onKeyUp);
      }
      function isOn() {
        return isSitecuesOn;
      }
      function init() {
        if (true) {
          console.log("Initializing Sitecues");
        }
        startSitecuesLoad = getCurrentTime();
        // When keyboard listening is ready
        events.on("keys/did-init", onKeyHandlingInitialized);
        events.on("zoom/ready", onZoomInitialized);
        // Set sitecues state flag to initializing
        sitecues.readyState = state.INITIALIZING;
        // Early synchronous initialization
        site.init();
        // Site configuration module
        urls.init();
        // API and services URLs
        platform.init();
        // Info about current platform, init now in case we need for error metric
        exports.init(isOn);
        // Sitecues exports
        Promise.all([ // TODO how can these be init'd at the same time if they both need the global storage iframe?
        id.init(), pref.init() ]).then(function() {
          // Synchronous initialization
          abTest.init();
          metric.init();
          inlineStyle.init();
          // Inline style utility
          domEvents.init();
        }).then(function() {
          return locale.init().then(bp.init).then(metric.initViewInfo).then(initPageFeatureListeners);
        });
      }
      init();
      // DO EET NOW !!
      return exports;
    }(Promise, run_conf_preferences, run_conf_id, run_conf_site, run_conf_urls, run_exports, run_locale, run_metric_metric, run_platform, run_bp_bp, run_constants, run_events, run_dom_events, run_modifier_key_state, run_ab_test_ab_test, run_shake_shake, run_inline_style_inline_style);
    page_zoom_constants = function() {
      var constants = {};
      constants.MS_PER_X_ZOOM_GLIDE = 1400;
      // For animations, the number of milliseconds per unit of zoom (e.g. from 1x to 2x)
      constants.MS_PER_X_ZOOM_SLIDER = 500;
      // For click in slider
      constants.ZOOM_PRECISION = 3;
      // Decimal places allowed
      constants.KEYFRAMES_ID = "sc-keyframes-zoom";
      constants.ZOOM_TARGETS_ID = "sc-zoom-targets";
      constants.ANIMATION_END_EVENTS = "animationend webkitAnimationEnd MSAnimationEnd";
      constants.MIN_RECT_SIDE = 4;
      constants.ANIMATION_OPTIMIZATION_SETUP_DELAY = 20;
      // Provide extra time to set up compositor layer if a key is pressed
      constants.CLEAR_ANIMATION_OPTIMIZATION_DELAY = 7e3;
      // After zoom, clear the will-change property if no new zoom occurs within this amount of time
      constants.UNPINCH_END_DELAY = 150;
      constants.REPAINT_FOR_CRISP_TEXT_DELAY = 100;
      // This is conjured out of thin air. Just seems to work.
      constants.CRISPING_ATTRIBUTE = "data-sc-crisp";
      constants.ZOOM_TARGET_ATTR = "data-sc-zoom-target";
      constants.ZOOM_TARGET_SELECTOR = "[" + constants.ZOOM_TARGET_ATTR + "]";
      constants.ZOOM_TARGET_ID = "sitecues-zoom-targets";
      constants.SITECUES_ZOOM_ID = "sitecues-js-zoom";
      constants.SITECUES_ZOOM_FORMS_ID = "sitecues-js-zoom-form-fix";
      constants.UNPINCH_FACTOR = .015;
      // How much the unpinch delta affects zoom
      constants.MAX_ZOOM = 3;
      constants.MIN_ZOOM = 1;
      constants.ZOOM_STEP = .01;
      constants.MIN_ZOOM_PER_CLICK = .2;
      // Change zoom at least this amount if user clicks on A button or presses +/- or left/right in slider
      constants.ZOOM_RANGE = constants.MAX_ZOOM - constants.MIN_ZOOM;
      constants.GLIDE_CHANGE_INTERVAL_MS = 30;
      // How often to call back with a new zoom value
      return constants;
    }();
    bp_expanded_view_slider = function(BP_CONST, state, helper, locale) {
      /*
   *** Public methods ***
   */
      /**
   * Reposition the zoom slider thumb on badge-panel state change or thumb change callback.
   * This does not change the current zoom of the page -- it only changes the slider appearance.
   */
      function updateThumbPosition(currZoom) {
        var thumbId = BP_CONST.ZOOM_SLIDER_THUMB_ID, thumbElement = helper.byId(thumbId), panelSliderWidth = BP_CONST.TRANSFORMS.PANEL[thumbId].translateX, badgeSliderWidth = BP_CONST.TRANSFORMS.BADGE[thumbId].translateX, isPanel = state.isPanel(), MIN_ZOOM = 1, ZOOM_RANGE = 2, // Use a fake zoom amount the first time sitecues loads for badge view
        // It just looks better -- making the slider look more interactive.
        percent = (currZoom - MIN_ZOOM) / ZOOM_RANGE, sliderWidth = isPanel ? BP_CONST.LARGE_SLIDER_WIDTH : BP_CONST.SMALL_SLIDER_WIDTH, offset = percent * sliderWidth + (isPanel ? panelSliderWidth : badgeSliderWidth);
        thumbElement.setAttribute("transform", "translate(" + offset + ")");
      }
      // Update the slider thumb position on bp view updates because the entire slider changes size
      // (it scales more horizontally than vertically)
      function render(zoomLevel) {
        updateThumbPosition(zoomLevel);
        updateZoomValue(zoomLevel);
      }
      /*
    Display new zoom value.
   */
      function updateZoomValue(currZoom) {
        // 1. Set aria-valuenow for screen readers
        // We do this when zoom is finished so that the screen reader is not trying to read every
        // new value during an animation which would be way too verbose
        var sliderElement = helper.byId(BP_CONST.ZOOM_SLIDER_BAR_ID), roundedZoom = currZoom ? Math.floor(10 * (currZoom + .0999)) / 10 : 1, zoomText = getLocalizedZoomValue(roundedZoom);
        sliderElement.setAttribute("aria-valuenow", roundedZoom ? roundedZoom.toString() : 1);
        sliderElement.setAttribute("aria-valuetext", zoomText);
        // 2. Update the zoom label, which follows pattern "1.3x" (or just "Zoom off" for 1x)
        function setZoomLabel(text) {
          helper.byId(BP_CONST.ZOOM_VALUE_ID).firstChild.data = text;
        }
        setZoomLabel(zoomText);
      }
      /*
   *** Private functions ***
   */
      function getLocalizedZoomValue(currZoom) {
        if (1 === currZoom) {
          // Zoom off
          return locale.translate(BP_CONST.ZOOM_STATE_LABELS.ZOOM_OFF);
        }
        // 1.3x, etc.
        var preZoomText = locale.translate(BP_CONST.ZOOM_STATE_LABELS.PRE_ZOOM), postZoomText = locale.translate(BP_CONST.ZOOM_STATE_LABELS.POST_ZOOM);
        return preZoomText + locale.translateNumber(currZoom, 2) + postZoomText;
      }
      return {
        updateThumbPosition: updateThumbPosition,
        render: render,
        updateZoomValue: updateZoomValue
      };
    }(run_bp_constants, run_bp_model_state, run_bp_helper, run_locale);
    run_errors = function() {
      function noop() {}
      return {
        report: noop
      };
    }();
    page_util_element_classifier = function() {
      function hasMatchingTag(tags, element) {
        return tags.hasOwnProperty(element.localName);
      }
      /**
   * Checks if the element has media contents which can be rendered.
   */
      var VISUAL_MEDIA_ELEMENTS = {
        img: 1,
        picture: 1,
        canvas: 1,
        video: 1,
        embed: 1,
        object: 1,
        iframe: 1,
        frame: 1,
        audio: 1
      };
      function isVisualMedia(element) {
        return hasMatchingTag(VISUAL_MEDIA_ELEMENTS, element);
      }
      /**
   * Checks if the element is a form control
   */
      var FORM_ELEMENTS = {
        input: 1,
        textarea: 1,
        select: 1,
        button: 1
      };
      function isFormControl(element) {
        return hasMatchingTag(FORM_ELEMENTS, element);
      }
      /**
   * Returns true if the element may use spacebar presses for its own purposes when focused.
   * For example, a video is likely to use spacebar to pause/play the video, and an input
   * uses the spacebar to insert spaces into the text.
   * @param selector
   * @returns {*|boolean}
   */
      // Define set of elements that need the spacebar but are not editable
      var NON_EDITABLE_SPACEBAR_ELEMENTS = {
        video: 1,
        embed: 1,
        object: 1,
        iframe: 1,
        frame: 1,
        audio: 1,
        button: 1,
        input: 1,
        select: 1
      };
      function isSpacebarConsumer(eventTarget) {
        // Added because window somehow came in here sometimes, causing exception
        return eventTarget.nodeType === Node.ELEMENT_NODE && hasMatchingTag(NON_EDITABLE_SPACEBAR_ELEMENTS, eventTarget) || eventTarget.hasAttribute("tabindex") || eventTarget.hasAttribute("onkeypress") || eventTarget.hasAttribute("onkeydown") || isEditable(eventTarget);
      }
      function isContentEditable(element) {
        var contentEditable = element.getAttribute("contenteditable");
        return "string" === typeof contentEditable && "false" !== contentEditable;
      }
      /**
   * Is the current element editable for any reason???
   * @param element
   * @returns {boolean} True if editable
   */
      var EDITABLE_INPUT_TYPES = [ "text", "email", "password", "search", "tel", "url", "color", "date", "datetime", "datetime-local", "month", "number", "time", "week" ];
      function isEditable(element) {
        if ("input" === element.localName) {
          var type = element.getAttribute("type");
          // A non-specified type attribute defaults to 'text', an editable element
          return !type || EDITABLE_INPUT_TYPES.indexOf(type.toLowerCase()) >= 0;
        }
        return "on" === document.designMode || "textarea" === element.localName || isContentEditable(element);
      }
      return {
        isVisualMedia: isVisualMedia,
        isFormControl: isFormControl,
        isSpacebarConsumer: isSpacebarConsumer,
        isEditable: isEditable
      };
    }();
    page_util_common = function(elemClassifier, inlineStyle) {
      function isTransparentColor(color) {
        // NOTE: Doesn't check HSLA colors for transparency
        return "transparent" === color || color.match(/^rgba.*0\)$/);
      }
      /**
   * @private
   */
      function isNonEmptyTextNode(node) {
        return node.nodeType === Node.TEXT_NODE && !isWhitespaceOrPunct(node);
      }
      function hasBorder(style) {
        return parseFloat(style.borderRightWidth) || parseFloat(style.borderBottomWidth);
      }
      /**
   * Checks if the text in a text node given has any characters that appear as text.
   * The picker uses this to determine if a text node has content worth highlighting --
   * we require at least one letter or number as punctuation marks are often used as decorative separators.
   * We use unicode ranges to ensure that characters from foreign alphabets are included,
   * otherwise the picker will not pick text from languages with non-roman alphabets.
   * This is a close approximation to that -- we kept the regex simple and the number of ranges smaller;
   * there may be some very rare characters where the regex is not perfect. That should generally be
   * ok, because it only needs one word character in a text node to make it pickable.
   */
      function isWhitespaceOrPunct(textNode) {
        var val = textNode.data, WORD_PATTERN = /[\w\u0100-\u024f\u0370-\u1fff\u2e80-\ufeff]/;
        return !val || !WORD_PATTERN.test(val);
      }
      // Return true if there is a visual sub-box of content
      function isVisualRegion(element, style, parentStyle) {
        if (element === document.documentElement || element === document.body) {
          return false;
        }
        var isVisRegion = hasBorder(style) || hasRaisedZIndex(style, parentStyle) || hasOwnBackground(element, style, parentStyle);
        return Boolean(isVisRegion);
      }
      function hasRaisedZIndex(style, parentStyle) {
        return parseFloat(style.zIndex) > parseFloat(parentStyle.zIndex);
      }
      function isSprite(style) {
        var coor = style.backgroundPosition.split(" ");
        return "none" !== style.backgroundImage && ("no-repeat" === style.backgroundRepeat || 0 === parseFloat(coor[0]) || 0 === parseFloat(coor[1]));
      }
      //TODO: Consider refactoring signature to take just the element as a parameter
      function hasOwnBackground(elem, style, parentStyle) {
        if (!style) {
          return false;
        }
        // 1. Background images (sprites don't count -- often used for things like bullets)
        if ("none" !== style.backgroundImage && !isSprite(style)) {
          return true;
        }
        // 2. Background colors
        return hasOwnBackgroundColor(elem, style, parentStyle);
      }
      function hasOwnBackgroundColor(elem, style, parentStyle) {
        var bgColor = style.backgroundColor;
        if (parentStyle && !isTransparentColor(bgColor)) {
          var parent = elem.parentNode;
          while (isTransparentColor(parentStyle.backgroundColor)) {
            if (parent === document.documentElement) {
              // Only transparent colors above = treated as white
              // Therefore current opaque bg is only treated as different if it's not white
              return "rgb(255, 255, 255)" !== bgColor;
            }
            parent = parent.parentNode;
            parentStyle = getComputedStyle(parent);
          }
          return parentStyle.backgroundColor !== bgColor;
        }
        return false;
      }
      function hasVisibleContent(current) {
        var children, index, numChildrenToCheck, MAX_CHILDREN_TO_CHECK = 10;
        if (elemClassifier.isVisualMedia(current) || elemClassifier.isFormControl(current)) {
          var mediaRect = current.getBoundingClientRect(), MIN_RECT_SIDE = 5;
          return mediaRect.width >= MIN_RECT_SIDE && mediaRect.height >= MIN_RECT_SIDE;
        }
        // Check to see if there are non-empty child text nodes.
        // If there are, we say we're not over whitespace.
        children = current.childNodes;
        // Shortcut: could not have text children because all children are elements
        if (current.childElementCount === children.length) {
          return false;
        }
        numChildrenToCheck = Math.min(children.length, MAX_CHILDREN_TO_CHECK);
        // Longer check: see if any children are non-empty text nodes, one by one
        for (index = 0; index < numChildrenToCheck; index++) {
          if (isNonEmptyTextNode(children[index])) {
            return true;
          }
        }
        return false;
      }
      /*
   * Check if current image value is not empty.
   * @imageValue A string that represents current image value.
   * @return true if image value contains some not-empty value.
   */
      function isEmptyBgImage(imageValue) {
        return !imageValue || "none" === imageValue;
      }
      /**
   * Create an SVG fragment for insertion into a web page -- ordinary methods don't work.
   * See http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element
   */
      function createSVGFragment(svgMarkup, className) {
        var temp = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
        temp.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="' + className + '">' + svgMarkup + "</svg>";
        var frag = document.createDocumentFragment();
        var child = temp.firstChild;
        while (child) {
          frag.appendChild(child);
          child = child.nextSibling;
        }
        return frag;
      }
      /*
   * A version of elementFromPoint() that restricts the point to the viewport
   */
      function elementFromPoint(x, y) {
        var maxX = innerWidth - 1, maxY = innerHeight - 1;
        x = Math.min(maxX, Math.max(0, x));
        y = Math.min(maxY, Math.max(0, y));
        return document.elementFromPoint(x, y);
      }
      /**
   * Defines if the element given contains vertical scroll.
   * @param el HTMLObject
   */
      function hasVertScroll(el) {
        return el.clientHeight < el.scrollHeight;
      }
      function getBulletWidth(listElement, style) {
        var MONOSPACE_BULLET_TYPES = {
          circle: 1,
          square: 1,
          disc: 1,
          none: 1
        }, bulletType = style.listStyleType, ems = 2.5;
        // Browsers seem to use max of 2.5 em for bullet width -- use as a default
        if (MONOSPACE_BULLET_TYPES.hasOwnProperty(bulletType)) {
          ems = 1.6;
        } else {
          if ("decimal" === bulletType) {
            var start = parseInt(listElement.getAttribute("start"), 10), end = (start || 1) + listElement.childElementCount - 1;
            ems = .9 + .5 * end.toString().length;
          }
        }
        return getEmsToPx(style.fontSize, ems);
      }
      function getEmsToPx(fontSize, ems) {
        // Create a div to measure the number of px in an em with this font-size
        var px, measureDiv = document.createElement("div");
        document.body.appendChild(measureDiv);
        inlineStyle.set(measureDiv, {
          fontSize: fontSize,
          width: ems + "em",
          visibility: "hidden"
        });
        // Multiply by zoom because our <div> is not affected by the document's current zoom level
        px = measureDiv.clientWidth;
        document.body.removeChild(measureDiv);
        return px;
      }
      function getComputedScale(elem) {
        var style = getComputedStyle(elem), transform = style.transform;
        return parseFloat(transform.substring(7)) || 1;
      }
      return {
        isWhitespaceOrPunct: isWhitespaceOrPunct,
        isVisualRegion: isVisualRegion,
        hasRaisedZIndex: hasRaisedZIndex,
        isSprite: isSprite,
        hasOwnBackground: hasOwnBackground,
        hasOwnBackgroundColor: hasOwnBackgroundColor,
        hasVisibleContent: hasVisibleContent,
        isEmptyBgImage: isEmptyBgImage,
        createSVGFragment: createSVGFragment,
        elementFromPoint: elementFromPoint,
        hasVertScroll: hasVertScroll,
        getBulletWidth: getBulletWidth,
        getEmsToPx: getEmsToPx,
        getComputedScale: getComputedScale
      };
    }(page_util_element_classifier, run_inline_style_inline_style);
    page_zoom_state = function() {
      var state = {
        completedZoom: 1,
        // Current zoom as of the last finished operation
        fixedZoom: 1,
        // Restricted zoom for fixed elements
        currentTargetZoom: 1,
        // Zoom we are aiming for in the current operation
        startZoomTime: 0,
        // If no current zoom operation, this is cleared (0 or undefined)
        isInitialLoadZoom: false,
        // Is this the initial zoom for page load? (The one based on previous user settings)
        hasFormsToFix: null,
        zoomInput: {}
      };
      Object.defineProperties(state, {
        // How many milliseconds have elapsed since the start of the zoom operation?
        elapsedZoomTime: {
          enumerable: true,
          get: function() {
            if (state.startZoomTime) {
              return Date.now() - state.startZoomTime;
            }
            return 0;
          }
        }
      });
      return state;
    }();
    page_zoom_config_config = function($, site) {
      var // Default zoom configuration
      config = {
        // Can be customized via provideCustomConfig()
        // Should smooth zoom animations be enabled?
        provideCustomZoomConfig: provideCustomZoomConfig,
        init: init
      };
      Object.defineProperties(config, {
        shouldRestrictWidth: {
          enumerable: true,
          get: function() {
            return config.isFluid;
          }
        }
      });
      // Allow customization of zoom configuration on a per-website basis
      function provideCustomZoomConfig(customZoomConfig) {
        $.extend(config, customZoomConfig);
      }
      function init() {
        $.extend(config, {
          // Does the web page use a fluid layout, where content wraps to the width?
          isFluid: site.get("isFluid"),
          // Can override in site preferences
          // Should the width of the page be restricted as zoom increases?
          // This is helpful for pages that try to word-wrap or use a fluid layout.
          // Eventually use fast page health calculation to automatically determine this
          // Assumes window width of 1440 (maximized screen on macbook)
          maxZoomToRestrictWidthIfFluid: site.get("maxRewrapZoom") || 1.5,
          // Set to 5 on sites where the words get too close to the left window's edge
          leftMarginOffset: site.get("leftMarginOffset") || 2,
          // Visible content containers for understanding left margin of page, or undefined to auto-detect,
          // The first one found will be used to determine the body's geometry.
          // e.g. '#pageWrapper, body>table'
          visibleRoots: site.get("visibleRoots")
        });
      }
      return config;
    }($, run_conf_site);
    page_viewport_viewport = function(domEvents) {
      var refreshFlags = {}, cachedWindowValues = {};
      function getWindowProperty(property) {
        if ("undefined" === typeof cachedWindowValues[property] || refreshFlags[property]) {
          cachedWindowValues[property] = window[property];
          refreshFlags[property] = false;
        }
        return cachedWindowValues[property];
      }
      function getPageXOffset() {
        return getWindowProperty("pageXOffset");
      }
      function getPageYOffset() {
        return getWindowProperty("pageYOffset");
      }
      function getInnerWidth() {
        return getWindowProperty("innerWidth");
      }
      function getInnerHeight() {
        return getWindowProperty("innerHeight");
      }
      function getOuterWidth() {
        return getWindowProperty("outerWidth");
      }
      function getOuterHeight() {
        return getWindowProperty("outerHeight");
      }
      function getPageOffsets() {
        return {
          x: getPageXOffset(),
          y: getPageYOffset()
        };
      }
      function getInnerDimensions() {
        return {
          width: getInnerWidth(),
          height: getInnerHeight()
        };
      }
      function getOuterDimensions() {
        return {
          width: getOuterWidth(),
          height: getOuterHeight()
        };
      }
      // After the user's initial zoom we need to realign any location hash target to the top of the screen
      function jumpToLocationHash() {
        var hash = location.hash, EXTRA_SPACE_SCROLL_TOP = 60;
        if (!hash) {
          return;
        }
        try {
          // Not all ids are necessarily valid -- protect against that
          var elem = document.querySelector(hash + ',[name="' + hash.substring(1) + '"]');
          if (elem) {
            elem.scrollIntoView(true);
            window.scrollBy(0, -EXTRA_SPACE_SCROLL_TOP);
          }
        } catch (ex) {}
      }
      function init() {
        domEvents.on(window, "scroll", function() {
          refreshFlags.pageXOffset = true;
          refreshFlags.pageYOffset = true;
        });
        domEvents.on(window, "resize", function() {
          cachedWindowValues = {};
        });
      }
      return {
        getPageOffsets: getPageOffsets,
        getPageXOffset: getPageXOffset,
        getPageYOffset: getPageYOffset,
        getInnerDimensions: getInnerDimensions,
        getInnerWidth: getInnerWidth,
        getInnerHeight: getInnerHeight,
        getOuterDimensions: getOuterDimensions,
        getOuterWidth: getOuterWidth,
        getOuterHeight: getOuterHeight,
        jumpToLocationHash: jumpToLocationHash,
        init: init
      };
    }(run_dom_events);
    page_zoom_util_restrict_zoom = function(constants, config) {
      var MAX_FIXED_ZOOM = 1.8, MAX = constants.MAX_ZOOM, MIN = constants.MIN_ZOOM, ZOOM_PRECISION = constants.ZOOM_PRECISION;
      // Make sure the zoom value is within the min and max, and does not use more decimal places than we allow
      function toValidRange(value) {
        value = parseFloat(value);
        // value is too small
        if (!value || value < MIN) {
          return MIN;
        }
        // value is too big
        if (value > MAX) {
          return MAX;
        }
        // value have float value
        return parseFloat(value.toFixed(ZOOM_PRECISION));
      }
      // This is the zoom that we will still restrict the width
      function forFluidWidth(currZoom) {
        // Adjust max zoom for width restrictions for current window width
        // The max zoom for width restriction is set for a specific size of window
        // We use a maximized window on a MacBook pro retina screen (1440px wide)
        // The default is to restrict width up to a max of 1.35x zoom
        // If the user's window is 75% of the 1440px, we multiply the max zoom by .75
        var maxZoomToRestrictWidth = Math.max(1, config.maxZoomToRestrictWidthIfFluid * (window.innerWidth / 1440));
        return Math.min(currZoom, maxZoomToRestrictWidth);
      }
      function forFixedZoomTarget(completedZoom) {
        return Math.min(MAX_FIXED_ZOOM, completedZoom);
      }
      return {
        toValidRange: toValidRange,
        forFluidWidth: forFluidWidth,
        forFixedZoomTarget: forFixedZoomTarget
      };
    }(page_zoom_constants, page_zoom_config_config);
    page_zoom_util_body_geometry = function($, common, config, constants, state, restrictZoom, viewport, domEvents, events, inlineStyle) {
      var body, $origBody, docElem, doDebugVisibleRects, originalBodyInfo, // The info we have on the body, including the rect and mainNode
      currentBodyInfo, isInitialized = false, callbacks = [], cachedDocumentScrollWidth = null, cachedDocumentScrollHeight = null, MIN_RECT_SIDE = constants.MIN_RECT_SIDE, ZOOM_PRECISION = constants.ZOOM_PRECISION;
      // This is the body's currently visible width, with zoom factored in
      function getBodyWidth() {
        // Use the originally measured visible body width
        init();
        // If width was restricted
        var divisorUsedToRestrictWidth = config.shouldRestrictWidth ? restrictZoom.forFluidWidth(state.completedZoom) : 1;
        // Multiply be the amount of zoom currently used
        return state.completedZoom * originalBodyInfo.width / divisorUsedToRestrictWidth;
      }
      function getBodyRight() {
        init();
        return originalBodyInfo.right * state.completedZoom;
      }
      function getBodyLeft() {
        init();
        return originalBodyInfo.leftMostNode.getBoundingClientRect().left + viewport.getPageXOffset();
      }
      function getMainNode() {
        init();
        return originalBodyInfo.mainNode;
      }
      // Is it a fluid layout?
      function isFluidLayout() {
        if (originalBodyInfo.width === viewport.getOuterWidth()) {
          // Handle basic case -- this works for duxburysystems.com, where the visible body content
          // spans the entire width of the available space
          return true;
        }
        // We consider it fluid if the main node we discovered inside the body changes width
        // if we change the body's width.
        var newWidth, isFluid, origWidth = originalBodyInfo.mainNode.clientWidth;
        inlineStyle.override(body, {
          width: viewport.getInnerWidth() / 5 + "px"
        });
        newWidth = originalBodyInfo.mainNode.clientWidth;
        isFluid = origWidth !== newWidth;
        inlineStyle.restore(body, "width");
        return isFluid;
      }
      // Get the rect for visible contents in the body, and the main content node
      function computeBodyInfo() {
        var mainNode, leftMostNode, // Everything else will be smaller
        rightMostNode, bodyInfo = {}, visibleNodes = [], mainNodeRect = {
          width: 0,
          height: 0
        }, leftMostCoord = 9999, rightMostCoord = 0, startNode = $(config.visibleRoots)[0] || body, MIN_WIDTH_MAIN_NODE = 300, bodyStyle = getComputedStyle(body);
        getBodyRectImpl(startNode, bodyInfo, visibleNodes, bodyStyle, true);
        if (!visibleNodes.length) {
          getBodyRectImpl(startNode, bodyInfo, visibleNodes, bodyStyle);
        }
        bodyInfo.width = bodyInfo.right - bodyInfo.left;
        bodyInfo.height = bodyInfo.bottom - bodyInfo.top;
        // Find tallest node
        visibleNodes.forEach(function(node) {
          var rect = node.rect;
          if (rect.height >= mainNodeRect.height && rect.width > MIN_WIDTH_MAIN_NODE) {
            if (rect.height > mainNodeRect.height || rect.width > mainNodeRect.width) {
              mainNodeRect = rect;
              mainNode = node.domNode;
            }
          }
          if (rect.left < leftMostCoord) {
            leftMostNode = node.domNode;
            leftMostCoord = rect.left;
          }
          if (rect.right > rightMostCoord) {
            rightMostNode = node.domNode;
            rightMostCoord = rect.right;
          }
        });
        bodyInfo.mainNode = mainNode || document.body;
        bodyInfo.leftMostNode = leftMostNode;
        bodyInfo.rightMostNode = rightMostNode;
        bodyInfo.transformOriginX = body.getBoundingClientRect().width / 2;
        return bodyInfo;
      }
      function willAddRect(newRect, node, style, parentStyle, isStrict) {
        if (node === document.body) {
          return;
        }
        // Strict checks
        if (isStrict) {
          if (0 === node.childNodes.length || newRect.width < MIN_RECT_SIDE || newRect.height < MIN_RECT_SIDE || // Watch for text-align: center or -webkit-center -- these items mess us up
          style.textAlign.indexOf("center") >= 0) {
            return;
          }
        }
        // Must check
        if (newRect.left < 0 || newRect.top < 0 || "visible" !== style.visibility) {
          return;
        }
        // Good heuristic -- when x > 0 it tends to be a useful rect
        if (newRect.left > 0) {
          return true;
        }
        // newRect.left === 0
        // We usually won't these rectangles flush up against the left margin,
        // but will add them if there are visible children.
        // If we added them all the time we would often have very large left margins.
        // This rule helps get left margin right on duxburysystems.com.
        if ("visible" !== style.overflow || !common.hasVisibleContent(node, style, parentStyle)) {
          return;
        }
        return true;
      }
      // Recursively look at rectangles and add them if they are useful content rectangles
      function getBodyRectImpl(node, sumRect, visibleNodes, parentStyle, isStrict) {
        var newRect = getAbsoluteRect(node), style = getComputedStyle(node);
        if (willAddRect(newRect, node, style, parentStyle, isStrict)) {
          if (doDebugVisibleRects && node.nodeType === Node.ELEMENT_NODE) {
            inlineStyle.set(node, {
              outline: "9px solid rgba(0,255,0,.5)",
              outlineOffset: "-5px"
            });
          }
          addRect(sumRect, newRect);
          visibleNodes.push({
            domNode: node,
            rect: newRect
          });
          return;
        }
        $(node).children().each(function() {
          //For some reason, Edge will run this function despite there not being any element children belonging to the element. Edge...
          //TODO: Remove this conditional if Edge ever gets its act together. Reproducible here: www.njstatelib.org
          //NOTE: Does not reproduce when the console is open. Yeah that was a fun one to figure out
          if (this.nodeType === Node.ELEMENT_NODE) {
            getBodyRectImpl(this, sumRect, visibleNodes, style, isStrict);
          }
        });
      }
      // Add the rectangle to the sum rect if it is visible and has a left margin > 0
      function addRect(sumRect, newRect) {
        if (isNaN(sumRect.left) || newRect.left < sumRect.left) {
          sumRect.left = newRect.left;
        }
        if (isNaN(sumRect.right) || newRect.right > sumRect.right) {
          sumRect.right = newRect.right;
        }
        if (isNaN(sumRect.top) || newRect.top < sumRect.top) {
          sumRect.top = newRect.top;
        }
        if (isNaN(sumRect.bottom) || newRect.bottom > sumRect.bottom) {
          sumRect.bottom = newRect.bottom;
        }
      }
      // Gets the absolute rect of a node
      // Does not use getBoundingClientRect because we need size to include overflow
      function getAbsoluteRect(node) {
        var clientRect = node.getBoundingClientRect(), pageOffsets = viewport.getPageOffsets(), width = clientRect.width, //  Math.max(node.scrollWidth, clientRect.width),
        height = Math.max(node.scrollHeight, clientRect.height), left = clientRect.left + pageOffsets.x, top = clientRect.top + pageOffsets.y;
        return {
          left: left,
          top: top,
          width: width,
          height: height,
          right: left + width,
          bottom: top + height
        };
      }
      // Return a formatted string for translateX as required by CSS
      function getFormattedTranslateX(targetZoom) {
        if (config.shouldRestrictWidth) {
          return "";
        }
        var zoomOriginX = Math.max(viewport.getInnerWidth(), originalBodyInfo.transformOriginX) / 2, // X-coordinate origin of transform
        bodyLeft = originalBodyInfo.left, halfOfBody = (zoomOriginX - bodyLeft) * targetZoom, pixelsOffScreenLeft = halfOfBody - zoomOriginX + config.leftMarginOffset, pixelsToShiftRight = Math.max(0, pixelsOffScreenLeft), translateX = pixelsToShiftRight / targetZoom;
        // Need to shift entire zoom image to the right so that start of body fits on screen
        return "translateX(" + translateX.toFixed(ZOOM_PRECISION) + "px)";
      }
      // Get the desired width of the body for the current level of zoom
      function getRestrictedBodyWidth(currZoom) {
        // For a short period of time, we tried the following, in a commit that suggested it helped reduce horizontal panning.
        // However, that change led to SC-3191
        //var winWidth = originalBodyInfo.width;
        return viewport.getInnerWidth() / restrictZoom.forFluidWidth(currZoom) + "px";
      }
      // Return cached body info or undefined if unknown
      function getOriginalBodyInfo() {
        return originalBodyInfo;
      }
      function getCurrentBodyInfo() {
        if (!currentBodyInfo) {
          currentBodyInfo = computeBodyInfo();
        }
        return currentBodyInfo;
      }
      function invalidateBodyInfo() {
        currentBodyInfo = null;
      }
      function getScrollWidth(isOnResize) {
        if (null === cachedDocumentScrollWidth || isOnResize) {
          cachedDocumentScrollWidth = docElem.scrollWidth;
        }
        return cachedDocumentScrollWidth;
      }
      function getScrollHeight(isOnResize) {
        if (null === cachedDocumentScrollHeight || isOnResize) {
          cachedDocumentScrollHeight = docElem.scrollHeight;
        }
        return cachedDocumentScrollHeight;
      }
      function refreshOriginalBodyInfo() {
        originalBodyInfo = computeBodyInfo();
        currentBodyInfo = originalBodyInfo;
      }
      function executeCallbacks() {
        callbacks.forEach(function(callback) {
          callback();
        });
        callbacks = [];
      }
      // Scroll content to maximize the use of screen real estate, showing as much content as possible.
      // In effect, stretch the bottom-right corner of the visible content down and/or right
      // to meet the bottom-right corner of the window.
      function maximizeContentVisibility() {
        var bodyRight = getOriginalBodyInfo().rightMostNode.getBoundingClientRect().right, // Actual right coord of visible content
        bodyHeight = getScrollHeight(), winWidth = viewport.getInnerWidth(), winHeight = viewport.getInnerHeight(), hScrollNow = viewport.getPageXOffset(), vScrollNow = viewport.getPageYOffset(), // How much do we need to scroll by to pull content to the bottom-right corner
        hScrollDesired = Math.max(0, winWidth - bodyRight), // Amount to pull right as a positive number
        vScrollDesired = Math.max(0, winHeight - bodyHeight), // Amount to pull down as a positive number
        // Don't scroll more than we actually can
        hScroll = Math.min(hScrollNow, hScrollDesired), vScroll = Math.min(vScrollNow, vScrollDesired);
        window.scrollBy(-hScroll, -vScroll);
      }
      // Ensure that initial body info is ready
      function init(callback) {
        if (isInitialized) {
          if (callback) {
            callback();
          }
          return;
        } else {
          if (callback) {
            callbacks.push(callback);
          }
        }
        // We expect <body> to be defined now, but we're being defensive
        // (perhaps future extension will init and call us very early).
        if (document.body) {
          isInitialized = true;
          body = document.body;
          docElem = document.documentElement;
          $origBody = $(body);
          refreshOriginalBodyInfo();
          executeCallbacks();
          domEvents.on(window, "resize", function() {
            cachedDocumentScrollHeight = null;
            cachedDocumentScrollWidth = null;
          });
          events.on("zoom", function() {
            cachedDocumentScrollHeight = null;
            cachedDocumentScrollWidth = null;
          });
          return;
        }
        // No document.body yet
        if ("loading" !== document.readyState) {
          init(callback);
        } else {
          document.addEventListener("DOMContentLoaded", function() {
            init(callback);
          });
        }
      }
      sitecues.debugVisibleRects = function() {
        doDebugVisibleRects = true;
        computeBodyInfo();
      };
      return {
        isFluidLayout: isFluidLayout,
        getBodyWidth: getBodyWidth,
        getRestrictedBodyWidth: getRestrictedBodyWidth,
        getBodyRight: getBodyRight,
        getBodyLeft: getBodyLeft,
        getMainNode: getMainNode,
        getOriginalBodyInfo: getOriginalBodyInfo,
        getCurrentBodyInfo: getCurrentBodyInfo,
        invalidateBodyInfo: invalidateBodyInfo,
        getScrollWidth: getScrollWidth,
        getScrollHeight: getScrollHeight,
        refreshOriginalBodyInfo: refreshOriginalBodyInfo,
        getFormattedTranslateX: getFormattedTranslateX,
        maximizeContentVisibility: maximizeContentVisibility,
        init: init
      };
    }($, page_util_common, page_zoom_config_config, page_zoom_constants, page_zoom_state, page_zoom_util_restrict_zoom, page_viewport_viewport, run_dom_events, run_events, run_inline_style_inline_style);
    page_zoom_combo_boxes = function(events, state, inlineStyle, arrayUtil, platform, nativeGlobal) {
      var comboBoxListener, zoomStyleSheet, selector = 'select[size="1"],select:not([size])';
      function listenForNewComboBoxes(records) {
        records.some(function(record) {
          var addedNodes = arrayUtil.from(record.addedNodes);
          return addedNodes.some(function(node) {
            if ("select" === node.localName || "function" === typeof node.getElementsByTagName && node.getElementsByTagName("select")[0]) {
              fixAllSelectElements();
              return true;
            }
          });
        });
      }
      function fixSelectElement(element, zoom) {
        inlineStyle.override(element, [ "transition", "all 0s" ]);
        inlineStyle.restore(element, [ "font-size", "width", "height", "transform", "transform-origin" ]);
        if (1 === zoom) {
          inlineStyle.restore(element, "transition");
          // We don't need to fix combo boxes if we aren't zooming
          return;
        }
        var fontSize, styles = {};
        if (false) {
          // setting the em font size to the scale factor seems to work well
          fontSize = 1 + .8 * (zoom - 1);
          // Select elements in Firefox misposition their drop down menus if their ancestors are scaled, so we apply the inverse transform
          // and bump up the width as needed. The height of the element grows to contain the font size automatically
          styles.transform = "scale(" + 1 / zoom + ")";
          var parent = element.parentElement;
          if (parent && "inline" === getComputedStyle(parent).display) {
            // If the containing element is inline, we should try to keep it grouped with the rest of the line (important for Fairfield Bank)
            styles.transformOrigin = "100% 75%";
          } else {
            styles.transformOrigin = "0 75%";
          }
        } else {
          // Arbitrary scale so that font size of the drop down items grow with the zoom
          fontSize = 1 + .3 * (zoom - 1);
        }
        // Allow the element to auto-adjust to size of the font
        styles.height = "initial";
        styles.width = "initial";
        styles.fontSize = fontSize + "em";
        inlineStyle.override(element, styles);
        nativeGlobal.setTimeout(function() {
          // If we reapply the transition style in the same synchronous block, it animates our changes
          inlineStyle.restore(element, "transition");
        }, 0);
      }
      function fixAllSelectElements() {
        var elements = arrayUtil.from(document.body.querySelectorAll(selector));
        elements.forEach(function(element) {
          fixSelectElement(element, state.completedZoom);
        });
      }
      function init() {
        if (false) {
          // We don't need to fix combo boxes in IE
          return;
        }
        comboBoxListener = new MutationObserver(listenForNewComboBoxes);
        comboBoxListener.observe(document.body, {
          childList: true,
          subtree: true
        });
        zoomStyleSheet = document.createElement("style");
        fixAllSelectElements();
        events.on("zoom", function() {
          nativeGlobal.setTimeout(function() {
            fixAllSelectElements();
          }, 0);
        });
      }
      return {
        init: init
      };
    }(run_events, page_zoom_state, run_inline_style_inline_style, run_util_array_utility, run_platform, mini_core_native_global);
    page_util_transition_util = function(Promise, inlineStyle, arrayUtil, nativeGlobal, domEvents) {
      function disableTransformTransition(element) {
        disableStyleTransition(element, "transform");
      }
      function disableStyleTransition(element, property) {
        if (canPropertyTransition({
          element: element,
          property: property
        })) {
          var transitionValue = inlineStyle(element).transition;
          if (transitionValue) {
            transitionValue += ", ";
          }
          transitionValue += property + " 0s";
          inlineStyle.override(element, {
            transition: transitionValue
          });
        }
      }
      function applyInstantTransform(elmnts, transform) {
        var elements = arrayUtil.wrap(elmnts);
        elements.forEach(disableTransformTransition);
        inlineStyle.override(elements, [ "transform", transform ]);
        nativeGlobal.setTimeout(function() {
          elements.forEach(restoreTransition);
        }, 0);
      }
      function applyInstantStyle(elmnts, property, value) {
        var elements = arrayUtil.wrap(elmnts);
        elements.forEach(function(element) {
          disableStyleTransition(element, property);
        });
        inlineStyle.override(elements, [ property, value ]);
        nativeGlobal.setTimeout(function() {
          elements.forEach(restoreTransition);
        }, 0);
      }
      // This function works for standardized css values returned by the browser, but it won't work for
      // decimals that don't include the leading zero e.g. '.5s' vs '0.5s'
      function parseTimeInMilliseconds(timeString) {
        var value = parseFloat(timeString), // Can be seconds or milliseconds
        unit = timeString.substring(String(value).length);
        return value * ("s" === unit ? 1e3 : 1);
      }
      // Returns a promise for the computed value of the property once the style has finished
      // transitioning, if it currently is transitioning
      function getFinalStyleValue(element, opts) {
        var transitionTimer, property = opts.property, computedStyle = getComputedStyle(element), initialValue = computedStyle[property], initialTransition = computedStyle.transition, transitionInfo = opts.transitionInfo || getTransitionInfo(element);
        var propertyTransition = findPropertyTransition(property, transitionInfo);
        if (!propertyTransition) {
          // No relevant transition styles apply to this property, so we can return it's current resolved value
          return Promise.resolve(computedStyle[property]);
        }
        var delay = propertyTransition.delay, duration = propertyTransition.duration;
        function setTransitionTimeout(resolve) {
          // setTimeout takes it time parameter in milliseconds
          // A 20% buffer time is added because there is typically a slight
          // discrepancy between the explicit timeout and the practical timeout
          var timeoutLength = Math.ceil(1.2 * (duration + delay));
          return nativeGlobal.setTimeout(function() {
            // It's important that we update the current style value after the time out
            var resolveValue, currentValue = computedStyle[property], currentTransition = computedStyle.transition;
            if (currentValue === initialValue) {
              // If the style value hasn't changed, a transition has not taken place
              resolveValue = currentValue;
            } else {
              if (initialTransition !== currentTransition) {
                // The `transitionend` event didn't fire because the transition value changed in the interim, interrupting the transition
                // since we can't guarantee that between that time and now a new target property value hasn't been assigned, add another
                // getFinalStyleValue promise to the chain
                resolveValue = getFinalStyleValue(element, {
                  property: property
                });
              } else {
                var boundingRect = element.getBoundingClientRect();
                if (!boundingRect.height || !boundingRect.width) {
                  // If an element has been unrendered, its transitions are interrupted
                  resolveValue = currentValue;
                } else {
                  // If the element is still rendered, its current value is different than its initial value, and it still
                  // has the same transition, a new value has been assigned to its target property and we should set a new
                  // timeout.
                  initialValue = currentValue;
                  transitionTimer = setTransitionTimeout(resolve);
                  return;
                }
              }
            }
            resolve(resolveValue);
          }, timeoutLength);
        }
        return new Promise(function(resolve) {
          domEvents.on(element, "transitionend", function onTransition(evt) {
            if (evt.propertyName === property) {
              clearTimeout(transitionTimer);
              domEvents.off(element, "transitionend", onTransition);
              resolve(computedStyle[property]);
            }
          });
          transitionTimer = setTransitionTimeout(resolve);
        });
      }
      function getTransitionInfo(element) {
        var computedStyle = getComputedStyle(element), transitionProperties = computedStyle.transitionProperty.split(","), transitionDurations = computedStyle.transitionDuration.split(","), durationCount = transitionDurations.length, transitionDelays = computedStyle.transitionDelay.split(",");
        return transitionProperties.map(function(property, index) {
          // If there are more transition properties than transition durations, the duration
          // list is repeated over
          var duration = transitionDurations[index] || transitionDurations[(index + 1) % durationCount], // If there are more transition properties than transition delays,
          // the remaining delay values are set to '0s'
          delay = transitionDelays[index] || "0s";
          return {
            property: property,
            duration: parseTimeInMilliseconds(duration),
            delay: parseTimeInMilliseconds(delay)
          };
        });
      }
      function canPropertyTransition(opts) {
        var element = opts.element, property = opts.property, transitionInfo = opts.transitionInfo || getTransitionInfo(element);
        var propertyInfo = findPropertyTransition(property, transitionInfo);
        return Boolean(propertyInfo && propertyInfo.duration);
      }
      function findPropertyTransition(property, transitionInfo) {
        return arrayUtil.find(transitionInfo, function(propertyInfo) {
          var transProperty = propertyInfo.property;
          return transProperty === property || "all" === transProperty;
        });
      }
      function restoreTransition(element) {
        inlineStyle.restore(element, "transition");
      }
      return {
        applyInstantTransform: applyInstantTransform,
        applyInstantStyle: applyInstantStyle,
        disableTransformTransition: disableTransformTransition,
        disableStyleTransition: disableStyleTransition,
        restoreTransition: restoreTransition,
        getFinalStyleValue: getFinalStyleValue,
        canPropertyTransition: canPropertyTransition,
        getTransitionInfo: getTransitionInfo
      };
    }(Promise, run_inline_style_inline_style, run_util_array_utility, mini_core_native_global, run_dom_events);
    page_zoom_style = function($, platform, state, constants, bodyGeo, config, nativeGlobal, inlineStyle, comboBoxes, transitionUtil) {
      var body, $zoomStyleSheet, // <style> element we insert to correct form issues in WebKit
      // Optimize fonts for legibility? Helps a little bit with Chrome on Windows
      shouldOptimizeLegibility, // Should we repaint when zoom is finished (after any animations)?
      // Should always be true in Chrome, because it makes text crisper
      // Don't use backface repainting method if there is a background-image on the <body>, because it will be erased.
      // (We still want to use the backface method when we can, because it often produces better results than our
      // other method, which is to overlay a transparent div and then remove it)
      shouldRepaintOnZoomChange, // Key frame animations
      SITECUES_ZOOM_ID = constants.SITECUES_ZOOM_ID, CRISPING_ATTRIBUTE = constants.CRISPING_ATTRIBUTE, MAX = constants.MAX_ZOOM, MIN = constants.MIN_ZOOM, // Decimal places allowed
      ZOOM_PRECISION = constants.ZOOM_PRECISION, KEYFRAMES_ID = constants.KEYFRAMES_ID, // This is conjured out of thin air. Just seems to work.
      REPAINT_FOR_CRISP_TEXT_DELAY = constants.REPAINT_FOR_CRISP_TEXT_DELAY;
      // Create <style> for keyframes animations
      // For initial zoom, call with the targetZoom
      // Otherwise, it will create a reverse (zoom-out) and forward (zoom-in) style sheet
      //This needs to set up a keyframe stylesheet for each zoom target
      /*
  * Each zoom target will need to calculate a desired zoom level:
  *   a. Primary body, 0th zoom target, will calculate full zoom range and translate x / width animations as necessary
  *   b. each succeeding zoom target will use its calculated zoom level (depending on ratio of dimensions to screen size)
  * */
      //instead of taking target zoom on the initial zoom stylesheet, just take a boolean clarifying if it is
      //the initial zoom or not
      function setupNextZoomStyleSheet(targetZoom, doUseKeyFrames) {
        var css = "";
        if (doUseKeyFrames) {
          if (targetZoom) {
            // Style sheet to zoom exactly to targetZoom
            css = getAnimationCSS(targetZoom);
          } else {
            if (state.completedZoom > MIN) {
              // Style sheet for reverse zoom (zoom-out to 1x)
              css += getAnimationCSS(MIN);
            }
            if (state.completedZoom < MAX) {
              // Style sheet for forward zoom (zoom-in to 3x)
              css += getAnimationCSS(MAX);
            }
          }
        }
        css += getCssCrispingFixes();
        applyZoomStyleSheet(css);
      }
      // Replace current zoom stylesheet or insert a new one with the
      // requested styles plus generic stylesheet fixes for the current configuration.
      function applyZoomStyleSheet(additionalCss) {
        var styleSheetText = additionalCss || "";
        if (styleSheetText) {
          if ($zoomStyleSheet) {
            $zoomStyleSheet.text(styleSheetText);
          } else {
            $zoomStyleSheet = $("<style>").text(styleSheetText).attr("id", SITECUES_ZOOM_ID).appendTo("head");
          }
        }
      }
      // This is used to repaint the DOM after a zoom in WebKit to ensure crisp text
      function getCssCrispingFixes() {
        if (shouldRepaintOnZoomChange) {
          return "\n[" + CRISPING_ATTRIBUTE + "] * { backface-visibility: hidden; }\n";
        }
        return "";
      }
      function getCssKeyFrames(targetZoom, doEase, doIncludeTimePercent) {
        var timePercent, animationPercent, step = 0, // For animation performance, use adaptive algorithm for number of keyframe steps:
        // Bigger zoom jump = more steps
        numSteps = Math.ceil(20 * Math.abs(targetZoom - state.completedZoom)), percentIncrement = 1 / numSteps, keyFrames = [];
        for (;step <= numSteps; ++step) {
          timePercent = step === numSteps ? 1 : step * percentIncrement;
          if (doEase) {
            // Provide simple sinusoidal easing in out effect for initial load zoom
            animationPercent = (Math.cos(Math.PI * timePercent) - 1) / -2;
          } else {
            animationPercent = timePercent;
          }
          var midAnimationZoom = state.completedZoom + (targetZoom - state.completedZoom) * animationPercent;
          keyFrames[step] = getZoomCss(midAnimationZoom);
          if (doIncludeTimePercent) {
            keyFrames[step].timePercent = timePercent;
          }
        }
        return keyFrames;
      }
      function getCssAnimationName(targetZoom) {
        return KEYFRAMES_ID + "-" + Math.round(1e3 * state.completedZoom) + "-" + Math.round(1e3 * targetZoom);
      }
      // Get keyframes css for animating from completed zoom to target zoom
      function getAnimationCSS(targetZoom) {
        var animationName = getCssAnimationName(targetZoom), keyFramesCssProperty = true ? "@-webkit-keyframes " : "@keyframes ", keyFramesCss = animationName + " {\n", keyFrames = getCssKeyFrames(targetZoom, state.isInitialLoadZoom, true), numSteps = keyFrames.length - 1, step = 0;
        for (;step <= numSteps; ++step) {
          var keyFrame = keyFrames[step], zoomCssString = "transform: " + keyFrame.transform + (keyFrame.width ? "; width: " + keyFrame.width : "");
          keyFramesCss += Math.round(1e4 * keyFrame.timePercent) / 100 + "% { " + zoomCssString + " }\n";
        }
        keyFramesCss += "}\n\n";
        return keyFramesCssProperty + keyFramesCss;
      }
      // Get a CSS object for the targetZoom level
      //This needs to return the formatted translate x / width only when we're zooming the primary body
      function getZoomCss(targetZoom) {
        var css = {
          transform: "scale(" + targetZoom.toFixed(ZOOM_PRECISION) + ") " + bodyGeo.getFormattedTranslateX(targetZoom)
        };
        if (config.shouldRestrictWidth) {
          css.width = bodyGeo.getRestrictedBodyWidth(targetZoom);
        }
        return css;
      }
      // Add useful zoom fixes to the body's @style
      function fixZoomBodyCss() {
        // Allow the content to be horizontally centered, unless it would go
        // offscreen to the left, in which case start zooming the content from the left-side of the window
        inlineStyle.override(body, [ "transformOrigin", config.shouldRestrictWidth ? "0 0" : "50% 0" ]);
        if (shouldOptimizeLegibility) {
          inlineStyle.override(body, {
            textRendering: "optimizeLegibility"
          });
        }
      }
      /**
   * repaintToEnsureCrispText's purpose is to render text clearly in browsers (chrome only)
   * that do not repaint the DOM when using CSS Transforms.  This function simply sets a
   * property, which is hopefully not set on pages sitecues runs on, that forces repaint.
   * 15ms of time is required, because the browser may not be done transforming
   * by the time Javascript is executed without the setTimeout.
   *
   * See here: https://equinox.atlassian.net/wiki/display/EN/Known+Issues
   */
      function repaintToEnsureCrispText() {
        if (!shouldRepaintOnZoomChange) {
          return;
        }
        var $anyBody = $("body");
        // Make sure we get clone body as well, if present
        $anyBody.attr(CRISPING_ATTRIBUTE, "");
        nativeGlobal.setTimeout(function() {
          $anyBody.removeAttr(CRISPING_ATTRIBUTE);
        }, REPAINT_FOR_CRISP_TEXT_DELAY);
        var MAX_ZINDEX = 2147483647, $appendedDiv = $("<sc>");
        inlineStyle.set($appendedDiv[0], {
          position: "fixed",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          opacity: 1,
          backgroundColor: "transparent",
          zIndex: MAX_ZINDEX,
          pointerEvents: "none"
        });
        $appendedDiv.appendTo("html");
        nativeGlobal.setTimeout(function() {
          $appendedDiv.remove();
        }, 0);
      }
      //Restore the intended inline style when we're done transforming the body
      function restoreBodyTransitions() {
        transitionUtil.restoreTransition(body);
      }
      //If there is a transition style applied to the body, we need to be sure that it doesn't apply to transformations
      //otherwise our zoom logic will break
      function fixBodyTransitions() {
        transitionUtil.disableTransformTransition(body);
      }
      function getZoomStyleSheet() {
        return $zoomStyleSheet;
      }
      function init() {
        body = document.body;
        shouldRepaintOnZoomChange = true;
        shouldOptimizeLegibility = true && platform.os.isWin;
        comboBoxes.init();
      }
      return {
        setupNextZoomStyleSheet: setupNextZoomStyleSheet,
        getZoomCss: getZoomCss,
        getZoomStyleSheet: getZoomStyleSheet,
        fixZoomBodyCss: fixZoomBodyCss,
        getCssAnimationName: getCssAnimationName,
        repaintToEnsureCrispText: repaintToEnsureCrispText,
        fixBodyTransitions: fixBodyTransitions,
        restoreBodyTransitions: restoreBodyTransitions,
        init: init
      };
    }($, run_platform, page_zoom_state, page_zoom_constants, page_zoom_util_body_geometry, page_zoom_config_config, mini_core_native_global, run_inline_style_inline_style, page_zoom_combo_boxes, page_util_transition_util);
    page_viewport_scrollbars = function(platform, viewport, nativeGlobal, bodyGeo, inlineStyle) {
      var mainBodyRect, docElem, shouldComputeMainBodyScrollbars, doForceHorizScrollbar, doForceVertScrollbar, finalizeScrollbarsTimer, isInitialized, // CSS overflow to use when we aren't forcing a scrollbar
      defaultOverflowX, defaultOverflowY;
      function onBodyRectChange() {
        if (shouldComputeMainBodyScrollbars) {
          determineScrollbars();
        }
      }
      function forceScrollbars(doTransformOnHorizontalScroll, doTransformOnVerticalScroll) {
        doForceHorizScrollbar = doTransformOnHorizontalScroll;
        doForceVertScrollbar = doTransformOnVerticalScroll;
        determineScrollbars();
      }
      function isBodyTooWide() {
        if (mainBodyRect) {
          var right = Math.max(mainBodyRect.right, mainBodyRect.width);
          return right > viewport.getInnerWidth();
        }
      }
      function isBodyTooTall() {
        if (mainBodyRect) {
          var bottom = Math.max(mainBodyRect.bottom, mainBodyRect.height);
          return bottom > viewport.getInnerHeight();
        }
      }
      function setOverflow(overflowX, overflowY) {
        var docStyle = inlineStyle(docElem);
        if (docStyle.overflowX !== overflowX) {
          inlineStyle.override(docElem, {
            overflowX: overflowX
          });
        }
        if (docStyle.overflowY !== overflowY) {
          inlineStyle.override(docElem, {
            overflowY: overflowY
          });
        }
      }
      // We are going to remove scrollbars and re-add them ourselves, because we can do a better job
      // of knowing when the visible content is large enough to need scrollbars.
      // This also corrects the dreaded IE scrollbar bug, where fixed position content
      // and any use of getBoundingClientRect() was off by the height of the horizontal scrollbar, or the
      // width of the vertical scroll bar, but only when the user scrolled down or to the right.
      // By controlling the visibility of the scrollbars ourselves, the bug magically goes away.
      // This is also good because we're better than IE at determining when content is big enough to need scrollbars.
      function determineScrollbars() {
        var docStyle = inlineStyle(docElem);
        mainBodyRect = bodyGeo.getCurrentBodyInfo();
        // -- Clear the scrollbars --
        if (shouldComputeMainBodyScrollbars) {
          defaultOverflowX = defaultOverflowY = "hidden";
        } else {
          defaultOverflowX = docStyle.overflowX;
          defaultOverflowY = docStyle.overflowY;
        }
        // -- Set the scrollbars after a delay --
        // If the right side of the visible content is beyond the window width,
        // or the visible content is wider than the window width, show the scrollbars.
        // Doing this after a timeout fixes SC-3722 for some reason -- the toolbar was moving up and down by the height
        // of the horizontal scrollbar. It's as if doing it on a delay gives IE/Edge a chance to
        // deal with zoom first, and then scrollbars separately
        // The delay also allows us to collect several concurrent requests and handle them once.
        clearTimeout(finalizeScrollbarsTimer);
        var doUseHorizScrollbar = doForceHorizScrollbar || isBodyTooWide(), doUseVertScrollbar = doForceVertScrollbar || isBodyTooTall(), newOverflowX = doUseHorizScrollbar ? "scroll" : defaultOverflowX, newOverflowY = doUseVertScrollbar ? "scroll" : defaultOverflowY;
        if (newOverflowX !== docStyle.overflowX || newOverflowY !== docStyle.overflowY) {
          if (shouldComputeMainBodyScrollbars) {
            // MS browsers need to reset first, otherwise causes SC-3722
            setOverflow("hidden", "hidden");
          }
          finalizeScrollbarsTimer = nativeGlobal.setTimeout(function() {
            setOverflow(newOverflowX, newOverflowY);
          }, 0);
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        // IE/Edge don't know when to put in scrollbars after CSS transform
        // Edge does, but we need to do this because of SC-3722 -- jiggling of Sitecues toolbar during vertical scrolls
        shouldComputeMainBodyScrollbars = platform.browser.isMS;
        docElem = document.documentElement;
      }
      return {
        onBodyRectChange: onBodyRectChange,
        forceScrollbars: forceScrollbars,
        init: init
      };
    }(run_platform, page_viewport_viewport, mini_core_native_global, page_zoom_util_body_geometry, run_inline_style_inline_style);
    page_zoom_animation = function($, pref, platform, events, metric, errors, common, state, constants, config, viewport, bodyGeo, restrictZoom, style, scrollbars, nativeGlobal, inlineStyle) {
      var isInitialized, body, $origBody, // Zoom operation state
      minZoomChangeTimer, // Keep zooming at least for this long, so that a glide does a minimum step
      zoomAnimator, // Frame request ID that can be cancelled
      elementDotAnimatePlayer, // AnimationPlayer used in some browsers (element.animate)
      // Zoom slider change listener
      thumbChangeListener, // Supports a single listener that is called back as animation proceeds
      glideChangeTimer, // State to help with animation optimizations and will-change
      zoomBeginTimer, // Timer before zoom can actually begin (waiting for browser to create composite layer)
      // Finish the glide if no more key down events during this period
      edgeKeyGlideTimer, // Should we use the Web Animations API (element.animate) ?
      shouldUseElementDotAnimate, // Timer used for callbacks
      // Function to call for requesting an animation frame
      requestFrame = window.requestAnimationFrame, EDGE_CONTINUE_KEY_GLIDE_WAIT_MS = 500, // Constants
      // Change zoom at least this amount if user clicks on A button or presses +/- or left/right in slider
      MIN_ZOOM_PER_CLICK = constants.MIN_ZOOM_PER_CLICK, // For animations, the number of milliseconds per unit of zoom (e.g. from 1x to 2x)
      MS_PER_X_ZOOM_GLIDE = constants.MS_PER_X_ZOOM_GLIDE, // For click in slider
      MS_PER_X_ZOOM_SLIDER = constants.MS_PER_X_ZOOM_SLIDER, // How often to call back with a new zoom value
      GLIDE_CHANGE_INTERVAL_MS = constants.GLIDE_CHANGE_INTERVAL_MS, ANIMATION_END_EVENTS = constants.ANIMATION_END_EVENTS;
      // Must be called to set up any type of zoom operation
      function beginZoomOperation(targetZoom, input, animationReadyCallback) {
        if (isZoomOperationRunning()) {
          errors.report(new Error("zoom begin repeated"));
        }
        // Initialize zoom input info
        state.zoomInput = $.extend({
          isSlider: false,
          // Slider in panel
          isSliderDrag: false,
          // True if the user drags the slider (as opposed to clicking in it)
          isSliderClick: false,
          // True if the user dragged the slider and now stopped
          isLongGlide: false,
          // Key or A button held down to glide extra
          isKey: false,
          isButtonPress: false,
          // Small or large A in panel
          isUnpinch: false,
          // Trackpad unpinch
          isCtrlWheel: false,
          // Ctrl+mousewheel
          // isFirstBadgeUse: undefined,     // If first badge use? Not defined if this is not originating from the badge
          fromZoom: state.completedZoom
        }, input);
        // Make sure we're ready
        bodyGeo.init();
        style.fixBodyTransitions();
        // Ensure no other operation is running
        clearZoomCallbacks();
        state.currentTargetZoom = restrictZoom.toValidRange(targetZoom);
        // Add what we need in <style> if we haven't already
        if (!style.getZoomStyleSheet()) {
          style.setupNextZoomStyleSheet(state.currentTargetZoom, shouldUseKeyFramesAnimation());
        }
        // Correct the start zoom time with the real starting time
        state.startZoomTime = Date.now();
        var $body = $("body");
        // Temporarily indicate that zooming is in progress -- this is used by the sitecues-zoom-form-fix stylesheet
        $body.attr("data-sc-zooming", "");
        inlineStyle.override($body.get(), {
          // Temporarily disable mouse cursor events and CSS behavior, to help with zoom performance
          pointerEvents: "none"
        });
        events.emit("zoom/begin");
        if (animationReadyCallback) {
          animationReadyCallback();
        }
      }
      // Begin an operation to the glide toward the current zoom, if smooth zoom is currently supported.
      // If no smooth zoom, apply an instant zoom change to increase or decrease zoom by a constant amount.
      // If we are zooming with +/- or clicking A/a
      function beginGlide(targetZoom, event, inputInfo) {
        if (targetZoom === state.completedZoom) {
          return;
        }
        if (!isZoomOperationRunning()) {
          var input = inputInfo || {};
          if (event) {
            if (event.keyCode) {
              // TODO should we differentiate between Enter on A/a vs +/- ?
              input.isKey = true;
              input.isBrowserKeyOverride = event.ctrlKey || event.metaKey;
            } else {
              input.isButtonPress = true;
            }
          }
          input.isLongGlide = true;
          // Default, assume glide will not be cut off early
          beginZoomOperation(targetZoom, input, beginGlideAnimation);
          // Provide callback for when animation can actually start
          $(window).one("keyup", finishGlideIfEnough);
        }
        if (platform.browser.isEdge && event && event.keyCode) {
          // SC-3615: Microsoft Edge not always firing keyup! Still true as of Edge 14 beta.
          // We must simulate something close to a keyup with a timer.
          // The timer will keep resetting as long as key repeat is active. The zoom glide
          // will end shortly after the last keydown event.
          clearTimeout(edgeKeyGlideTimer);
          edgeKeyGlideTimer = nativeGlobal.setTimeout(finishGlideIfEnough, EDGE_CONTINUE_KEY_GLIDE_WAIT_MS);
        }
        function beginGlideAnimation() {
          glideChangeTimer = setInterval(onGlideChange, GLIDE_CHANGE_INTERVAL_MS);
          if (!state.zoomInput.isLongGlide) {
            // Button/key was already released, zoom only for long enough to get minimum zoom
            var delta = MIN_ZOOM_PER_CLICK * (state.completedZoom < targetZoom ? 1 : -1);
            state.currentTargetZoom = restrictZoom.toValidRange(state.completedZoom + delta);
            minZoomChangeTimer = nativeGlobal.setTimeout(finishZoomOperation, MIN_ZOOM_PER_CLICK * getMsPerXZoom());
          }
          if (shouldUseElementDotAnimate) {
            performElementDotAnimateZoomOperation();
          } else {
            if (shouldUseKeyFramesAnimation()) {
              performKeyFramesZoomOperation();
            } else {
              performJsAnimateZoomOperation();
            }
          }
        }
      }
      // Cancel any currently requested animation frame
      function cancelFrame() {
        window.cancelAnimationFrame(zoomAnimator);
      }
      // Continual slider updates
      // This matches our updates with screen refreshes.
      // Unfortunately, it causes issues in some older versions of Firefox on Mac + Retina.
      function performContinualZoomUpdates() {
        zoomAnimator = requestFrame(performContinualZoomUpdates);
        performInstantZoomOperation();
        state.completedZoom = state.currentTargetZoom;
      }
      function finishZoomSliderOperation() {
        // ---- Slider drag ----
        if (state.zoomInput.isSliderDrag) {
          cancelFrame();
          finishZoomOperation();
          return;
        }
        // ---- Slider click ----
        // Is in the middle of gliding to a zoom click -- this always uses JS.
        // Let it finish -- the animation's end will cause finishZoomOperation() to be called
        state.zoomInput.isSliderClick = true;
      }
      // If smooth zoom is used, which kind -- JS or CSS keyframes?
      // In dev, we can override default behavior as follows:
      // Shift-key: Script-based
      // Ctrl-key: CSS-based
      function shouldUseKeyFramesAnimation() {
        var restrictingWidthInSafari = false;
        // IE/Edge are working better with JS animation (keyframes even taking too long to start/stop, not really smoother)
        // Safari is herky jerky if animating the width and using key frames
        return !platform.browser.isMS && !restrictingWidthInSafari && !shouldUseElementDotAnimate;
      }
      // Animate until the currentTargetZoom, used for gliding zoom changes
      // Use falsey value for isTargetZoomStable for slider zoom, where the
      // target keeps changing as the slider moves
      function performJsAnimateZoomOperation() {
        function jsZoomStep() {
          // Firefox passes in a weird startZoomTime that can't be compared with Date.now()
          var midAnimationZoom = getMidAnimationZoom();
          inlineStyle.override($origBody[0], style.getZoomCss(midAnimationZoom));
          if (midAnimationZoom === state.currentTargetZoom && !isSliderActive()) {
            zoomAnimator = requestFrame(finishZoomOperation);
          } else {
            zoomAnimator = requestFrame(jsZoomStep);
          }
        }
        zoomAnimator = requestFrame(jsZoomStep);
      }
      // This is used for the following types of zoom:
      // * Initial load zoom
      // * Keypress (+/-) or A button press, which zoom until the button is let up
      function performKeyFramesZoomOperation() {
        //This needs to get the transform animation, and apply it to zoom targets
        //It also needs to get the width animation, and apply it to the primary body
        //body:first-child { width animation }
        var zoomSpeedMs = Math.abs(state.currentTargetZoom - state.completedZoom) * getMsPerXZoom(), //the animation names need to be tied to the specific keyframes (primary body vs. other zoom targets)
        //perhaps we should include zoom target index, with the 0th index always being the primary body
        animationCss = {
          animation: style.getCssAnimationName(state.currentTargetZoom) + " " + zoomSpeedMs + "ms linear",
          animationPlayState: "running",
          fillMode: "forwards"
        };
        // Apply the new CSS
        inlineStyle.override($origBody[0], animationCss);
        // No zoomStopRequested() received for initial zoom
        $origBody.one(ANIMATION_END_EVENTS, onGlideStopped);
      }
      function getAnimationKeyFrames(targetZoom, doEase, doIncludeTimePercent) {
        var timePercent, animationPercent, step = 0, // For animation performance, use adaptive algorithm for number of keyframe steps:
        // Bigger zoom jump = more steps
        numSteps = Math.ceil(20 * Math.abs(targetZoom - state.completedZoom)), percentIncrement = 1 / numSteps, keyFrames = [];
        for (;step <= numSteps; ++step) {
          timePercent = step === numSteps ? 1 : step * percentIncrement;
          if (doEase) {
            // Provide simple sinusoidal easing in out effect for initial load zoom
            animationPercent = (Math.cos(Math.PI * timePercent) - 1) / -2;
          } else {
            animationPercent = timePercent;
          }
          var midAnimationZoom = state.completedZoom + (targetZoom - state.completedZoom) * animationPercent;
          keyFrames[step] = style.getZoomCss(midAnimationZoom);
          if (doIncludeTimePercent) {
            keyFrames[step].timePercent = timePercent;
          }
        }
        return keyFrames;
      }
      // Go directly to zoom. Do not pass go. But do collect the $200 anyway.
      function performInstantZoomOperation() {
        var zoomCss = style.getZoomCss(state.currentTargetZoom);
        if (true && body.animate) {
          // Magically, this works with the new crisper (and the new crisper doesn't kill mouse events on floats ...)
          if (elementDotAnimatePlayer) {
            elementDotAnimatePlayer.cancel();
          }
          elementDotAnimatePlayer = body.animate([ zoomCss, zoomCss ], {
            duration: 1,
            iterations: 1,
            fill: "forwards"
          });
        } else {
          inlineStyle.override($origBody[0], zoomCss);
        }
        if (thumbChangeListener) {
          thumbChangeListener(state.currentTargetZoom);
        }
      }
      function performElementDotAnimateZoomOperation() {
        var animationMs = Math.abs(state.currentTargetZoom - state.completedZoom) * MS_PER_X_ZOOM_GLIDE;
        elementDotAnimatePlayer = body.animate(getAnimationKeyFrames(state.currentTargetZoom), {
          duration: animationMs,
          iterations: 1,
          fill: "forwards",
          easing: state.isInitialLoadZoom ? "ease-out" : "linear"
        });
        elementDotAnimatePlayer.onfinish = onGlideStopped;
      }
      function isSliderActive() {
        return state.zoomInput.isSlider && !state.zoomInput.isSliderClick;
      }
      // Are we in the middle of a zoom operation?
      function isZoomOperationRunning() {
        return state.startZoomTime;
      }
      function isGlideCurrentlyRunning() {
        return glideChangeTimer;
      }
      function getMsPerXZoom() {
        return state.zoomInput.isSlider ? MS_PER_X_ZOOM_SLIDER : MS_PER_X_ZOOM_GLIDE;
      }
      // Get what the zoom value would be if we stopped the animation now
      function getMidAnimationZoom() {
        var totalZoomChangeRequested = Math.abs(state.currentTargetZoom - state.completedZoom), zoomDirection = state.currentTargetZoom > state.completedZoom ? 1 : -1, zoomChange = state.elapsedZoomTime / getMsPerXZoom();
        if (zoomChange > totalZoomChangeRequested) {
          zoomChange = totalZoomChangeRequested;
        }
        return restrictZoom.toValidRange(state.completedZoom + zoomDirection * zoomChange);
      }
      // Helper for calling back glide change listener
      function onGlideChange() {
        if (thumbChangeListener) {
          thumbChangeListener(getMidAnimationZoom());
        }
      }
      function onGlideStopped() {
        if (elementDotAnimatePlayer) {
          // If we don't do this, then setting CSS directly on body no longer works
          // (May not have been cancelled if user holds + and reaches 3 or holds - and reaches 1)
          elementDotAnimatePlayer.cancel();
          elementDotAnimatePlayer = null;
        }
        var styles = style.getZoomCss(state.currentTargetZoom);
        styles.animation = "";
        inlineStyle.override($origBody[0], styles);
        finishZoomOperation();
      }
      // Must be called at the end of a zoom operation.
      function finishZoomOperation() {
        var $body = $("body");
        if (!isZoomOperationRunning()) {
          errors.report(new Error("zoom finish before start"));
        }
        bodyGeo.invalidateBodyInfo();
        if (elementDotAnimatePlayer) {
          // Can't leave animation player around, as it will prevent future animations
          inlineStyle.override($origBody[0], style.getZoomCss(state.currentTargetZoom));
          elementDotAnimatePlayer.onfinish = null;
          elementDotAnimatePlayer.cancel();
        }
        var didUnzoom = state.completedZoom > state.currentTargetZoom;
        state.completedZoom = getActualZoom();
        state.fixedZoom = restrictZoom.forFixedZoomTarget(state.completedZoom);
        state.startZoomTime = 0;
        if (didUnzoom) {
          bodyGeo.maximizeContentVisibility();
        }
        // Remove and re-add scrollbars -- we will re-add them after zoom if content is large enough
        // Only determine scrollbars for IE
        scrollbars.onBodyRectChange();
        // Restore mouse cursor events and CSS behavior
        inlineStyle.override($body.get(), {
          pointerEvents: ""
        });
        // Indicate that zooming has finished -- this is used by the sitecues-zoom-form-fix stylesheet
        nativeGlobal.setTimeout(function() {
          $("body").removeAttr("data-sc-zooming");
        }, 0);
        // notify all about zoom change
        events.emit("zoom", state.completedZoom);
        if (!state.isInitialLoadZoom) {
          pref.set("zoom", state.completedZoom);
          if (!didUnzoom) {
            !function(audioCues) {
              audioCues.playZoomCue(state.completedZoom);
            }(audio_cues_audio_cues);
          }
          if ("{}" === nativeGlobal.JSON.stringify(state.zoomInput)) {
            errors.report(new Error("zoom metric empty details"));
          }
          new metric.ZoomChange(state.zoomInput).send();
        }
        clearZoomCallbacks();
        if (state.isInitialLoadZoom) {
          viewport.jumpToLocationHash();
        }
        state.isInitialLoadZoom = false;
        state.zoomInput = {};
        // Get next forward/backward glide animations ready.
        // Doing it now helps with performance, because stylesheet will be parsed and ready for next zoom.
        nativeGlobal.setTimeout(style.setupNextZoomStyleSheet, 0, null, shouldUseKeyFramesAnimation());
        style.restoreBodyTransitions();
        if (1 === state.completedZoom) {
          // Fixed elements are broken when we apply a transformation, and it takes work for us to correct that, so we remove the transformation
          // from the body when possible
          inlineStyle.restore(body, "transform");
        }
        // Un-Blur text in Chrome
        if (true) {
          style.repaintToEnsureCrispText();
        }
      }
      function cancelGlideChangeTimer() {
        if (glideChangeTimer) {
          clearInterval(glideChangeTimer);
          glideChangeTimer = 0;
        }
      }
      // Make sure the current zoom operation does not continue
      function clearZoomCallbacks() {
        // Ensure no further changes to zoom from this operation
        cancelFrame();
        clearTimeout(minZoomChangeTimer);
        clearTimeout(zoomBeginTimer);
        clearTimeout(edgeKeyGlideTimer);
        cancelGlideChangeTimer();
        $origBody.off(ANIMATION_END_EVENTS, onGlideStopped);
        $(window).off("keyup", finishGlideIfEnough);
      }
      // When an A button or +/- key is pressed, we always glide at least MIN_ZOOM_PER_CLICK.
      // This provides a consistent amount of zoom change for discrete presses.
      function finishGlideIfEnough() {
        if (!isGlideCurrentlyRunning()) {
          // Glide has started, but animation hasn't started yet -- we are waiting for
          // the ANIMATION_OPTIMIZATION_SETUP_DELAY period while the browser sets up for the animation.
          state.zoomInput.isLongGlide = false;
          // beginGlideAnimation() will see this and setup it's own timer
          return;
        }
        // If MIN_ZOOM_PER_CLICK has not been reached, we set a timer to finish the zoom
        // based on how much time would be needed to achieve MIN_ZOOM_PER_CLICK
        var timeRemaining = Math.max(0, MIN_ZOOM_PER_CLICK * getMsPerXZoom() - state.elapsedZoomTime);
        state.zoomInput.isLongGlide = 0 === timeRemaining;
        minZoomChangeTimer = nativeGlobal.setTimeout(finishGlideEarly, timeRemaining);
      }
      function freezeZoom() {
        state.currentTargetZoom = getActualZoom();
        inlineStyle.override($origBody[0], style.getZoomCss(state.currentTargetZoom));
        if (elementDotAnimatePlayer) {
          elementDotAnimatePlayer.onfinish = null;
          elementDotAnimatePlayer.cancel();
        }
        onGlideStopped();
      }
      function finishElementDotAnimate() {
        // We have to stop it like this so that we keep the current amount of zoom in the style attribute,
        // while the animation player is stopped so that it doesn't block future style attribute changes
        // from taking affect (e.g. via the slider)
        requestFrame(function() {
          if (elementDotAnimatePlayer) {
            elementDotAnimatePlayer.pause();
          }
          requestFrame(freezeZoom);
        });
      }
      // A glide operation is finishing. Use the current state of the zoom animation for the final zoom amount.
      function finishGlideEarly() {
        cancelGlideChangeTimer();
        // Stop element.animate player
        if (elementDotAnimatePlayer) {
          finishElementDotAnimate();
          return;
        }
        // JS zoom operation
        if (!shouldUseKeyFramesAnimation()) {
          state.currentTargetZoom = getMidAnimationZoom();
          finishZoomOperation();
          return;
        }
        // Stop key frames or element.animate
        zoomAnimator = requestFrame(function() {
          // Stop the key-frame animation at the current zoom level
          // Yes, it's crazy, but this sequence helps the zoom stop where it is supposed to, and not jump back a little
          inlineStyle.override($origBody[0], {
            animationPlayState: "paused"
          });
          zoomAnimator = requestFrame(function() {
            state.currentTargetZoom = getActualZoom();
            onGlideStopped();
          });
        });
      }
      // Get the current zoom value as reported by the layout engine
      function getActualZoom() {
        return restrictZoom.toValidRange(common.getComputedScale(body));
      }
      function updateSlider() {
        if (thumbChangeListener) {
          glideChangeTimer = setInterval(onGlideChange, GLIDE_CHANGE_INTERVAL_MS);
        }
      }
      function chooseZoomStrategy() {
        zoomAnimator = requestFrame(performContinualZoomUpdates);
      }
      // Allow one listener for all zoom updates, even mid-animation.
      // These occur when the user holds down A, a, +, - (as opposed to conf.set and the 'zoom' event which occur at the end)
      // Currently only supports one listener.
      // It has to be fast, otherwise it will affect zoom performance.
      function setThumbChangeListener(listener) {
        thumbChangeListener = listener;
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        viewport.init();
        //This module is initialized after body has been parsed
        body = document.body;
        $origBody = $(body);
        shouldUseElementDotAnimate = true && body.animate;
      }
      return {
        beginZoomOperation: beginZoomOperation,
        beginGlide: beginGlide,
        performInstantZoomOperation: performInstantZoomOperation,
        performJsAnimateZoomOperation: performJsAnimateZoomOperation,
        isZoomOperationRunning: isZoomOperationRunning,
        finishZoomOperation: finishZoomOperation,
        finishZoomSliderOperation: finishZoomSliderOperation,
        finishGlideIfEnough: finishGlideIfEnough,
        updateSlider: updateSlider,
        chooseZoomStrategy: chooseZoomStrategy,
        cancelFrame: cancelFrame,
        cancelGlideChangeTimer: cancelGlideChangeTimer,
        setThumbChangeListener: setThumbChangeListener,
        init: init
      };
    }($, run_conf_preferences, run_platform, run_events, run_metric_metric, run_errors, page_util_common, page_zoom_state, page_zoom_constants, page_zoom_config_config, page_viewport_viewport, page_zoom_util_body_geometry, page_zoom_util_restrict_zoom, page_zoom_style, page_viewport_scrollbars, mini_core_native_global, run_inline_style_inline_style);
    page_zoom_flash = function(events, state, urls, arrayUtil, inlineStyle) {
      var flashObserver, dimensionsMap = new WeakMap(), observedDocuments = new WeakMap();
      function isInteger(number) {
        return !isNaN(number) && Math.floor(number) === number;
      }
      function onDocumentMutation(mutations) {
        mutations.forEach(function(mutation) {
          arrayUtil.from(mutation.addedNodes).forEach(function(node) {
            if (isFlashElement(node)) {
              fixFlashElements(node);
            }
          });
        });
      }
      function observeDocument(document) {
        if (observedDocuments.get(document)) {
          return;
        }
        var opts = {
          subtree: true,
          childList: true
        };
        flashObserver.observe(document, opts);
      }
      function fixFlashElements(documentOrElement) {
        var elements;
        if (documentOrElement) {
          elements = documentOrElement.nodeType === Node.ELEMENT_NODE ? [ documentOrElement ] : findFlashElements(documentOrElement);
        } else {
          elements = findFlashElements();
        }
        function setDimension(element, dimension, value, unit) {
          if (isInteger(value)) {
            element.setAttribute(dimension, value + unit);
          }
        }
        elements.forEach(function(element) {
          var zoomReciprocal = 1 / state.completedZoom, ancestor = element.parentElement;
          while (!isTransformable(ancestor)) {
            ancestor = ancestor.parentElement;
          }
          var styles = {};
          styles.transform = "scale(" + zoomReciprocal + ")";
          styles.transformOrigin = "0 0";
          inlineStyle.override(ancestor, styles);
          var originalDimensions = dimensionsMap.get(element) || {}, originalWidth = originalDimensions.width, originalHeight = originalDimensions.height, width = element.getAttribute("width"), height = element.getAttribute("height"), widthMatch = width.match(/[^0-9\.]+/), heightMatch = height.match(/[^0-9\.]+/), widthUnit = widthMatch ? widthMatch[0] : "", heightUnit = heightMatch ? heightMatch[0] : "";
          if ("undefined" === typeof originalWidth) {
            width = parseInt(width);
            height = parseInt(height);
            // Rounding `null` coerces to zero, so we use a string here
            originalDimensions.width = isNaN(width) ? "null" : width;
            originalDimensions.height = isNaN(height) ? "null" : height;
            dimensionsMap.set(element, originalDimensions);
          } else {
            width = originalWidth;
            height = originalHeight;
          }
          width = Math.round(width * state.completedZoom);
          height = Math.round(height * state.completedZoom);
          setDimension(element, "width", width, widthUnit);
          setDimension(element, "height", height, heightUnit);
        });
      }
      function findFlashElements(document) {
        var embedSelector = "object, embed", frameSelector = "iframe, frame", embedElements = [], documentsToSearch = [ document || getHighestPermittedDocument() ];
        function getHighestPermittedDocument() {
          var docRef, refSucceeded = false, highestWindow = window, document = window.document;
          while (highestWindow !== highestWindow.parent) {
            try {
              // wrapped in a try block to avoid cross-origin Errors halting the script
              docRef = highestWindow.parent.document;
              refSucceeded = true;
            } catch (e) {}
            if (refSucceeded) {
              highestWindow = highestWindow.parent;
              document = docRef;
              refSucceeded = false;
            } else {
              break;
            }
          }
          return document;
        }
        function searchDocument(document) {
          var nestedFrames = Array.prototype.slice.call(document.querySelectorAll(frameSelector), 0);
          embedElements = embedElements.concat(Array.prototype.slice.call(document.querySelectorAll(embedSelector)));
          observeDocument(document);
          nestedFrames.forEach(function(frame) {
            if (!frame.src || urls.isSameOrigin(frame.src)) {
              documentsToSearch.push(frame.contentDocument);
            }
          });
        }
        while (documentsToSearch.length) {
          searchDocument(documentsToSearch.shift());
        }
        return embedElements.filter(isFlashElement);
      }
      function isFlashElement(element) {
        if ("application/x-shockwave-flash" === element.type) {
          return true;
        }
        var swfSrc = element.src && element.src.indexOf("swf") >= 0, swfData = element.data && element.data.indexOf("swf") >= 0;
        return swfSrc || swfData;
      }
      function isTransformable(element) {
        return [ "object", "embed", "param" ].indexOf(element.localName) === -1;
      }
      function init() {
        flashObserver = new MutationObserver(onDocumentMutation);
        events.on("zoom", function() {
          fixFlashElements();
        });
      }
      return {
        init: init
      };
    }(run_events, page_zoom_state, run_conf_urls, run_util_array_utility, run_inline_style_inline_style);
    page_zoom_zoom = function($, pref, events, modifierKeyState, animation, bodyGeo, state, constants, config, restrictZoom, style, scrollbars, nativeGlobal, flash, inlineStyle) {
      var isInitialized, // Is the zoom module already initialized?
      isReady, // Are the dependencies initialized
      $origBody, body, unpinchEndTimer, UNPINCH_FACTOR = constants.UNPINCH_FACTOR, UNPINCH_END_DELAY = constants.UNPINCH_END_DELAY, MAX = constants.MAX_ZOOM, MIN = constants.MIN_ZOOM;
      // ------------------------ PUBLIC -----------------------------
      // Is this the zoom that occurs on page load?
      function getIsInitialZoom() {
        return state.isInitialLoadZoom;
      }
      function beginZoomIncrease(event, inputInfo) {
        // Increase up to max or until zoomStopRequested()
        animation.beginGlide(MAX, event, inputInfo);
      }
      function beginZoomDecrease(event, inputInfo) {
        animation.beginGlide(MIN, event, inputInfo);
      }
      function getCompletedZoom() {
        return state.completedZoom;
      }
      // Use to jump the current zoom immediately to the targetZoom requested
      // The use case for this is currently the zoom slider
      function jumpTo(targetZoom, inputInfo) {
        if (!animation.isZoomOperationRunning()) {
          // 1st call -- we will glide to it, it may be far away from previous zoom value
          animation.beginZoomOperation(targetZoom, $.extend({}, inputInfo, {
            isSlider: true
          }));
          // Get ready for more slider updates
          if (targetZoom !== state.completedZoom) {
            animation.performJsAnimateZoomOperation();
            animation.updateSlider();
          }
        } else {
          if (!state.zoomInput.isSliderDrag) {
            // 2nd call -- cancel glide and begin continual updates
            animation.cancelFrame();
            animation.cancelGlideChangeTimer();
            state.zoomInput.isSliderDrag = true;
            animation.chooseZoomStrategy();
          }
          // 3rd and subsequent calls, just update the target zoom value
          // so that the continual update loop uses the new value
          state.currentTargetZoom = restrictZoom.toValidRange(targetZoom);
        }
      }
      function resetZoom() {
        if (state.completedZoom > 1) {
          animation.beginZoomOperation(1, {});
          animation.performInstantZoomOperation();
          animation.finishZoomOperation();
        }
      }
      // We capture ctrl+wheel events because those are actually pinch/unpinch events
      function onMouseWheel(event) {
        if (!event.ctrlKey) {
          return;
        }
        event.preventDefault();
        function getWheelEventInputInfo() {
          return modifierKeyState.isCtrlKeyDown() ? {
            isCtrlWheel: true
          } : {
            isUnpinch: true
          };
        }
        var delta = -event.deltaY * UNPINCH_FACTOR, targetZoom = animation.isZoomOperationRunning() ? state.currentTargetZoom + delta : state.completedZoom + delta;
        clearTimeout(unpinchEndTimer);
        unpinchEndTimer = nativeGlobal.setTimeout(animation.finishZoomOperation, UNPINCH_END_DELAY);
        if (!animation.isZoomOperationRunning()) {
          // 1st call -- we will glide to it, it may be far away from previous zoom value
          animation.beginZoomOperation(targetZoom, getWheelEventInputInfo());
        }
        state.currentTargetZoom = restrictZoom.toValidRange(targetZoom);
        // Change target
        animation.performInstantZoomOperation();
      }
      function zoomStopRequested() {
        if (animation.isZoomOperationRunning()) {
          if (state.zoomInput.isSlider) {
            animation.finishZoomSliderOperation();
          } else {
            // "A" button or +/- keypress
            animation.finishGlideIfEnough();
          }
        }
      }
      function performInitialLoadZoom(initialZoom) {
        var targetZoom = restrictZoom.toValidRange(initialZoom);
        if (1 === targetZoom) {
          return;
        }
        if (!isReady) {
          // Wait until <body> is ready
          // This can happen in the case of extension which loads very fast
          // In the future, extension may try to zoom sooner rather than waiting for entire document to load
          events.on("zoom/ready", function() {
            performInitialLoadZoom(targetZoom);
          });
          // Zoom once badge is ready
          return;
        }
        state.isInitialLoadZoom = true;
        animation.beginGlide(targetZoom);
      }
      /**
   * Recompute the visible body size, and re-zoom the page as that handles the logic
   * to properly scale, resize, and position the page and its elements with respect to the current
   * sizes of the body and window.
   */
      function onResize() {
        if (!$origBody) {
          return;
        }
        inlineStyle.restore(body, [ "width", "transform" ]);
        bodyGeo.refreshOriginalBodyInfo();
        inlineStyle.override(body, style.getZoomCss(state.completedZoom));
        if (config.shouldRestrictWidth) {
          // Restrict the width of the body so that it works similar to browser zoom
          // Documents designed to fit the width of the page still will
          inlineStyle.override(body, {
            width: bodyGeo.getRestrictedBodyWidth(state.completedZoom)
          });
        }
        bodyGeo.invalidateBodyInfo();
        // TODO computeBodyInfo() is doing a lot of work that refreshBodyInfo() did -- at least it should share which nodes to iterate over
        scrollbars.onBodyRectChange();
        events.emit("resize");
      }
      function bodyGeometryInitialized(wheelEvent) {
        scrollbars.init();
        style.init();
        animation.init();
        flash.init();
        //This callback will only be called when body is parsed
        body = document.body;
        $origBody = $(body);
        // Use pref module for sharing current zoom level value
        pref.defineHandler("zoom", restrictZoom.toValidRange);
        // ATKratter wouldn't scroll when we listened to this on the window
        document.addEventListener("wheel", onMouseWheel);
        // Ctrl+wheel = unpinch
        if ("undefined" === typeof config.isFluid) {
          config.isFluid = bodyGeo.isFluidLayout();
        }
        $(window).on("resize", onResize);
        style.fixZoomBodyCss();
        // Get it read as soon as zoom might be used
        if (wheelEvent) {
          onMouseWheel(wheelEvent);
        }
        isReady = true;
        events.emit("zoom/ready");
      }
      function init(wheelEvent) {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        config.init();
        bodyGeo.init(function() {
          bodyGeometryInitialized(wheelEvent);
        });
      }
      return {
        getIsInitialZoom: getIsInitialZoom,
        jumpTo: jumpTo,
        beginZoomIncrease: beginZoomIncrease,
        beginZoomDecrease: beginZoomDecrease,
        getCompletedZoom: getCompletedZoom,
        resetZoom: resetZoom,
        zoomStopRequested: zoomStopRequested,
        performInitialLoadZoom: performInitialLoadZoom,
        init: init
      };
    }($, run_conf_preferences, run_events, run_modifier_key_state, page_zoom_animation, page_zoom_util_body_geometry, page_zoom_state, page_zoom_constants, page_zoom_config_config, page_zoom_util_restrict_zoom, page_zoom_style, page_viewport_scrollbars, mini_core_native_global, page_zoom_flash, run_inline_style_inline_style);
    bp_expanded_controller_slider_controller = function(BP_CONST, ZOOM_CONST, helper, platform, state, sliderView, zoomMod, animation, events, domEvents) {
      var isListeningToWindowMouseMoveEvents, isListeningToWindowMouseUpEvents, isInitialized;
      /**
   * Mouse is been pressed down on the slider:
   * If the slider is ready for input, begin sending zoom new values for every mouse move.
   */
      function initialMouseDown(evt) {
        if (!state.isPanel()) {
          return;
        }
        moveThumb(evt);
        addWindowMouseMoveListener();
        addWindowMouseUpListener();
      }
      function addWindowMouseMoveListener() {
        if (!isListeningToWindowMouseMoveEvents) {
          isListeningToWindowMouseMoveEvents = true;
          // Be a capturing listener so that we get events before any especially "creative" page scripts
          domEvents.on(window, "mousemove", moveThumb, {
            passive: false
          });
        }
      }
      function addWindowMouseUpListener() {
        if (!isListeningToWindowMouseUpEvents) {
          isListeningToWindowMouseUpEvents = true;
          domEvents.on(window, "mouseup", finishZoomChanges, {
            passive: false
          });
        }
      }
      function removeWindowMouseListeners() {
        if (isListeningToWindowMouseMoveEvents) {
          domEvents.off(window, "mousemove", moveThumb, {
            passive: false
          });
          isListeningToWindowMouseMoveEvents = false;
        }
        if (isListeningToWindowMouseMoveEvents) {
          domEvents.off(window, "mouseup", finishZoomChanges, {
            passive: false
          });
          isListeningToWindowMouseUpEvents = false;
        }
      }
      // Mouse button was pressed down over slider and mouse cursor has moved
      function moveThumb(evt) {
        var sliderThumbRect = helper.getRectById(BP_CONST.ZOOM_SLIDER_THUMB_ID), sliderRect = helper.getRectById(BP_CONST.ZOOM_SLIDER_BAR_ID), panelLeft = helper.getRectById(BP_CONST.BP_CONTAINER_ID).left, // TODO Need comments what the browser differences are
        sliderLeft = true ? sliderRect.left + sliderThumbRect.width / 2 : panelLeft + BP_CONST.FIREFOX_SLIDER_OFFSET, sliderWidth = sliderRect.width - sliderThumbRect.width, newPercent = (evt.clientX - sliderLeft) / sliderWidth;
        var newValue = newPercent * ZOOM_CONST.ZOOM_RANGE + ZOOM_CONST.MIN_ZOOM;
        zoomMod.jumpTo(newValue, {
          isFirstBadgeUse: isFirstBadgeUse()
        });
        evt.preventDefault();
      }
      function isFirstBadgeUse() {
        return state.get("isFirstBadgeUse");
      }
      /**
   * Handler when click on small or large A.
   */
      function handleAButtonsPress(evt) {
        var target = helper.getEventTarget(evt), isDecrease = target.id === BP_CONST.SMALL_A_ID;
        addWindowMouseUpListener();
        var changeFn = isDecrease ? zoomMod.beginZoomDecrease : zoomMod.beginZoomIncrease;
        changeFn(evt, {
          isFirstBadgeUse: isFirstBadgeUse()
        });
      }
      function finishZoomChanges() {
        zoomMod.zoomStopRequested();
        removeWindowMouseListeners();
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        // Init zoom, add permanent listeners
        zoomMod.init();
        sliderView.render(zoomMod.getCompletedZoom());
        animation.setThumbChangeListener(sliderView.updateThumbPosition);
        // Zoom controls
        var sliderTarget = helper.byId(BP_CONST.ZOOM_SLIDER_ID), sliderThumb = helper.byId(BP_CONST.ZOOM_SLIDER_THUMB_ID), smallA = helper.byId(BP_CONST.SMALL_A_ID), largeA = helper.byId(BP_CONST.LARGE_A_ID), zoomLabel = helper.byId(BP_CONST.ZOOM_LABEL_ID);
        domEvents.on(sliderTarget, "mousedown", initialMouseDown, {
          passive: false
        });
        domEvents.on(sliderThumb, "mousedown", initialMouseDown, {
          passive: false
        });
        domEvents.on(smallA, "mousedown", handleAButtonsPress);
        domEvents.on(largeA, "mousedown", handleAButtonsPress);
        domEvents.on(zoomLabel, "mousedown", handleAButtonsPress);
        events.on("bp/will-shrink", finishZoomChanges);
        // A zoom operation has been completed
        // (We don't move the thumb here ... we do via setThumbChangeListener, because we get mid-animation changes that way)
        events.on("zoom", sliderView.updateZoomValue);
      }
      return {
        init: init
      };
    }(run_bp_constants, page_zoom_constants, run_bp_helper, run_platform, run_bp_model_state, bp_expanded_view_slider, page_zoom_zoom, page_zoom_animation, run_events, run_dom_events);
    bp_expanded_controller_shrink_controller = function(BP_CONST, state, helper, metric, view, events, domEvents, nativeGlobal) {
      var // Min distance before shrink
      mouseLeaveShrinkTimer, // How long we wait before shrinking BP from any mouseout (even only just barely outside panel)
      isListening, isZooming, // First time, we will already be expanded
      isInitialized, MIN_DISTANCE = 75, isExpandingOrExpanded = true, byId = helper.byId;
      function isSticky() {
        return state.get("isStickyPanel");
      }
      function cancelMouseLeaveShrinkTimer() {
        clearTimeout(mouseLeaveShrinkTimer);
        mouseLeaveShrinkTimer = 0;
      }
      // Return truthy value if a button is pressed on a mouse event.
      // There are three properties for mouse buttons, and they all work differently -- both
      // in terms of browsers and on mousemove events in particular.
      function isButtonDown(mouseEvent) {
        return "undefined" === typeof mouseEvent.buttons ? mouseEvent.which : mouseEvent.buttons;
      }
      // Don't close panel too quickly when the mouse leaves the window, because the panel
      // may be near the window's edge and users with shaky hands may accidentally move mouse outside the window.
      // We don't know anything about the mouse other than the fact that it left the window
      function winMouseLeave(evt) {
        if (helper.getEventTarget(evt).id === BP_CONST.BADGE_ID) {
          mouseLeaveShrinkTimer = nativeGlobal.setTimeout(shrinkPanel, BP_CONST.MOUSELEAVE_DELAY_SHRINK_BP);
        }
      }
      // return truthy value if mouseout should cause panel to close
      function canShrinkFromMouseout() {
        // Only allow close from hover if mouse was in panel once
        return state.get("wasMouseInPanel");
      }
      function winMouseMove(evt) {
        if (isButtonDown(evt)) {
          return;
        }
        if (isMouseOutsidePanel(evt, MIN_DISTANCE)) {
          if (true && isSticky()) {
            return;
          }
          if (canShrinkFromMouseout()) {
            shrinkPanel();
          }
        } else {
          state.set("wasMouseInPanel", true);
          cancelMouseLeaveShrinkTimer();
        }
      }
      function fireClickMetric(evt) {
        var role, id, ancestor = helper.getEventTarget(evt);
        // default name if we don't find a metric target
        while (ancestor) {
          role = helper.getAriaOrNativeRole(ancestor);
          if ("presentation" !== role) {
            // Do not fire metrics for items only included to help presentation, e.g. a shadow
            id = ancestor.id;
            if (id || id === BP_CONST.BP_CONTAINER_ID) {
              break;
            }
          }
          ancestor = ancestor.parentNode;
        }
        new metric.PanelClick({
          target: id,
          role: role,
          isFirstBadgeUse: isFirstBadgeUse()
        }).send();
      }
      function isFirstBadgeUse() {
        return state.get("isFirstBadgeUse");
      }
      function winMouseDown(evt) {
        if (true && isSticky()) {
          return;
        }
        if (isMouseOutsidePanel(evt, 0)) {
          if (!state.get("isOpenedWithScreenReader")) {
            // Any click anywhere outside of visible contents should close panel, no safe-zone needed
            // Unless opened by a screen reader in virtual cursor mode, because JAWS sends spurious clicks outside of panel (SC-3211)
            shrinkPanel();
          }
          return;
        }
        // Fire metrics only for clicks inside the panel
        if (isWithinContainer(evt.target, BP_CONST.BP_CONTAINER_ID)) {
          fireClickMetric(evt);
        }
      }
      function onBlur(event) {
        if (event.target === window) {
          maybeShrinkPanel();
        }
      }
      function maybeShrinkPanel() {
        if (true && isSticky()) {
          return;
        }
        shrinkPanel(true);
      }
      // @param isFromKeyboard -- optional, if truthy, then the shrink command is from the keyboard (e.g. escape key)
      // bpc.processKeyDown, buttonPress, winMouseMove, winMouseDown call this function...
      function shrinkPanel(isFromKeyboard) {
        if (state.isShrinking()) {
          return;
        }
        /*
     bp/will-shrink sets and removes attributes used for screen readers.
     bp/will-shrink removes mousedown, mousemove, and keydown event listeners bound to the window.
     bp/will-shrink cancels badge->panel animation
     bp/will-shrink removes click handler for toggling speech
     */
        events.emit("bp/will-shrink");
        state.set("transitionTo", BP_CONST.BADGE_MODE);
        state.set("isShrinkingFromKeyboard", isFromKeyboard);
        state.set("isSecondaryPanel", false);
        state.set("secondaryPanelTransitionTo", 0);
        // If the secondary panel is active, deactivate it.
        if (state.isSecondaryPanelRequested()) {
          disableSecondaryPanel();
        }
        // Finally, begin the shrinking animation.
        view.update();
        new metric.PanelClose({
          isFirstBadgeUse: isFirstBadgeUse()
        }).send();
      }
      /*
   Private functions.
   */
      /**
   * disableSecondaryPanel is called when the panel is about to shrink.
   * It is responsible for deactivating the secondary panel.
   */
      function disableSecondaryPanel() {
        var moreToggle = helper.byId(BP_CONST.MORE_BUTTON_GROUP_ID);
        moreToggle.setAttribute("aria-label", "View more options");
      }
      function isWithinContainer(elem, id) {
        while (elem) {
          if (elem.id === id) {
            return true;
          }
          elem = elem.parentNode;
        }
      }
      function getVisiblePanelRect() {
        var secondaryOutlineHeight, mainOutline = byId(BP_CONST.MAIN_OUTLINE_ID), rect = helper.getRect(mainOutline);
        if (state.isSecondaryFeaturePanel()) {
          secondaryOutlineHeight = byId(BP_CONST.MORE_OUTLINE_ID).getBoundingClientRect().height;
          rect.height = secondaryOutlineHeight;
          rect.bottom = rect.top + rect.height;
        }
        return rect;
      }
      function isMouseOutsideRect(evt, rect, minDistance) {
        return evt.clientY > rect.bottom + minDistance || evt.clientY < rect.top - minDistance || evt.clientX > rect.right + minDistance || evt.clientX < rect.left - minDistance;
      }
      function isMouseOutsidePanel(evt, distance) {
        var target = helper.getEventTarget(evt), targetId = target.id;
        if (targetId !== BP_CONST.BP_CONTAINER_ID && targetId !== BP_CONST.BADGE_ID && !isWithinContainer(target, BP_CONST.MORE_BUTTON_CONTAINER_ID)) {
          return isMouseOutsideRect(evt, getVisiblePanelRect(), distance);
        }
      }
      // These listeners are temporary – only bound when the panel is open.
      // Good for performance – it prevents extra code from being run on every mouse move/click when we don't need it
      function toggleListeners(doTurnOn) {
        var addOrRemoveFn = doTurnOn ? domEvents.on : domEvents.off;
        addOrRemoveFn(window, "mousedown", winMouseDown);
        if (!state.get("isOpenedWithScreenReader")) {
          // Mousemove can close panel after mouseout, unless opened with a screen reader
          addOrRemoveFn(window, "mousemove", winMouseMove);
        }
        addOrRemoveFn(window, "mouseout", winMouseLeave);
        addOrRemoveFn(window, "blur", onBlur);
        addOrRemoveFn(window, "resize", maybeShrinkPanel);
      }
      function refresh() {
        var shouldBeOn = !isZooming && isExpandingOrExpanded;
        if (shouldBeOn !== isListening) {
          isListening = shouldBeOn;
          toggleListeners(isListening);
        }
      }
      function willZoom() {
        isZooming = true;
        refresh();
      }
      function didZoom() {
        isZooming = false;
        refresh();
      }
      function willExpand() {
        isExpandingOrExpanded = true;
        refresh();
      }
      function willShrink() {
        isExpandingOrExpanded = false;
        refresh();
      }
      function didShrink() {
        state.set("isShrinkingFromKeyboard", false);
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        events.on("info/did-show", shrinkPanel);
        events.on("bp/will-expand", willExpand);
        events.on("bp/will-shrink", willShrink);
        events.on("bp/did-shrink", didShrink);
        events.on("zoom/begin", willZoom);
        events.on("zoom", didZoom);
        toggleListeners(true);
      }
      return {
        init: init,
        shrinkPanel: shrinkPanel
      };
    }(run_bp_constants, run_bp_model_state, run_bp_helper, run_metric_metric, run_bp_view_view, run_events, run_dom_events, mini_core_native_global);
    bp_expanded_controller_focus_controller = function(BP_CONST, state, helper, metric, view, events, CORE_CONST, nativeGlobal, inlineStyle) {
      var savedDocumentFocus, tabbedElement, isInitialized, isListeningToClicks, byId = helper.byId, keyCode = CORE_CONST.KEY_CODE, TAB = keyCode.TAB, ENTER = keyCode.ENTER, ESCAPE = keyCode.ESCAPE, SPACE = keyCode.SPACE, LEFT = keyCode.LEFT, UP = keyCode.UP, RIGHT = keyCode.RIGHT, DOWN = keyCode.DOWN, arrows = [ UP, DOWN, LEFT, RIGHT ], triggerKeys = [ ENTER, SPACE ], TABBABLE = {
        // IMPORTANT: remove 'scp-' prefix -- it gets added in by the code
        main: [ "zoom-slider-bar", "speech", "more-button-group" ],
        "button-menu": [ "tips-button", "settings-button", "feedback-button", "about-button", "more-button-group" ],
        tips: [ "$", // Current card contents
        "settings-label", "feedback-label", "about-label", "more-button-group" ],
        settings: [ "$", // Current card contents
        "tips-label", "feedback-label", "about-label", "more-button-group" ],
        feedback: [ "feedback-textarea", "stars-1", "stars-2", "stars-3", "stars-4", "stars-5", "feedback-send-link", "feedback-thanks", "tips-label", "settings-label", "about-label", "more-button-group" ],
        about: [ "about-sitecues-link", "about-rate-button", "tips-label", "settings-label", "feedback-label", "more-button-group" ]
      }, DELTA_KEYS = {};
      DELTA_KEYS[LEFT] = -1;
      DELTA_KEYS[UP] = 1;
      DELTA_KEYS[RIGHT] = 1;
      DELTA_KEYS[DOWN] = -1;
      function getPanelContainer() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      // Clear the visual focus rectangle and current focus state
      function clearPanelFocus() {
        if (tabbedElement) {
          tabbedElement.removeAttribute("data-show-focus");
          tabbedElement.removeAttribute("tabindex");
        }
        hideFocus();
        tabbedElement = null;
        getPanelContainer().removeAttribute("aria-activedescendant");
      }
      // Hide focus but keep focus state
      function hideFocus() {
        var focusShownOn = getElementToShowFocusOn();
        if (focusShownOn) {
          focusShownOn.removeAttribute("data-show-focus");
        }
        byId(BP_CONST.OUTLINE_ID).removeAttribute("data-show");
      }
      function updateDOMFocusState() {
        if (!tabbedElement) {
          return;
        }
        var panelContainer = getPanelContainer();
        panelContainer.setAttribute("aria-activedescendant", tabbedElement.id);
        tabbedElement.setAttribute("focusable", true);
        tabbedElement.setAttribute("tabindex", 0);
        try {
          // Allow real focus if item/browser allows it:
          // - In Firefox, for now this will only work on HTML elements
          // - In other browsers, anything with focusable/tabindex can be focused
          tabbedElement.focus();
        } catch (ex) {
          panelContainer.focus();
        }
      }
      function showFocus() {
        updateDOMFocusState();
        if (!tabbedElement || !isKeyboardMode()) {
          // No focus to show or not in keyboard mode
          hideFocus();
        } else {
          // Show focus
          if (tabbedElement.id === BP_CONST.MORE_BUTTON_GROUP_ID) {
            events.emit("bp/did-focus-more-button");
          }
          renderFocusOutline();
        }
      }
      function listenToClicks() {
        if (!isListeningToClicks) {
          isListeningToClicks = true;
          var mainSVG = byId(BP_CONST.SVG_ID), bpContainer = byId(BP_CONST.BP_CONTAINER_ID);
          mainSVG.addEventListener("mousedown", clickToFocus);
          bpContainer.addEventListener("mousedown", clickToFocus);
        }
      }
      function isKeyboardMode() {
        return state.get("isKeyboardMode");
      }
      function focusCard(cardId, tabElement, isFromLink) {
        if (isKeyboardMode() && tabElement) {
          clearPanelFocus();
          tabbedElement = tabElement;
          if (isFromLink) {
            // When jumping directly to tab, navigate to the first content inside the tab
            while (tabbedElement && "tab" === tabbedElement.getAttribute("role")) {
              navigateInDirection(1);
            }
          }
          showFocus();
        }
      }
      function focusFirstItem() {
        if (isKeyboardMode()) {
          nativeGlobal.setTimeout(function() {
            navigateInDirection(1, true);
          }, 0);
        }
      }
      /*
   If the badge was focused, the panel will go into focus mode when it's entered.
   In focus mode, we show the following:
   - A keyboard focus outline so the user knows where they are tabbing
   - A close button in case the user doesn't realize Escape key will close
   - The "more button" is shown immediately rather than on a timer, so that the tabbing cycle doesn't suddenly change in the middle of tabbing
   We also save the last focus so that we can restore it when the panel closes.
   */
      function beginKeyHandling() {
        // Save the last focus so that we can restore it when panel closes
        savedDocumentFocus = document.activeElement;
        // If the badge is focused we will turn keyboard mode on for the panel
        var isBadgeFocused = savedDocumentFocus && savedDocumentFocus.id === BP_CONST.BADGE_ID;
        clearPanelFocus();
        if (isBadgeFocused) {
          // TODO can we remove this ? It's set elsewhere. Try with a screen reader.
          //badgeElement.setAttribute('aria-expanded', 'true');
          // Turn keyboard mode on for the panel, and start focus on the first item
          tabbedElement = getElementForFocusIndex(0);
          turnOnKeyboardMode();
          showFocus();
        }
        // Take the focus whether or not we're in focus mode,
        // in case the user presses tab or Escape to turn on keyboard mode after expansion
        getPanelContainer().focus();
        window.addEventListener("keydown", processKeyDown, true);
      }
      function endKeyHandling() {
        // If the BP_CONTAINER has focus AND the document.body was the previous
        // focused element, blur the BP_CONTAINER focus.
        //
        // If the BP_CONTAINER has focus AND the document.body was NOT the previous
        // focused element, focus the previously focused element.
        clearPanelFocus();
        if ((!savedDocumentFocus || savedDocumentFocus === document.body) && "blur" in document.activeElement) {
          document.activeElement.blur();
        } else {
          var focusable = savedDocumentFocus || ("focus" in document ? document : document.body);
          //TODO: Focusing is broken in Edge, figure out the root cause of this
          if ("function" === typeof focusable.focus) {
            focusable.focus();
          }
        }
        window.removeEventListener("keydown", processKeyDown, true);
      }
      function turnOnKeyboardMode() {
        state.set("isKeyboardMode", true);
        listenToClicks();
        view.update();
      }
      function getFocusedItem() {
        // User has tabbed: we're in keyboard, mode, so the focused item is tabbedElement.
        // User has NOT tabbed: the focused item is where they last clicked -- document.activeElement
        return tabbedElement || document.activeElement;
      }
      function getElementToShowFocusOn() {
        if (tabbedElement) {
          var focusForwarder = tabbedElement.getAttribute("data-visible-focus-on");
          return focusForwarder ? byId(focusForwarder) : tabbedElement;
        }
      }
      function renderFocusOutline() {
        // @data-visible-focus-on = id of element to show focus on
        // @data-show-focus = focus to be shown on this element
        // @data-own-focus-ring = element will show it's own focus ring
        var showFocusOn = getElementToShowFocusOn(), scale = state.get("scale");
        function getFinalCoordinate(coord) {
          return coord / scale + "px";
        }
        showFocusOn.setAttribute("data-show-focus", "");
        if (!showFocusOn.hasAttribute("data-own-focus-ring")) {
          // Show focus outline
          var EXTRA_FOCUS_PADDING = 1, clientPanelRect = helper.getRect(getPanelContainer()), // Focus rect is positioned relative to this
          clientFocusRect = helper.getRect(showFocusOn), focusOutline = byId(BP_CONST.OUTLINE_ID);
          focusOutline.setAttribute("data-show", true);
          inlineStyle.set(focusOutline, {
            width: getFinalCoordinate(clientFocusRect.width + 2 * EXTRA_FOCUS_PADDING),
            height: getFinalCoordinate(clientFocusRect.height + 2 * EXTRA_FOCUS_PADDING),
            top: getFinalCoordinate(clientFocusRect.top - EXTRA_FOCUS_PADDING - clientPanelRect.top),
            left: getFinalCoordinate(clientFocusRect.left - EXTRA_FOCUS_PADDING - clientPanelRect.left)
          });
        }
      }
      function getAllTabbableItemsInActiveCard() {
        function getItems(itemsSelector) {
          var panelSelector = "#scp-" + state.getPanelName() + ">", nodeList = document.querySelectorAll(panelSelector + itemsSelector);
          return Array.prototype.slice.call(nodeList);
        }
        var cardTabs = getItems(".scp-card-chooser>sc-link"), cardContentItems = getItems('.scp-active .scp-tabbable:not([data-show="false"])');
        return cardTabs.concat(cardContentItems);
      }
      function getAdjacentTabbableItem(all, current, direction) {
        for (var i = 0, l = all.length; i < l; i++) {
          if (all[i] === current) {
            return all[i + direction];
          }
        }
      }
      function getFirstOrLastTabbableItem(all, direction) {
        // First or last dynamic tabbable item.
        return all[direction > 0 ? 0 : all.length - 1];
      }
      function navigateInCard(direction, isFirstTimeInCard, currentItem) {
        // All items in the active card.
        var tabbableItemsInActiveCard = getAllTabbableItemsInActiveCard();
        // If there are none, skip to the next item.
        // The item adjacent to the current focused item, depending on what direction user tabs.
        return isFirstTimeInCard ? getFirstOrLastTabbableItem(tabbableItemsInActiveCard, direction) : getAdjacentTabbableItem(tabbableItemsInActiveCard, currentItem, direction);
      }
      function isFocusable(elem) {
        return elem && "true" !== elem.getAttribute("aria-disabled") && parseFloat(getComputedStyle(elem).opacity) > .1;
      }
      function navigateInDirection(direction, doStartFromTop) {
        if (!state.isPanel()) {
          return;
        }
        hideFocus();
        var nextItem, tabbable = getTabbableItems(), focusIndex = doStartFromTop ? -1 : getFocusIndexForElement(getFocusedItem()), isFirstTimeInCard = "$" !== tabbable[focusIndex], numItems = tabbable.length;
        while (true) {
          nextItem = null;
          if ("$" === tabbable[focusIndex]) {
            nextItem = navigateInCard(direction, isFirstTimeInCard, tabbedElement);
            isFirstTimeInCard = false;
          }
          if (!nextItem) {
            focusIndex += direction;
            if (focusIndex < 0) {
              // If shift+tab from the first item, go to the last
              focusIndex = numItems - 1;
            } else {
              if (focusIndex >= numItems) {
                // If tab past the last item, go to the first
                focusIndex = 0;
              }
            }
            nextItem = getElementForFocusIndex(focusIndex);
          }
          tabbedElement = nextItem;
          // Skip disabled items such as the prev arrow which is turned off at first
          if (isFocusable(nextItem)) {
            break;
          }
        }
        showFocus();
      }
      function getTabbableItems() {
        return TABBABLE[state.getPanelName()];
      }
      function getElementForFocusIndex(focusIndex) {
        return byId("scp-" + getTabbableItems()[focusIndex]);
      }
      function isTabbableCardItem(elem) {
        var className = elem.getAttribute("class");
        return className && className.indexOf("scp-tabbable") >= 0;
      }
      function getFocusIndexForElement(elem) {
        // Remove scp- from id and find new index
        if (elem) {
          var tabbable = getTabbableItems(), focusIndex = tabbable.indexOf(elem.id.substr(4));
          // If can't find the element in the tabbable items, it means it's in card content
          if (focusIndex < 0 && isTabbableCardItem(elem)) {
            // Not one of the main focused items listed in TABBABLE, try to see if it's a focusable card item
            focusIndex = tabbable.indexOf("$");
          }
          return focusIndex;
        }
        return -1;
      }
      function clickToFocus(event) {
        var target = state.isPanel() && helper.getEventTarget(event);
        clearPanelFocus();
        while (target && target.id !== BP_CONST.BADGE_ID && target.id !== BP_CONST.BP_CONTAINER_ID) {
          var forwardClickFocus = target.getAttribute("aria-controls");
          if (forwardClickFocus) {
            // Clicking slider thumb should focus slider bar
            target = byId(forwardClickFocus);
          }
          if (getFocusIndexForElement(target) >= 0) {
            tabbedElement = target;
            break;
          }
          target = target.parentNode;
        }
        if (tabbedElement) {
          showFocus();
        } else {
          // Clicked in whitespace, on collapsed badge or somewhere that can't take focus
          // Prevent default handling and thus prevent focus
          // User may think they need to click in badge
          // We don't want to take focus that way -- only via tabbing or from screen reader use
          return helper.cancelEvent(event);
        }
      }
      // If it was always HTML we could just use elem.click()
      function simulateClick(element) {
        var event = document.createEvent("MouseEvents");
        // If you need clientX, clientY, etc., you can call
        // initMouseEvent instead of initEvent
        event.initEvent("click", true, true);
        element.dispatchEvent(event);
        new metric.PanelClick({
          target: element.id,
          role: helper.getAriaOrNativeRole(element)
        }).send();
      }
      function onZoomKeyUp() {
        !function(zoomMod) {
          zoomMod.zoomStopRequested();
        }(page_zoom_zoom);
      }
      function performZoomSliderCommand(keyCode, evt) {
        var deltaSliderCommand = DELTA_KEYS[keyCode];
        if (deltaSliderCommand) {
          !function(zoomMod) {
            window.removeEventListener("keyup", onZoomKeyUp);
            // Zoom module will listen from here
            zoomMod.init();
            if (deltaSliderCommand > 0) {
              zoomMod.beginZoomIncrease(evt);
            } else {
              zoomMod.beginZoomDecrease(evt);
            }
          }(page_zoom_zoom);
          window.addEventListener("keyup", onZoomKeyUp);
        }
      }
      // Process key down and return true if key should be allowed to perform default behavior
      function processKey(evt) {
        var keyCode = evt.keyCode;
        // Escape = close
        if (keyCode === ESCAPE) {
          if (state.isSecondaryPanelRequested()) {
            simulateClick(byId(BP_CONST.MORE_BUTTON_GROUP_ID));
          } else {
            !function(shrinkController) {
              shrinkController.shrinkPanel(true);
            }(bp_expanded_controller_shrink_controller);
          }
          return;
        }
        // Tab navigation
        if (keyCode === TAB) {
          turnOnKeyboardMode();
          navigateInDirection(evt.shiftKey ? -1 : 1);
          new metric.PanelFocusMove().send();
          return;
        }
        // Perform widget-specific command
        // Can't use evt.target because in the case of SVG it sometimes only has fake focus (some browsers can't focus SVG elements)
        var item = getFocusedItem();
        if (item) {
          if ("textarea" === item.localName || "input" === item.localName) {
            return true;
          }
          if (item.id === BP_CONST.ZOOM_SLIDER_BAR_ID) {
            performZoomSliderCommand(keyCode, evt);
          } else {
            if (triggerKeys.indexOf(keyCode) > -1) {
              simulateClick(item);
            }
          }
        }
        if (triggerKeys.indexOf(keyCode) > -1) {
          //Don't allow default behavior for enter and space keys while the panel is open
          return;
        }
        if (arrows.indexOf(keyCode) > -1) {
          //Prevent window from scrolling on arrow keys
          return;
        }
        // else fall through to native processing of keystroke
        return true;
      }
      function isModifiedKey(evt) {
        return evt.altKey || evt.metaKey || evt.ctrlKey;
      }
      function processKeyDown(evt) {
        if (isModifiedKey(evt) || !state.isPanel()) {
          return;
        }
        if (!processKey(evt)) {
          evt.preventDefault();
          return false;
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        events.on("bp/will-toggle-feature", hideFocus);
        events.on("bp/did-open-subpanel", focusFirstItem);
        events.on("bp/did-show-card", focusCard);
        beginKeyHandling();
        // First time badge expands
        events.on("bp/will-expand", beginKeyHandling);
        events.on("bp/will-shrink", endKeyHandling);
        events.on("bp/did-expand", showFocus);
      }
      return {
        init: init,
        getFocusedItem: getFocusedItem,
        navigateInDirection: navigateInDirection,
        processKey: processKey
      };
    }(run_bp_constants, run_bp_model_state, run_bp_helper, run_metric_metric, run_bp_view_view, run_events, run_constants, mini_core_native_global, run_inline_style_inline_style);
    bp_expanded_controller_scroll_prevention = function(events, helper, BP_CONST) {
      var isInitialized;
      // Return truthy if document will be scrolled
      // This occurs if the current element is already scrolled all the way in this direction
      function isFinishedScrollingElement(elem, event) {
        var deltaY = parseInt(event.deltaY || -event.wheelDeltaY), // parseInt() sanitizes by converting strange -0 value to 0
        scrollHeight = elem.scrollHeight, // The total height of the scrollable area
        scrollTop = elem.scrollTop, // Pixel height of invisible area above element (what has been scrolled)
        clientHeight = elem.clientHeight, // The height of the element in the window
        scrollBottom = scrollHeight - scrollTop - clientHeight, // The pixels height invisible area below element (what is left to scroll)
        scrollingDown = deltaY > 0, // If the user is scrolling downwards
        scrollingUp = deltaY < 0;
        // If the user is scrolling upwards
        // Already at top
        return scrollingDown && deltaY > scrollBottom || scrollingUp && -deltaY > scrollTop || !deltaY;
      }
      function shouldCancelScrollEvent(evt) {
        var target = helper.getEventTarget(evt);
        if (!target.hasAttribute("data-allow-scroll")) {
          // Most elements in BP don't allow scrolling at all
          return true;
        }
        // In an element that needs scrolling such as textarea
        if (isFinishedScrollingElement(target, evt)) {
          // Finished scrolling element -- scroll event will propagate up unless we cancel it.
          // Unfortunately you cannot just stopPropagation() on a scroll event to prevent it from scrolling the parent
          return true;
        }
      }
      // Don't scroll document while BP is open
      function preventDocumentScroll(evt) {
        if (shouldCancelScrollEvent(evt)) {
          return helper.cancelEvent(evt);
        }
      }
      function getBpContainer() {
        return helper.byId(BP_CONST.BP_CONTAINER_ID);
      }
      function willExpand() {
        getBpContainer().addEventListener("wheel", preventDocumentScroll);
      }
      function willShrink() {
        getBpContainer().removeEventListener("wheel", preventDocumentScroll);
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        willExpand();
        // First time
        events.on("bp/will-expand", willExpand);
        events.on("bp/will-shrink", willShrink);
      }
      return {
        init: init
      };
    }(run_events, run_bp_helper, run_bp_constants);
    bp_expanded_view_tts_button = function(BP_CONST, helper, state, locale, pref, events, platform, nativeGlobal, inlineStyle) {
      var waveAnimationTimer, waveAnimationStepNum, localizedSpeechString, isInitialized, isListeningToEvents, isSpeechEnabled = pref.get("ttsOn");
      function toggleSpeech() {
        !function(audio) {
          // We do a timeout here so that this occurs after any key handlers that stop speech
          // Otherwise, the same Enter/space press that starts speaking the cue could immediately silence the same cue
          nativeGlobal.setTimeout(audio.toggleSpeech, 0);
        }(audio_audio);
      }
      function getTTSButtonElement() {
        return helper.byId(BP_CONST.SPEECH_ID);
      }
      function getTTSLabelElement() {
        return helper.byId(BP_CONST.SPEECH_LABEL_ID);
      }
      function ensureLabelFitsInPanel() {
        var ttsLabelElement = getTTSLabelElement(), speechLabelWidth = ttsLabelElement.getBoundingClientRect().width;
        function setAlignment(alignment) {
          // alignment is 'start' for left justification, and 'end' for right justification
          ttsLabelElement.setAttribute("text-anchor", alignment);
          ttsLabelElement.setAttribute("x", ttsLabelElement.getAttribute("data-x-" + alignment));
        }
        function getMaxLabelWidth() {
          // The right side of the speech target, which is almost at the panel's edge
          // minus the visible left side of the speech button
          return helper.byId(BP_CONST.SPEECH_TARGET_ID).getBoundingClientRect().right - helper.byId(BP_CONST.HEAD_ID).getBoundingClientRect().left;
        }
        // Use right justification if label is too large to fit
        setAlignment(speechLabelWidth > getMaxLabelWidth() ? "end" : "start");
        if (platform.browser.isEdge) {
          helper.fixTextAnchors(ttsLabelElement);
        }
      }
      function setTTSLabel(state) {
        var speechStateLabel = getTTSLabelElement(), localizedState = locale.translate(state), text = localizedSpeechString + " " + localizedState, node = document.createTextNode(text);
        speechStateLabel.removeChild(speechStateLabel.firstChild);
        speechStateLabel.appendChild(node);
        ensureLabelFitsInPanel();
      }
      /*
   Show TTS is enabled or disabled.
    */
      function updateTTSStateView(isEnabled) {
        isSpeechEnabled = isEnabled;
        var ttsButton = getTTSButtonElement();
        endWaveAnimation();
        // Don't keep animating the wave hover effect after a click
        enableDimmingHover(false);
        // Don't use hover effects after a click
        // Set aria-checked so that screen readers speak the new state
        ttsButton.setAttribute("aria-checked", !!isEnabled);
        // Update the label for the TTS button
        setTTSLabel(isEnabled ? BP_CONST.SPEECH_STATE_LABELS.ON : BP_CONST.SPEECH_STATE_LABELS.OFF);
      }
      function getWaves() {
        return [ helper.byId(BP_CONST.WAVE_1_ID), helper.byId(BP_CONST.WAVE_2_ID), helper.byId(BP_CONST.WAVE_3_ID) ];
      }
      function nextWaveAnimationStep() {
        var waves = getWaves(), opacityData = BP_CONST.ANIMATE_WAVES_OPACITY;
        for (var waveNum = 0; waveNum < waves.length; waveNum++) {
          inlineStyle(waves[waveNum]).opacity = opacityData[waveNum][waveAnimationStepNum];
        }
        if (++waveAnimationStepNum < opacityData[0].length) {
          // Not finished with animation, do it again
          waveAnimationTimer = nativeGlobal.setTimeout(nextWaveAnimationStep, BP_CONST.ANIMATE_WAVES_STEP_DURATION);
        } else {
          endWaveAnimation();
        }
      }
      function endWaveAnimation() {
        var waves = getWaves();
        clearTimeout(waveAnimationTimer);
        waveAnimationStepNum = 0;
        for (var waveNum = 0; waveNum < waves.length; waveNum++) {
          inlineStyle(waves[waveNum]).opacity = "";
        }
      }
      // Animate waves if user hovers over TTS button, speech is off and animation is not already playing
      function beginHoverEffects() {
        if (!state.isPanel()) {
          return;
        }
        enableDimmingHover(true);
        if (!isSpeechEnabled && !waveAnimationStepNum) {
          nextWaveAnimationStep();
        }
      }
      function endHoverEffects() {
        endWaveAnimation();
        enableDimmingHover(false);
      }
      function enableDimmingHover(doEnable) {
        getTTSButtonElement().setAttribute("class", doEnable ? "scp-dim-waves" : "");
      }
      function toggleListeners(isOn) {
        if (isOn === isListeningToEvents) {
          return;
        }
        isListeningToEvents = isOn;
        var fn = isOn ? "addEventListener" : "removeEventListener", mouseTarget1 = getTTSButtonElement(), mouseTarget2 = helper.byId(BP_CONST.SPEECH_LABEL_ID);
        // Do not use click listeners when the panel is shrunk because it confused the Window-Eyes browse mode
        // (when Enter key was pressed on badge, it toggled speech)
        mouseTarget1[fn]("click", toggleSpeech);
        mouseTarget2[fn]("click", toggleSpeech);
        mouseTarget1[fn]("mouseover", beginHoverEffects);
        mouseTarget1[fn]("mouseout", endHoverEffects);
        mouseTarget1[fn]("mouseover", beginHoverEffects);
        mouseTarget1[fn]("mouseout", endHoverEffects);
      }
      /*
   Set up speech toggle.
    */
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        localizedSpeechString = locale.translate("speech");
        toggleListeners(true);
        events.on("bp/did-expand", function() {
          toggleListeners(true);
        });
        events.on("bp/will-shrink", function() {
          toggleListeners(false);
        });
        updateTTSStateView(isSpeechEnabled);
        waveAnimationStepNum = 0;
      }
      return {
        init: init,
        updateTTSStateView: updateTTSStateView
      };
    }(run_bp_constants, run_bp_helper, run_bp_model_state, run_locale, run_conf_preferences, run_events, run_platform, mini_core_native_global, run_inline_style_inline_style);
    bp_expanded_view_transform_util = function(inlineStyle, platform) {
      var SHOULD_USE_CSS_TRANSFORM_IN_SVG = !platform.browser.isMS && // MS does not support CSS in SVG
      true && // Safari CSS animations are actually slower
      true;
      // FF breaks getBoundingClientRect() when CSS transform is used
      // Skips past non-numeric characters and get the next number as type 'number'
      // It will include a negative sign and decimal point if it exists in the string
      function getNumberFromString(str) {
        return "number" === typeof str ? str : +str.match(/[0-9\.\-]+/);
      }
      function shouldUseCss(elem) {
        return SHOULD_USE_CSS_TRANSFORM_IN_SVG || !(elem instanceof SVGElement);
      }
      // Set @transform or CSS transform as appropriate
      // transformMap: {     // optional fields
      //   translateX: number
      //   translateY: number
      //   scale: number,
      //   scaleType: 'scaleX' || 'scaleY'
      //   rotate: number
      // }
      // scaleType can be 'scaleX' or 'scaleY'
      function setElemTransform(elem, transformMap) {
        var useCss = shouldUseCss(elem), transformString = getTransformString(transformMap, useCss);
        if (useCss) {
          // Always use CSS, even in SVG
          inlineStyle(elem).transform = transformString;
        } else {
          if (transformString) {
            elem.setAttribute("transform", transformString);
          } else {
            elem.removeAttribute("transform");
          }
        }
      }
      // Always get style transform
      function getStyleTransformMap(elem) {
        return getTransformMap(inlineStyle(elem).transform);
      }
      function getElemTransformMap(elem) {
        return shouldUseCss(elem) ? getStyleTransformMap(elem) : getAttrTransformMap(elem);
      }
      function getAttrTransformMap(elem) {
        return getTransformMap(elem.getAttribute("transform"));
      }
      function getTransformMap(transformString) {
        var // We use String.prototype.split to extract the values we want, and we need a
        // variable to store the intermediary result.  I'm not a huge fan of this.
        rotateValues, transformValues, hasTranslate = transformString && transformString.indexOf("translate") !== -1, hasScale = transformString && transformString.indexOf("scale") !== -1, hasScaleY = hasScale && transformString.indexOf("scale(1,") !== -1, // Only vertical scaling used (scaleY)
        hasRotate = transformString && transformString.indexOf("rotate") !== -1, translateY = 0, translateX = 0, scale = 1, rotate = 0;
        if (hasTranslate) {
          // translate is always first
          var separator = transformString.indexOf(",") > 0 ? "," : " ";
          // Attributes split by space, CSS by comma
          transformValues = transformString.split(separator);
          translateX = transformValues[0] || 0;
          translateY = hasScale ? transformValues[1].split("scale")[0] : transformValues[1] || 0;
        }
        if (hasScale) {
          if (hasScaleY) {
            // Only vertical scaling used (scaleY)
            transformValues = transformString.split("scale(1,");
          } else {
            transformValues = transformString.split("scale");
          }
          scale = hasRotate ? transformValues[1].split("rotate")[0] : transformValues[1];
        }
        if (hasRotate) {
          rotate = transformString.split("rotate")[1];
          if (rotate.indexOf(",") !== -1) {
            rotateValues = rotate.split(",");
            rotate = rotateValues[0];
          }
        }
        return {
          translateX: getNumberFromString(translateX),
          translateY: getNumberFromString(translateY),
          scale: getNumberFromString(scale),
          scaleType: hasScaleY ? "scaleY" : "scale",
          rotate: getNumberFromString(rotate)
        };
      }
      function getTransformString(transformMap, useCss) {
        var translateUnits = useCss ? "px" : "", hasTranslate = transformMap.translateX || transformMap.translateY, translateCSS = hasTranslate ? "translate(" + (transformMap.translateX || 0) + translateUnits + ", " + (transformMap.translateY || 0) + translateUnits + ") " : "", scale = transformMap.scale, hasScale = scale && 1 !== scale, scaleType = "scaleY" === transformMap.scaleType ? "scale(1," : "scale(", scaleCSS = hasScale ? scaleType + scale + ") " : "", rotate = transformMap.rotate, rotateUnits = useCss ? "deg" : "", rotateCSS = rotate ? " rotate(" + rotate + rotateUnits + ") " : "";
        return translateCSS + scaleCSS + rotateCSS;
      }
      return {
        getTransformMap: getTransformMap,
        getElemTransformMap: getElemTransformMap,
        getStyleTransformMap: getStyleTransformMap,
        setElemTransform: setElemTransform,
        shouldUseCss: shouldUseCss
      };
    }(run_inline_style_inline_style, run_platform);
    bp_expanded_view_transform_animate = function(objectUtil, inlineStyle, transformUtil, platform) {
      var requestFrameFn = window.requestAnimationFrame, cancelFrameFn = window.cancelAnimationFrame, // https://gist.github.com/gre/1650294
      timingFunctions = {
        "ease-out": function(t) {
          return --t * t * t + 1;
        },
        linear: function(t) {
          return t;
        }
      };
      function getFinalTransforms(toTransforms, fromTransforms) {
        var fromTransform, toTransform, finalTransforms = [], index = toTransforms.length;
        while (index--) {
          fromTransform = fromTransforms[index] || {};
          toTransform = toTransforms[index] || {};
          finalTransforms[index] = {
            translateX: "number" === typeof toTransform.translateX ? toTransform.translateX : fromTransform.translateX || 0,
            translateY: "number" === typeof toTransform.translateY ? toTransform.translateY : fromTransforms.translateY || 0,
            scale: "number" === typeof toTransform.scale ? toTransform.scale : fromTransform.scale || 1,
            scaleType: toTransform.scaleType,
            rotate: "number" === typeof toTransform.rotate ? toTransform.rotate : fromTransform.rotate || 0
          };
        }
        return finalTransforms;
      }
      function getOrigTransforms(elements) {
        var index = elements.length, origTransforms = [];
        // Get the original transforms for each element
        while (index--) {
          if (elements[index]) {
            origTransforms[index] = transformUtil.getElemTransformMap(elements[index]);
          }
        }
        return origTransforms;
      }
      function JsAnimation(elements, fromTransforms, toTransforms, duration, onFinish, timingFunctionName) {
        var animationStartTime = Date.now(), timingFn = timingFunctions[timingFunctionName], currAnimation = this;
        this.onFinish = onFinish;
        this.isRunning = true;
        this.onTick = tick;
        this.setDuration = setDuration;
        this.animationId = tick();
        // Start the animation automatically.
        function setDuration(newDuration) {
          duration = newDuration;
        }
        function tick() {
          var from, to, interim, time = duration > 0 ? timingFn(Math.min(1, (Date.now() - animationStartTime) / duration)) : 1, index = elements.length;
          while (index--) {
            if (elements[index]) {
              from = fromTransforms[index];
              to = toTransforms[index];
              interim = {
                translateX: from.translateX + (to.translateX - from.translateX) * time,
                translateY: from.translateY + (to.translateY - from.translateY) * time,
                scale: from.scale + (to.scale - from.scale) * time,
                scaleType: to.scaleType,
                rotate: from.rotate + (to.rotate - from.rotate) * time
              };
              transformUtil.setElemTransform(elements[index], interim);
            }
          }
          if (time < 1) {
            currAnimation.animationId = requestFrameFn(tick);
          } else {
            currAnimation.isRunning = false;
            if (onFinish) {
              onFinish();
            }
          }
        }
      }
      JsAnimation.prototype.finishNow = function() {
        if (this.isRunning) {
          if (this.onTick) {
            this.setDuration(0);
            this.onTick();
          }
          if (this.onFinish) {
            this.onFinish();
          }
          cancelFrameFn(this.animationId);
          this.isRunning = false;
        }
      };
      function CssAnimation(elements, fromTransforms, toTransforms, duration, onCustomFinish, timingFunctionName) {
        var isRunning = true;
        function initTransitionStyles(transition) {
          elements.forEach(function(elem) {
            if (elem) {
              var css = {
                transition: transition
              };
              if (transition) {
                css.transitionTimingFunction = timingFunctionName;
              }
              inlineStyle.set(elem, css);
            }
          });
        }
        // doTweak is used when we need to make sure to set a different value after a transition was removed
        function initTransforms(doTweak) {
          var toTransform, index = elements.length;
          while (index--) {
            if (elements[index]) {
              toTransform = toTransforms[index];
              if (doTweak) {
                toTransform = objectUtil.assign({}, toTransform);
                toTransform.translateY = (toTransform.translateY || 0) + .001;
              }
              transformUtil.setElemTransform(elements[index], toTransform);
            }
          }
        }
        function addTransitionEndListener() {
          elements[0].addEventListener(platform.transitionEndEvent, onFinish);
        }
        function removeTransitionEndListener() {
          elements[0].removeEventListener(platform.transitionEndEvent, onFinish);
        }
        function onFinish(evt) {
          // Don't bubble to a parent animation (e.g the secondary panel may still need to animate while a hover finishes animating)
          if (evt.target === evt.currentTarget) {
            evt.stopPropagation();
            finishNow();
          }
        }
        function finishNow() {
          if (isRunning) {
            // Don't finish twice
            isRunning = false;
            removeTransitionEndListener();
            initTransitionStyles("");
            // Disable the element transition by setting the style to ''
            initTransforms(true);
            if (onCustomFinish) {
              onCustomFinish();
            }
          }
        }
        function beginTransition() {
          addTransitionEndListener();
          initTransitionStyles("transform " + duration + "ms");
          getComputedStyle(elements[0]);
          // Force layout update
          requestAnimationFrame(initTransforms);
        }
        beginTransition();
        return {
          finishNow: finishNow
        };
      }
      function animateTransformLinear(element, value, duration) {
        return animateTransforms([ element ], [ value ], duration, null, "linear");
      }
      // Optimized transform animation that works via @transform on IE, CSS transition on other browsers
      // Currently only works with CSS transform, on element at a time
      function animateTransforms(elements, requestedTransforms, duration, onCustomFinish, timingFunctionName) {
        timingFunctionName = timingFunctionName || "ease-out";
        var animationType = transformUtil.shouldUseCss(elements[0]) ? CssAnimation : JsAnimation, fromTransforms = getOrigTransforms(elements), toTransforms = getFinalTransforms(requestedTransforms, fromTransforms);
        return new animationType(elements, fromTransforms, toTransforms, duration, onCustomFinish, timingFunctionName);
      }
      return {
        animateTransformLinear: animateTransformLinear,
        animateTransforms: animateTransforms
      };
    }(run_util_object_utility, run_inline_style_inline_style, bp_expanded_view_transform_util, run_platform);
    bp_expanded_view_transform_hovers = function(helper, BP_CONST, transformUtil, animate, events) {
      var isActivePanel = false, byId = helper.byId, HOVER_ANIMATION_MS = 500, savedHoverElems = [], uniqueId = 0, origTransforms = [], animations = [], hoverState = [];
      function getContainer() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      function toggleHover(target, isActiveHover) {
        if ("true" === target.getAttribute("aria-disabled") || !target.hasAttribute("data-hover")) {
          return;
        }
        var id = +target.getAttribute("data-id"), origTransform = origTransforms[id] || "", transformValue = origTransform + " " + (isActiveHover ? target.getAttribute("data-hover") : "");
        if (hoverState[id] === isActiveHover) {
          return;
        }
        if (animations[id]) {
          animations[id].finishNow();
        }
        animations[id] = animate.animateTransformLinear(target, transformUtil.getTransformMap(transformValue), HOVER_ANIMATION_MS);
        hoverState[id] = isActiveHover;
      }
      function onMouseOver(evt) {
        toggleHover(helper.getEventTarget(evt), true);
      }
      function onMouseMove(evt) {
        var index = savedHoverElems.length, x = evt.clientX, y = evt.clientY;
        while (index--) {
          if (hoverState[index] && evt.target !== savedHoverElems[index] && evt.target.parentNode !== savedHoverElems[index]) {
            var rect = savedHoverElems[index].getBoundingClientRect();
            if (x < rect.left - 1 || x > rect.right + 1 || y < rect.top - 1 || y > rect.bottom + 1) {
              toggleHover(savedHoverElems[index], false);
            }
          }
        }
      }
      function toggleMouseListeners(willBeActive) {
        if (isActivePanel === willBeActive) {
          return;
        }
        storeAllHoverElements();
        isActivePanel = willBeActive;
        var addOrRemoveFn = isActivePanel ? "addEventListener" : "removeEventListener", index = savedHoverElems.length;
        function addOrRemoveHovers(elem) {
          elem[addOrRemoveFn]("mouseenter", onMouseOver);
        }
        while (index--) {
          addOrRemoveHovers(savedHoverElems[index]);
        }
        window[addOrRemoveFn]("mousemove", onMouseMove);
      }
      function storeAllHoverElements() {
        var elem, allHoverElems = getContainer().querySelectorAll("[data-hover]"), index = allHoverElems.length;
        while (index--) {
          elem = allHoverElems[index];
          if (savedHoverElems.indexOf(elem) < 0) {
            // If not already saved
            savedHoverElems[uniqueId] = elem;
            elem.setAttribute("data-id", uniqueId);
            origTransforms[uniqueId] = elem.getAttribute("transform");
            ++uniqueId;
          }
        }
      }
      function cancelHovers() {
        var index = savedHoverElems.length;
        while (index--) {
          toggleHover(savedHoverElems[index], false);
        }
      }
      function hoversOn() {
        toggleMouseListeners(true);
      }
      function hoversOff() {
        toggleMouseListeners(false);
      }
      function refreshHovers() {
        // Ensure listeners are added for new content
        hoversOff();
        storeAllHoverElements();
        hoversOn();
      }
      function init() {
        refreshHovers();
        // Current expansion
        events.on("bp/did-expand zoom", hoversOn);
        // Future expansions
        events.on("bp/will-shrink zoom/begin", hoversOff);
        events.on("bp/did-init-secondary bp/content-loaded", refreshHovers);
        events.on("bp/will-show-secondary-feature", cancelHovers);
      }
      return {
        init: init
      };
    }(run_bp_helper, run_bp_constants, bp_expanded_view_transform_util, bp_expanded_view_transform_animate, run_events);
    bp_expanded_view_more_button = function(BP_CONST, helper, transformUtil, animate, hovers, state, events, inlineStyle, abTest, nativeGlobal) {
      var userInputTimeoutId, doAlwaysShowButton, isAfterUserInput, moreButtonContainer, moreOpacityElem, isInitialized, BUTTON_ENTER_ANIMATION_DURATION = 500, // Milliseconds
      BUTTON_ENTER_ANIMATION_DURATION_INSTANT = 0, NO_INPUT_TIMEOUT_DEFAULT = 3e3, // Oft-used functions. Putting it in a variable helps minifier, convenience, brevity
      byId = helper.byId;
      function getHelpOrSecondaryPanel(doToggle) {
        if (state.get("isClassicMode")) {
          !function(info) {
            if (doToggle) {
              info.showHelp();
            }
          }(info_info);
          return;
        }
        !function(secondary) {
          // Show or hide the secondary panel.
          secondary.init();
          if (doToggle) {
            secondary.toggleSecondaryPanel();
          }
        }(bp_secondary_bp_secondary);
      }
      function onMouseClick() {
        getHelpOrSecondaryPanel(true);
      }
      function addMouseListeners() {
        moreButtonContainer.addEventListener("click", onMouseClick);
      }
      function setSize(size) {
        transformUtil.setElemTransform(moreButtonContainer, {
          scale: size
        });
      }
      function showMoreButton(useInstantTransition) {
        byId(BP_CONST.BOTTOM_MOUSETARGET_ID).removeEventListener("mousemove", showMoreButtonSlowly);
        clearTimeout(userInputTimeoutId);
        moreOpacityElem.setAttribute("class", useInstantTransition ? "" : "scp-transition-opacity-fast");
        inlineStyle(moreOpacityElem).opacity = 1;
        // Scale the button to 0.5 and then animate it to a scale of 1
        if (!useInstantTransition) {
          setSize(.5);
          // Delay to fix Chrome animation bug
          // TODO WTF? We need to wait 30 ms? Tried requestAnimationFrame() and only 50% success rate
          nativeGlobal.setTimeout(function() {
            getComputedStyle(moreButtonContainer);
            // Force layout update
            animate.animateTransformLinear(moreButtonContainer, {
              scale: 1
            }, useInstantTransition ? BUTTON_ENTER_ANIMATION_DURATION_INSTANT : BUTTON_ENTER_ANIMATION_DURATION);
          }, 30);
        }
        // Once we show the button, always show it.
        doAlwaysShowButton = true;
        getHelpOrSecondaryPanel();
        // Preload
        // Add mouse listeners once BP is ready
        addMouseListeners();
      }
      function showMoreButtonSlowly() {
        showMoreButton(false);
      }
      function activate() {
        getHelpOrSecondaryPanel(true);
      }
      function showMoreButtonInstantly() {
        showMoreButton(true);
      }
      function show(callback) {
        showMoreButtonSlowly();
        if (callback) {
          nativeGlobal.setTimeout(callback, BUTTON_ENTER_ANIMATION_DURATION);
        }
      }
      function hideHelpButton() {
        moreOpacityElem.setAttribute("class", "");
        moreOpacityElem.style.opacity = 0;
        byId(BP_CONST.BOTTOM_MOUSETARGET_ID).removeEventListener("mousemove", showMoreButtonSlowly);
        clearTimeout(userInputTimeoutId);
      }
      function captureUserInput() {
        isAfterUserInput = true;
        byId(BP_CONST.SVG_ID).removeEventListener("mousedown", captureUserInput);
      }
      function showButtonIfNoUserInput() {
        if (!isAfterUserInput) {
          showMoreButton();
        }
      }
      // Three things may happen when the panel is expanded:
      // 1) Show the button immediately.
      // 2) Wait for the user to mouse over the bottom of the panel. If so, show the button.
      // 3) Wait and see if the user makes any actions in the panel. If not, show the button.
      function initButtonBehavior() {
        // If the user has already been presented with the button (during this page load),
        // there is no reason to not show it immediately whenever the panel is expanded.
        if (doAlwaysShowButton) {
          showMoreButtonSlowly();
          // Or use showMoreButton() to go back to showing the button instantly in this case
          return;
        }
        // Add event listener for mousing over the bottom of the panel
        byId(BP_CONST.BOTTOM_MOUSETARGET_ID).addEventListener("mousemove", showMoreButtonSlowly);
        // Add event listener for mouse down anywhere on the panel
        byId(BP_CONST.SVG_ID).addEventListener("mousedown", captureUserInput);
        // After NO_INPUT_TIMEOUT, we will be able to determine if the user has
        // pressed their mouse button.  If they have not, show the additional button.
        var noInputTimeoutMs = abTest.get("moreButtonTimerV2", NO_INPUT_TIMEOUT_DEFAULT);
        userInputTimeoutId = nativeGlobal.setTimeout(showButtonIfNoUserInput, noInputTimeoutMs);
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        // Get elements
        moreButtonContainer = byId(BP_CONST.MORE_BUTTON_CONTAINER_ID);
        moreOpacityElem = byId("scp-more-button-opacity");
        // Show immediately?
        doAlwaysShowButton = !state.get("isFirstBadgeUse");
        // After a complete expansion of the badge, determine if and when we will show
        // the "more" button.
        events.on("bp/did-expand", initButtonBehavior);
        // Future expansions
        initButtonBehavior();
        // First expansion is now
        // Allows other modules to show the more button.  For example, pressing the
        // tab key to navigate and operate the panel.
        events.on("bp/did-focus-more-button", showMoreButtonInstantly);
        // Always hide the more button when the panel is about to collapse.
        events.on("bp/will-shrink", hideHelpButton);
        //TODO: Once Edge gets itself together (see SC-3434) we should attach the button mouse listener here instead of after revealing it
        hovers.init();
      }
      return {
        init: init,
        show: show,
        activate: activate
      };
    }(run_bp_constants, run_bp_helper, bp_expanded_view_transform_util, bp_expanded_view_transform_animate, bp_expanded_view_transform_hovers, run_bp_model_state, run_events, run_inline_style_inline_style, run_ab_test_ab_test, mini_core_native_global);
    bp_expanded_bp_expanded = function(sliderController, shrinkController, focusController, scrollPrevention, ttsButton, moreButton, transform, helper, BP_CONST, state) {
      var isInitialized;
      function getFocusController() {
        return focusController;
      }
      function init() {
        if (!isInitialized) {
          state.set("scale", transform.getStyleTransformMap(helper.byId(BP_CONST.BP_CONTAINER_ID)).scale);
          sliderController.init();
          shrinkController.init();
          focusController.init();
          ttsButton.init();
          moreButton.init();
          scrollPrevention.init();
          !function(cursor) {
            cursor.init();
          }(page_cursor_cursor);
        }
        isInitialized = true;
      }
      return {
        init: init,
        getFocusController: getFocusController
      };
    }(bp_expanded_controller_slider_controller, bp_expanded_controller_shrink_controller, bp_expanded_controller_focus_controller, bp_expanded_controller_scroll_prevention, bp_expanded_view_tts_button, bp_expanded_view_more_button, bp_expanded_view_transform_util, run_bp_helper, run_bp_constants, run_bp_model_state);
    bp_secondary_font_charset = function(locale) {
      /**
   * Return 'latin-ext' if latin-ext font needed, etc.
   * @returns {*}
   */
      return function() {
        var currExtension, currLangs, lang = locale.getLang(), EXTENDED_LANGS = {
          "latin-ext": [ "hr", // Croatian
          "cs", // Czech
          "et", // Estonian
          "hu", // Hungarian
          "lv", // Latvian
          "lt", // Lithuanian
          "pl", // Polish
          "ro", // Romanian
          "sr", // Serbian
          "sk", // Slovak
          "sl", // Slovenian
          "tr" ]
        }, allExtensions = Object.keys(EXTENDED_LANGS), index = allExtensions.length;
        while (index--) {
          currExtension = allExtensions[index];
          currLangs = EXTENDED_LANGS[currExtension];
          if (currLangs.indexOf(lang) >= 0) {
            return currExtension;
          }
        }
      };
    }(run_locale);
    bp_secondary_insert_secondary_markup = function(finalizer, helper, platform, fontCharset, urls, events) {
      /*jshint multistr: true */
      var isInitialized, svgSecondary = // xmlns:xlink needed for outerHTML to work on docs with xhtml doctype
      '<g id="scp-secondary" class="scp-secondary-only" aria-label="{{more_features}}" xmlns:xlink="http://www.w3.org/1999/xlink">  <rect id="scp-secondary-fill" role="presentation" x="1" y="1" width="806" height="134" fill="#fff" stroke-width="0"/>  <g id="scp-bottom-secondary">    <use xlink:href="#scp-bottom-def"/>    <g id="scp-tips-label" role="button" class="scp-hand-cursor" data-feature="tips" aria-label="{{tips}}">      <text text-anchor="middle" x="75" y="178">{{tips}}</text>      <rect x="5" y="148" height="40" width="150" class="scp-hidden-target"/>    </g>    <g id="scp-settings-label" role="button" class="scp-hand-cursor" data-feature="settings" aria-label="{{settings}}">      <text text-anchor="middle" x="285" y="178">{{settings}}</text>      <rect x="200" y="148" height="40" width="165" class="scp-hidden-target"/>    </g>    <g id="scp-feedback-label" role="button" class="scp-hand-cursor" data-feature="feedback" aria-label="{{rate_us}}">      <text text-anchor="middle" x="517" y="178">{{rate_us}}</text>      <rect x="432" y="148" height="40" width="165" class="scp-hidden-target"/>    </g>    <g id="scp-about-label" role="button" class="scp-hand-cursor" data-feature="about" aria-label="{{about}}">      <text text-anchor="middle" x="730" y="178">{{about}}</text>      <rect x="660" y="148" height="40" width="145" class="scp-hidden-target"/>    </g>  </g>  <rect id="scp-card-header-bg" class="scp-secondary-feature-only" y="1" width="808" height="133" stroke="#C0BFBF" stroke-width="1" fill="#EEE"/>  <g>    <g id="scp-arrows" role="presentation" class="scp-transition-opacity scp-secondary-feature scp-if-settings scp-if-tips">      <g id="scp-prev-card" class="scp-arrow scp-hand-cursor scp-transition-opacity" transform="translate(640,72) rotate(90) scale(1.4)" role="button" aria-label="{{previous}}" aria-disabled="true">        <g data-hover="scale(1.3)">          <use xlink:href="#scp-arrow"/>          <rect class="scp-hidden-target" x="-25" y="-10" width="50" height="50"/>        </g>      </g>      <g id="scp-next-card" class="scp-arrow scp-hand-cursor" transform="translate(729,72) rotate(-90) scale(1.4)" role="button" aria-label="{{next}}">        <g data-hover="scale(1.3)">          <use xlink:href="#scp-arrow"/>          <rect class="scp-hidden-target" x="-25" y="-25" width="50" height="50"/>        </g>      </g>    </g>    <g id="scp-feedback" class="scp-if-feedback scp-transition-opacity scp-secondary-feature" role="group" aria-labelledby="scp-feedback-header">      <rect id="scp-feedback-input-rect" role="presentation" data-own-focus-ring="true" x="45" y="315" width="715" height="400" stroke-width="3" stroke="#aaa" fill="#fdfcfc" rx="20" ry="20"/>      <g id="scp-rating" class="scp-hand-cursor" role="group" aria-label="{{rating}}">        <use id="scp-stars-1" role="button" aria-pressed="false" aria-label="{{rating_1}}" class="scp-rating-star" xlink:href="#scp-rating-star-def" x="42" y="736"/>        <use id="scp-stars-2" role="button" aria-pressed="false" aria-label="{{rating_2}}" class="scp-rating-star" xlink:href="#scp-rating-star-def" x="108" y="736"/>        <use id="scp-stars-3" role="button" aria-pressed="false" aria-label="{{rating_3}}" class="scp-rating-star" xlink:href="#scp-rating-star-def" x="174" y="736"/>        <use id="scp-stars-4" role="button" aria-pressed="false" aria-label="{{rating_4}}" class="scp-rating-star" xlink:href="#scp-rating-star-def" x="240" y="736"/>        <use id="scp-stars-5" role="button" aria-pressed="false" aria-label="{{rating_5}}" class="scp-rating-star" xlink:href="#scp-rating-star-def" x="306" y="736"/>      </g>    </g>    <g id="scp-about" class="scp-if-about" transform="translate(805,16)">      <g id="scp-logo-text" role="presentation">        <image id="scp-sitecues-text" role="presentation" x="-11" y="-12" width="400" height="100"></image>        <text text-anchor="end" style="font-family:Open Sans;font-size:24px" y="96" x="300">{{zoom_and_speech}}</text>      </g>    </g>  </g>  <g id="scp-button-menu" transform="translate(52,66)">    <g id="scp-tips-button" class="scp-if-tips scp-hand-cursor scp-transition-opacity" role="button" data-feature="tips" aria-labelledby="scp-tips-label">      <g data-hover="scale(1.2)">        <circle r="52" fill="#548ECE"/>        <circle r="22" transform="translate(0,-14)" fill="#fff"/> <!-- Fix fill blink bug in Chrome -->        <path fill="#fff" stroke="#fff" stroke-width="3" stroke-miterlimit="10" d="m.9,-34.3c12.3,0 22.2,10 22.2,22.2c0,12.1 -7.3,13.5 -8.7,26.7c0,1.2 -1,2.2 -2.2,2.2h-11.4m.1,0h-.1h-11.3c-1.2,0 -2.2,-1 -2.2,-2.2c-1.4,-13.2 -8.7,-14.6 -8.7,-26.7c0,-12.3 10,-22.2 22.2,-22.2"/>        <path fill="#fff" d="m14,23.5c0,1.2 -1,2.2 -2.2,2.2h-22.2c-1.2,0 -2.2,-1 -2.2,-2.2c0,-1.2 1,-2.2 2.2,-2.2h22.2c1.2,0 2.2,1 2.2,2.2zm0,6.5c0,1.2 -1,2.2 -2.2,2.2h-22.2c-1.2,0 -2.2,-1 -2.2,-2.2c0,-1.2 1,-2.2 2.2,-2.2h22.2c1.2,0 2.2,1 2.2,2.2zm-27,4.5h23c0,2.5 -2,4.5 -4.5,4.5h-8.9c-2.5,0 -4.5,-2 -4.5,-4.5l0,0l0,0l.1,0l-5.2,0z"/>        <rect fill="none" width="120" height="120" y="-60" x="-60" class="scp-hand-cursor"/>      </g>    </g>    <g id="scp-settings-button" class="scp-if-settings scp-hand-cursor scp-transition-opacity" role="button" data-feature="settings" aria-labelledby="scp-settings-label">      <g data-hover="scale(1.2)">        <path d="m-36,47.8c0,1.3 1,2.3 2.3,2.3h6.2c1.3,0 2.3,-1 2.3,-2.3v-90.8c0,-1.3 -1,-2.3 -2.3,-2.3h-6.2c-1.3,0 -2.3,1 -2.3,2.3v91l0,-.2zm61.4,0c0,1.3 1,2.3 2.3,2.3h6.2c1.3,0 2.3,-1 2.3,-2.3v-90.8c0,-1.3 -1,-2.3 -2.3,-2.3h-6c-1.3,0 -2.3,1 -2.3,2.3v90.8l-.2,0zm-30.7,0c0,1.3 1,2.3 2.3,2.3h6.2c1.3,0 2.3,-1 2.3,-2.3v-90.8c0,-1.3 -1,-2.3 -2.3,-2.3h-6c-1.3,0 -2.3,1 -2.3,2.3v90.8l-.2,0z" fill="#7B7B7B"/>        <path d="m-19.7,4.5c0,1.3 -1,2.3 -2.3,2.3h-17.1c-1.3,0 -2.3,-1 -2.3,-2.3v-5.3c0,-1.3 1,-2.3 2.3,-2.3h17.1c1.3,0 2.3,1 2.3,2.3v5.3l0,0zm30.7,-28.5c0,1.3 -1,2.3 -2.3,2.3h-17.1c-1.3,0 -2.3,-1 -2.3,-2.3v-5.2c0,-1.3 1,-2.3 2.3,-2.3h17.1c1.3,0 2.3,1 2.3,2.3v5.40001l0,-.2zm31.5,46.4c0,1.3 -1,2.3 -2.3,2.3h-17.1c-1.3,0 -2.3,-1 -2.3,-2.3v-5.3c0,-1.3 1,-2.3 2.3,-2.3h17.1c1.3,0 2.3,1 2.3,2.3v5.3l0,0z" fill="#548ECE"/>        <rect fill="none" width="120" height="120" y="-60" x="-60" class="scp-hand-cursor"/>      </g>    </g>    <g id="scp-feedback-button" class="scp-if-feedback scp-hand-cursor scp-transition-opacity" role="button" data-feature="feedback" aria-labelledby="scp-feedback-label">      <g data-hover="scale(1.2)">        <path d="m-10,40c3,1 7,1 11,1c27,0 49,-19 49,-43c0,-24 -22,-44 -49,-44c-27,0 -50,19 -50,43c0,12 6,23 15,31c-2.2,9.2 -7.6,14.8 -17,20.7c15,-1 25,2 41,-9" stroke="#548ECE" stroke-miterlimit="5" stroke-linejoin="round" stroke-linecap="round" stroke-width="5.5" fill="#FFF"/>        <rect fill="none" width="120" height="120" y="-60" x="-60" class="scp-hand-cursor"/>      </g>    </g>    <g id="scp-about-button" class="scp-if-about scp-hand-cursor scp-transition-opacity" role="button" data-feature="about" aria-labelledby="scp-about-label">      <g id="scp-about-rotate-helper" role="presentation">        <g data-hover="scale(1.2)">          <path d="m15.8,-9.5h-11.2c-1,0 -3.4,3.9 -3.4,5.2l.1,15.3l-49.8,6.1h0c-1.6,-5 -2.5,-10.3 -2.5,-15.8c0,-27.9 22.6,-50.4 50.4,-50.4c21.2,0 39.4,13 46.8,31.7h0c5,11.2 0,22.2 -10.89999,24.1l-16.10001,2l0,-13.1c0,-1.2 -2.39999,-5.1 -3.39999,-5.1zm-7,47.3c1.6,1.89999 2.8,0 2.8,0l7.1,-11.10001c.2,-.3 .4,-.6 .4,-1v0v-4h26.4h0c-7.8,17.8 -25.5,30.3 -46.2,30.3c-20.7,0 -38.4,-12.4 -46.2,-30.3v0h48.1v4.3c0,.3 .2,.6 .4,.9l7.2,10.9z" fill="#000"/>          <rect fill="none" width="120" height="120" y="-60" x="-60" class="scp-hand-cursor"/>        </g>      </g>    </g>  </g>  <g id="scp-secondary-outline" role="presentation">    <path d="M808 186.5c0 6-5 11-11 11H11.5 c-6 0-11-5-11-11" fill="transparent" stroke="#999" stroke-width="1.5"/>    <line stroke="#999" stroke-width="1.5" x1=".5" y1="-700" x2=".5" y2="188"/>    <line stroke="#999" stroke-width="1.5" x1="808" y1="-700" x2="808" y2="188"/>  </g>  <line stroke="#999" stroke-width="1" x1="0" y1=".5" x2="808" y2=".5"/> <!-- outline top --></g>', htmlSecondary = '<sc-h1 id="scp-feedback-header" class="scp-card-header scp-secondary-feature">{{rate_us}}</sc-h1><sc class="scp-secondary-feature scp-transition-opacity scp-if-feedback" role="group" aria-labelledby="scp-feedback-header">  <sc-p id="scp-feedback-prompt">{{rate_us_suggest}} {{rate_us_prompt}}</sc-p>  <textarea id="scp-feedback-textarea" class="scp-hand-cursor" data-allow-scroll="true"     aria-describedby="scp-feedback-prompt" data-visible-focus-on="scp-feedback-input-rect" placeholder="{{tell_us_something}}"></textarea>  <sc-button id="scp-feedback-send-button" aria-disabled="true"><a class="scp-button-link scp-hand-cursor" id="scp-feedback-send-link" class="scp-hand-cursor" data-mailto="mailto:support@sitecues.com">{{send}}</a></sc-button>.</sc><sc id="scp-feedback-thanks" class="scp-if-feedback-sent scp-secondary-feature" role="note" aria-label="{{thank_you}}">  <sc-h1>{{thank_you}}</sc-h1></sc><sc class="scp-about-teaser scp-if-about scp-transition-opacity scp-secondary-feature" role="group" aria-label="{{about}} sitecues">  <sc-p>    <sc-span id="scp-about-preamble">{{about_preamble}}</sc-span>    <a class="scp-link scp-hand-cursor" id="scp-about-sitecues-link" aria-describedby="scp-about-preamble scp-about-sitecues-link" target="_blank" href="https://sitecues.com?utm_source=sitecues-badge-panel&amp;utm_medium=bp3&amp;utm_campaign=BP_redirect&amp;utm_content=link">sitecues.com</a>.  </sc-p>  <sc-p id="scp-about-rate-footer">    <sc-span id="scp-rate-us-suggest" role="heading">{{about_rate_us}}</sc-span><br/>    <sc-button id="scp-about-rate-button" class="scp-hand-cursor" role="button" aria-label="{{rate_us}}" aria-describedby="scp-rate-us-suggest">{{rate_us}}</sc-button>  </sc-p></sc>';
      function insertHtml(insertionId, markup) {
        var where = helper.byId(insertionId), finalMarkup = finalizer(markup);
        where.outerHTML = finalMarkup;
      }
      function insertSvg(insertionId, markup) {
        // Unfortunately innertHTML, outerHTML, insertAdjacentHTML do not work for <svg> in Safari (or probably IE)
        // We have to create the elements in the SVG namespace and then insert it
        var svgElement, svgContentToInsert, where = helper.byId(insertionId), finalMarkup = finalizer(markup), divElement = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
        // Use HTML element so that we can use innerHTML property
        divElement.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + finalMarkup + "</svg>";
        svgElement = divElement.firstChild;
        // This is the <svg> element
        svgContentToInsert = svgElement.firstChild;
        // This is the actual content we want
        where.parentNode.replaceChild(svgContentToInsert, where);
      }
      function insertSheet(name) {
        var cssLink = document.createElement("link"), cssUrl = urls.resolveResourceUrl("css/" + name + ".css");
        cssLink.setAttribute("rel", "stylesheet");
        cssLink.setAttribute("href", cssUrl);
        cssLink.id = "sitecues-js-" + name;
        document.querySelector("head").appendChild(cssLink);
      }
      function insertSheets() {
        // CSS: always use secondary.css
        insertSheet("secondary");
        // CSS: use latin-ext.css etc. if necessary
        var extendedFontCharsetName = fontCharset();
        if (extendedFontCharsetName) {
          insertSheet(extendedFontCharsetName);
        }
        // CSS: use vendor stylesheet as well (e.g. secondary-moz.css, secondary-ie.css, secondary-webkit.css)
        if (platform.cssPrefix) {
          insertSheet("secondary" + platform.cssPrefix);
        }
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          insertHtml("scp-html-secondary-anchor", htmlSecondary);
          insertSvg("scp-secondary-anchor", svgSecondary);
          insertSheets();
          events.emit("bp/did-insert-secondary-markup");
        }
      }
      return {
        init: init
      };
    }(run_bp_view_markup_finalizer, run_bp_helper, run_platform, bp_secondary_font_charset, run_conf_urls, run_events);
    bp_secondary_tips = function(BP_CONST, helper, events, nativeGlobal, inlineStyle) {
      var isInitialized, byId = helper.byId, animationTimers = [], animationFns = {
        "scp-zoom-card": "zoom",
        "scp-zoom-keys-card": "zoom",
        "scp-highlight-card": "highlight",
        "scp-lens-card": "lens",
        "scp-speech-card": "lens",
        "scp-full-guide-card": "none"
      }, animationFnMap = {
        zoom: animateZoom,
        highlight: animateHighlight,
        lens: animateLens
      }, ACTORS = [ BP_CONST.DEMO_PAGE_CONTENTS, BP_CONST.DEMO_PARA, BP_CONST.DEMO_MOUSE, //        BP_CONST.DEMO_ZOOM_PLUS,
      //        BP_CONST.DEMO_ZOOM_MINUS,
      BP_CONST.DEMO_LENS_SPACE ];
      function getGeometryTargets(cssValues) {
        return cssValues;
      }
      function cardActivated(id) {
        // Clear existing tips animations
        animationTimers.forEach(clearTimeout);
        animationTimers.length = 0;
        ACTORS.forEach(clearElementDemo);
        // Find an appropriate animation
        var demoPage, hasAnimation, newAnimation = animationFns[id];
        if (!newAnimation) {
          return;
        }
        demoPage = byId(BP_CONST.DEMO_PAGE);
        hasAnimation = "none" !== newAnimation;
        demoPage.setAttribute("data-hasdemo", hasAnimation);
        if (hasAnimation) {
          // Run the animation function for this card (if any)
          animationFnMap[newAnimation](id);
          // Set a class on the demo-page element so it knows what's up
          demoPage.className = "scp-demo-" + newAnimation;
          byId(BP_CONST.TIPS_CONTENT_ID).setAttribute("data-active", id);
        }
      }
      function pushTimeout(fn, howLongMs) {
        animationTimers.push(nativeGlobal.setTimeout(fn, howLongMs));
      }
      // Reset demo page element back to original state
      function clearElementDemo(id) {
        var elem = byId(id);
        if (elem) {
          // Reset element back to normal position instantly (temporarily turn of animations)
          elem.setAttribute("data-demo", false);
          inlineStyle(elem).transitionDuration = "0s";
          nativeGlobal.setTimeout(function() {
            inlineStyle(elem).transitionDuration = "";
          }, 20);
        }
      }
      // Optional -- howLongMs is how long to wait before doing it
      function toggleElementDemo(id, isOn, howLongMs) {
        function toggle() {
          byId(id).setAttribute("data-demo", isOn || false);
        }
        pushTimeout(toggle, howLongMs || 0);
      }
      function animateZoom() {
        function toggleZoom(isOn, key, howLongMs) {
          toggleElementDemo(BP_CONST.DEMO_PAGE_CONTENTS, isOn, howLongMs);
          // Zoom page
          toggleElementDemo(BP_CONST.DEMO_SLIDER_THUMB, isOn, howLongMs);
          // Move slider
          toggleElementDemo(key, true, howLongMs);
          // Push key
          toggleElementDemo(key, false, howLongMs + 2e3);
        }
        function zoomThenUnzoom() {
          toggleZoom(true, BP_CONST.DEMO_ZOOM_PLUS, 2e3);
          toggleZoom(false, BP_CONST.DEMO_ZOOM_MINUS, 6e3);
        }
        zoomThenUnzoom();
        pushTimeout(zoomThenUnzoom, 8e3);
      }
      function animateHighlight() {
        function highlightThenUnhighlight() {
          toggleElementDemo(BP_CONST.DEMO_MOUSE, true, 2e3);
          toggleElementDemo(BP_CONST.DEMO_PARA, true, 4e3);
          toggleElementDemo(BP_CONST.DEMO_MOUSE, false, 6e3);
          toggleElementDemo(BP_CONST.DEMO_PARA, false, 6500);
        }
        highlightThenUnhighlight();
        pushTimeout(highlightThenUnhighlight, 9999);
      }
      function animateLens(id) {
        function toggleSpacebar(isPressed) {
          toggleElementDemo(BP_CONST.DEMO_LENS_SPACE, isPressed);
          toggleElementDemo(BP_CONST.DEMO_SPEECH_SPACE, isPressed);
        }
        function pressSpacebar() {
          toggleSpacebar(true);
          pushTimeout(toggleSpacebar, 1e3);
        }
        function openThenCloseLens() {
          !function(audio) {
            function speakIt() {
              audio.speakContent(byId(BP_CONST.DEMO_PARA), true);
            }
            pushTimeout(pressSpacebar, 2e3);
            toggleElementDemo(BP_CONST.DEMO_PARA, true, 3200);
            // Open lens
            if ("scp-speech-card" === id) {
              pushTimeout(speakIt, 3200);
            }
            pushTimeout(pressSpacebar, 6e3);
            toggleElementDemo(BP_CONST.DEMO_PARA, false, 7200);
          }(audio_audio);
        }
        openThenCloseLens();
        pushTimeout(openThenCloseLens, 12e3);
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          events.on("bp/did-show-card", cardActivated);
        }
      }
      return {
        getGeometryTargets: getGeometryTargets,
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_events, mini_core_native_global, run_inline_style_inline_style);
    page_style_service_user_agent_css = function() {
      /*jshint multistr: true */
      // The following system colors are converted to hex colors here to improve performance:
      // button { color:ButtonText; border-color:ButtonFace; background-color:ButtonFace; }
      // input:disabled, select:disabled {color:GrayText; background-color:ThreeDFace; }
      var text = 'html{\n  cursor:default;\n}\na,input,textarea,select,button,label{\n  cursor:pointer;\n}\nbody{\n    background-color:#fff;\n    color:#000;\n}\nselect{\n  background-color:#fff;\n  color:#000;\n  border-color:#fff;\n}\ntextarea,input,button{\n  color:#000;\n  border-color:#c0c0c0;\n  background-color:#fff;\n}\ninput:disabled, select:disabled {\n  color:#7f7f7f !important;\n  background-color:#c0c0c0 !important;\n}\nblockquote[type="cite"] {\n  border-color:#00f;\n}\nmark {\n  background-color:#ffff00;\n  color:#000;\n}\nhr {\n  color:#808080;\n}\nimg[usemap], object[usemap] {\n  color:#00f;\n}\na{\n  color:#00f;\n}\na:visited {\n  color:#551a8b;\n}';
      return text;
    }();
    page_style_service_media_queries = function() {
      function isActiveMediaQuery(mediaQuery) {
        // No media query or a matching one
        var trimmedQuery = "string" === typeof mediaQuery ? mediaQuery.trim() : "";
        return !trimmedQuery || window.matchMedia(trimmedQuery).matches;
      }
      return {
        isActiveMediaQuery: isActiveMediaQuery
      };
    }();
    page_style_service_css_aggregator = function($, UA_CSS, urls, mediaQueries, nativeGlobal) {
      var onCssReadyFn, numPending = 0, sheets = [], INLINE_ID_ATTR = "data-sc-inline", // Allow each element with inline @style to have own ID for use with stylesheets
      //This kept timing out at 2 seconds
      TIMEOUT_MS = 6e3;
      /**
   * StyleSheet object constructor. This object represents one stylesheet on the page,
   * either from a <link rel="stylesheet">, a <style> or an @import.
   * Caller should provide a url or text, but not both.
   * @param url The url of the stylesheet to fetch
   * @param text The text of the stylesheet if already known (ignored if there is a url)
   * @param debugName [optional] -- a name for the stylesheet to help with debugging
   * @constructor
   */
      function StyleSheet(url, text, debugName) {
        this.url = url;
        if (true) {
          this.debugName = debugName;
        }
        ++numPending;
        var currentSheet = this;
        if (url) {
          // We will need to retrieve this stylesheet over the network
          var request = createGetRequest(url);
          request.url = url;
          // Only apply the request if the response status < 400 (>=400 means error but onerror not called!)
          request.onload = function(evt) {
            var request = evt.target || this;
            if (request.status < 400) {
              currentSheet.text = request.responseText;
            }
            markReady(currentSheet);
          };
          request.onerror = function() {
            // Still need to mark it ready even though we don't have any CSS text for it,
            // otherwise the numPending will not return to 0 and we will never finish aggregating the CSS
            markReady(currentSheet);
          };
          currentSheet.errorTimeout = nativeGlobal.setTimeout(function() {
            markReady(currentSheet);
          }, TIMEOUT_MS);
          request.send();
        } else {
          // A <style> already has it's text --
          // as opposed to a <link href> which will be marked ready after it's loaded
          currentSheet.text = text || "";
          nativeGlobal.setTimeout(function() {
            // Use the setTimeout as a fake fetch that will simply provide the text we already have.
            // (We don't want to mark ready until all the sheets are added to the queue, otherwise we could finish too early)
            markReady(currentSheet);
          }, 0);
        }
      }
      // CSS proxy passes us the CSS text whether or not cross-origin policy allows it
      // Example of page that needs this: http://www.dcmetrobln.org/about-us
      function getCssProxyUrl(url) {
        if (0 === url.indexOf("data:")) {
          return url;
        }
        return urls.getProxyApiUrl("css/passthrough", url);
      }
      /**
   * Cross browser solution to initiating an XMLHTTPRequest
   * that supports the Origin HTTP header
   * @param  {string} method
   * @param  {string} url
   * @return {Object}
   */
      function createGetRequest(url) {
        // Unsafe cross-origin request
        // - Will run into cross-origin restrictions because URL is from different origin
        // This is not an issue with the extension, because the content script doesn't have cross-origin restrictions
        var isUnsafeRequest = false;
        if (isUnsafeRequest) {
          if (true) {
            console.log("Cross-Origin: " + url);
          }
          // Use sitecues CSS proxy to bypass CORS restrictions on fetching CSS text for analysis
          url = getCssProxyUrl(url);
        }
        // Credit to Nicholas Zakas
        // http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.setRequestHeader("Accept", "text/css,text/plain");
        return xhr;
      }
      // Once a sheet is ready, mark it as complete and finalize the process if there are no pending sheet requests
      function markReady(sheet) {
        if (sheet.isFinished) {
          return;
        }
        sheet.isFinished = true;
        --numPending;
        clearTimeout(sheet.errorTimeout);
        processSheetCss(sheet);
        finalizeCssIfComplete();
      }
      /**
   * Replace all relatively defined style resources with their absolute counterparts. See SC-1302.
   * @param  {StyleSheet} sheet    A stylesheet object with text
   */
      function convertRelativeUrlsToAbsolute(sheet) {
        /*
         One of our goals is to extract from a CSS file all relative URLs. This document outlines
         valid URLs for CSS: http://www.w3.org/TR/CSS21/syndata.html#uri
    
         The RegEx below will MATCH the following:
    
         background: url(instant/templates/_default_/images/nyromodal/close.gif);
         background: url('instant/templates/_default_/images/nyromodal/close.gif');
         background: url("instant/templates/_default_/images/nyromodal/close.gif");
         background: url(  instant/templates/_default_/images/nyromodal/close.gif  );
         background: url(./instant/templates/_default_/images/nyromodal/close.gif);
         background: url('./instant/templates/_default_/images/nyromodal/close.gif');
         background: url("./instant/templates/_default_/images/nyromodal/close.gif");
         background: url(  ./instant/templates/_default_/images/nyromodal/close.gif  );
         background: url(../instant/templates/_default_/images/nyromodal/close.gif);
         background: url('../instant/templates/_default_/images/nyromodal/close.gif');
         background: url("../instant/templates/_default_/images/nyromodal/close.gif");
         background: url(  ../../instant/templates/_default_/images/nyromodal/close.gif  );
    
         The RegEx below will IGNORE the following:
    
         background: url(http://example.ru/templates/_default_/close.gif)
         background: url(https://instant/templates/_default_/images/nyromodal/close.gif);
         background: url('http://example.ru/templates/_default_/close.gif')
         background: url('https://instant/templates/_default_/images/nyromodal/close.gif');
         background: url("http://example.ru/templates/_default_/close.gif")
         background: url("https://instant/templates/_default_/images/nyromodal/close.gif");
         background: url(   http://example.ru/templates/_default_/close.gif   )
         background: url(   https://instant/templates/_default_/images/nyromodal/close.gif   );
         background:url(data:jpg;base64,/QL9Av0GaqAAA//2Q==)
         background: url(//int.nyt.com/applications/portals/assets/loader-t-logo-32x32-ecedeb-49955d7789658d80497f4f2b996577f6.gif)
         */
        var RELATIVE_URL_REGEXP = /url\((?:(?:[\'\" ])*(?!data:|https?:\/\/|\/\/)([^\"\'\)]+)[\'\" ]*)/gi;
        return sheet.text.replace(RELATIVE_URL_REGEXP, function(totalMatch, actualUrl) {
          // totalMatch includes the prefix string  url("      - whereas actualUrl is just the url
          return "url(" + urls.resolveUrl(actualUrl, sheet.url);
        });
      }
      // Clear CSS comments out of the current string
      function removeComments(sheet) {
        // From http://blog.ostermiller.org/find-comment
        var COMMENTS_REGEXP = /\/\*(?:[^*]|[\r\n]|(?:\*+(?:[^*\/]|[\r\n])))*\*+\//g;
        return sheet.text.replace(COMMENTS_REGEXP, "");
      }
      // Convert @import into new stylesheet requests
      function processAtImports(sheet) {
        var IMPORT_REGEXP = /\s*(?:@import\s+(?:url\()?(?:(?:['" ])*([^"'\)]+)['" ]*)(?:\))?\s*([^;$]*))/gi;
        return sheet.text.replace(IMPORT_REGEXP, function(totalMatch, actualUrl, mediaQuery) {
          // Insert sheet for retrieval before this sheet, so that the order of precedence is preserved
          mediaQuery = mediaQuery.split(";")[0];
          if (true && mediaQuery) {
            console.log("@import media query: " + mediaQuery);
          }
          if (mediaQueries.isActiveMediaQuery(mediaQuery) && isUsableCssUrl(actualUrl)) {
            insertNewSheetBefore(sheet, urls.resolveUrl(actualUrl, sheet.url));
          }
          // Now remove @import line from CSS so that it does not get reprocessed
          return "";
        });
      }
      // Perform post-processing on the CSS text in the style sheet
      function processSheetCss(sheet) {
        // Ensure some text even in the case of an error
        sheet.text = sheet.text || "";
        // Remove comments so that they do not interfere,
        // after all we don't want to process commented-out @imports!
        sheet.text = removeComments(sheet);
        // Convert relative URLS to absolute
        if (sheet.url) {
          sheet.text = convertRelativeUrlsToAbsolute(sheet);
        }
        // Convert imports into new pending sheets
        sheet.text = processAtImports(sheet);
      }
      function insertNewSheetBefore(insertBeforeSheet, urlForNewSheet) {
        var debugName = true && "@import " + urlForNewSheet, insertionIndex = sheets.indexOf(insertBeforeSheet), newSheet = new StyleSheet(urlForNewSheet, null, debugName);
        sheets.splice(insertionIndex, 0, newSheet);
      }
      function addSheet(url, text, debugName) {
        var newSheet = new StyleSheet(url, text, debugName);
        sheets.push(newSheet);
      }
      function hasPendingRequests() {
        return numPending > 0;
      }
      function finalizeCssIfComplete() {
        if (hasPendingRequests()) {
          return;
        }
        // Concatenate retrieved CSS text
        var allCss = "";
        sheets.forEach(function(sheet) {
          if (true) {
            allCss += "\n/***** " + sheet.debugName + " *****/\n\n";
          }
          allCss += (sheet.text || "") + "\n";
        });
        // Clear the sheets references and free the memory
        sheets.length = 0;
        // Use callback
        onCssReadyFn(allCss);
      }
      // Needed to support deprecated @bgcolor
      // for example on http://www.nhptv.org/natureworks/fisher.htm
      function addDeprecatedAttributeStyles() {
        var bgColors = {}, cssText = "";
        $("body[bgColor],table[bgcolor],td[bgcolor],th[bgcolor]").each(function() {
          bgColors[this.getAttribute("bgcolor")] = 1;
        });
        Object.keys(bgColors).forEach(function(bgColor) {
          cssText += '[bgColor="' + bgColor + '"] { background-color:' + bgColor + " }\n";
        });
        if (cssText) {
          addSheet(null, cssText, "bgcolor attrs");
        }
      }
      // Needed to support hacky inline style attributes
      // for example background-image on http://www.classifieds.faast.org/
      function addInlineStyles() {
        var cssText = "";
        $("body [style]").not("#sitecues-badge,#sitecues-badge *").each(function(index, element) {
          $(element).attr(INLINE_ID_ATTR, index);
          cssText += "[" + INLINE_ID_ATTR + '="' + index + '"] {' + element.getAttribute("style") + "}\n";
        });
        if (cssText) {
          addSheet(null, cssText, "inline style attrs");
        }
      }
      /**
   * Initiates the collection of all style sheet text
   */
      function collectAllCss(cssReadyCallbackFn) {
        onCssReadyFn = cssReadyCallbackFn;
        if ("loading" !== document.readyState) {
          collectAllCssImpl();
        } else {
          document.addEventListener("DOMContentLoaded", collectAllCssImpl);
        }
      }
      function isUsableCssUrl(url) {
        // Sitecues does not need to process CSS3 fonts, at least for now -- waste of processing
        // Fill in more common font pattern libraries here
        // The benefit is less work and speedier processing of site CSS
        var GOOGLE_FONT_PATTERN = "//fonts.google";
        return url.indexOf(GOOGLE_FONT_PATTERN) < 0;
      }
      function collectAllCssImpl() {
        function startsWith(s1, s2) {
          return s1.substr(0, s2.length) === s2;
        }
        function isUsableLinkedStyleSheet(linkElem) {
          // Ignore all CSS with the wrong media, e.g. print
          return mediaQueries.isActiveMediaQuery(linkElem.media) && isUsableCssUrl(linkElem.href);
        }
        function isUsableStyleElement(styleElem) {
          return !!styleElem.firstChild;
        }
        function isUsable(index, elem) {
          var SITECUES_STYLE_ID_PREFIX = "sitecues-js-", // <style id="sitecues-js-XXX"> are sitecues stylesheets
          id = elem.id;
          if (!id || !startsWith(id, SITECUES_STYLE_ID_PREFIX)) {
            return "link" === elem.localName ? isUsableLinkedStyleSheet(elem) : isUsableStyleElement(elem);
          }
        }
        function addSheetForElem(index, elem) {
          var isLink = "link" === elem.localName, href = isLink && elem.href, text = !isLink && elem.firstChild.data, debugName = true && elem.localName + " " + (href || "");
          return addSheet(href, text, debugName);
        }
        // First come the default user agent CSS rules
        addSheet(null, UA_CSS, "User agent styles");
        // Add styles to make up for deprecated bgcolor attribute
        addDeprecatedAttributeStyles();
        // Add styles to deal with inline style="foo" attributes?
        addInlineStyles();
        // Next add <link> and <style> sheets, in document order
        var $styleElems = $('link[rel="stylesheet"],style').filter(isUsable);
        $styleElems.each(addSheetForElem);
      }
      return {
        collectAllCss: collectAllCss
      };
    }($, page_style_service_user_agent_css, run_conf_urls, page_style_service_media_queries, mini_core_native_global);
    page_style_service_style_service = function($, cssAggregator, mediaQueries, platform, nativeGlobal) {
      var isInitialized, isCssRequested, // Have we even begun the init sequence?
      isCssComplete, domStylesheetObjects = [], SITECUES_COMBINED_CSS_ID = "sitecues-js-combined-css", WAIT_BEFORE_USING_STYLESHEET_DATA = 50, CSS_MAX_CHUNK_SIZE = 5e3, // Max number of CSS chars to process at once
      DOM_STYLESHEET_KEY = "DOMSS", // Init sequence is complete
      callbackFns = [], debugTime = {};
      function addChunk(css, chunks, start, end) {
        var newChunk = css.substring(start, end), numChunks = chunks.length;
        if (chunks[numChunks - 1].length + newChunk.length < CSS_MAX_CHUNK_SIZE) {
          // Still fits within size threshold, just add to last chunk
          chunks[numChunks - 1] += newChunk;
        } else {
          chunks[numChunks] = newChunk;
        }
      }
      // Each } that is not inside an outer {} ends a legal chunk of CSS
      // We've already removed comments, so no need to worry about those
      function chunkCssByClosingBrace(css) {
        var nextClosingBrace, nextOpeningBrace, chunks = [ "" ], lastChunkStart = 0, position = 0, braceDepth = 0;
        while (true) {
          nextClosingBrace = css.indexOf("}", position);
          nextOpeningBrace = css.indexOf("{", position);
          if (nextOpeningBrace >= 0 && nextOpeningBrace < nextClosingBrace) {
            braceDepth++;
            // Now 1 if not already inside other braces
            position = nextOpeningBrace + 1;
            continue;
          } else {
            if (nextClosingBrace >= 0) {
              braceDepth--;
              position = nextClosingBrace + 1;
              if (0 === braceDepth) {
                // The end of a CSS block
                addChunk(css, chunks, lastChunkStart, position);
                lastChunkStart = position;
              } else {
                if (braceDepth < 0) {
                  if (true) {
                    console.log("Error parsing CSS ... brace mismatch at %s", css.substring(0, nextClosingBrace + 1));
                  }
                  addChunk(css, chunks, lastChunkStart, css.length);
                  break;
                } else {}
              }
            } else {
              // Last chunk
              addChunk(css, chunks, lastChunkStart, css.length);
              break;
            }
          }
        }
        return chunks;
      }
      // Sometimes CSS that's too large creates huge performance problems in IE, locking up the browser
      // There seems to be a size threshold where the problems don't occur if they are under that
      // Note: not necessary in Edge!
      function chunkCss(allCss) {
        if (true) {
          return [ allCss ];
        }
        return chunkCssByClosingBrace(allCss);
      }
      /**
   * Create an disabled style sheet to be filled in later with styles
   */
      function createCombinedStylesheets(allCss, callback) {
        var cssChunks = chunkCss(allCss), index = 0, numChunks = cssChunks.length, elems = [];
        function createNext() {
          var $newSheet = updateSheet(SITECUES_COMBINED_CSS_ID + "-" + index, {
            text: cssChunks[index],
            doDisable: true
          });
          elems[index] = $newSheet[0];
          if (++index < numChunks) {
            // We must wait before creating the next stylesheet otherwise we overload IE11 and cause it to lockup
            nativeGlobal.setTimeout(createNext, 0);
          } else {
            callback(elems);
          }
        }
        createNext();
      }
      function getDOMStyleSheetObjects(styleElems, callback) {
        var numRemaining = styleElems.length;
        styleElems.forEach(function(styleElem, index) {
          getDOMStylesheet($(styleElem), function(domStylesheetObject) {
            domStylesheetObjects[index] = domStylesheetObject;
            if (0 === --numRemaining) {
              callback();
            }
          });
        });
      }
      // This is called() when all the CSS text of the document is available for processing
      function retrievalComplete(allCss) {
        if (true) {
          debugTime.retrievalComplete = performance.now();
        }
        createCombinedStylesheets(allCss, function(styleElems) {
          nativeGlobal.setTimeout(function() {
            getDOMStyleSheetObjects(styleElems, function() {
              isCssComplete = true;
              clearCallbacks();
            });
          }, WAIT_BEFORE_USING_STYLESHEET_DATA);
        });
      }
      function isReady() {
        return isCssComplete;
      }
      function requestCss() {
        if (isCssRequested) {
          return;
        }
        if (true) {
          debugTime.begin = performance.now();
        }
        isCssRequested = true;
        // Create a <style id="sitecues-js-combined-css"> containing all relevant style rule in the right order.
        // It will start with default user agent style rules and add
        // any <style> or <link> that is not from sitecues, and create a combined stylesheet with those contents (in the right order).
        // This will initialize the composite stylesheet when finished and call style-service/ready
        cssAggregator.collectAllCss(retrievalComplete);
      }
      // -------------------------------------- PUBLIC -----------------------------------------------
      /**
   * [This function allows the targeting of styles, such as "cursor", and invokes a callback
   * that gets passed the style and the rule associated with it for any CSS selector]
   * @param  {string}   propertyName
   * @param  {string]   matchValue, optional value to match, null to match anything
   * @return  {[]} Array of objects with rule (selector) and value (CSS property affected)
   */
      function getAllMatchingStyles(propertyName, matchValue) {
        return getAllMatchingStylesCustom(function(cssStyleDeclaration) {
          var ruleValue = cssStyleDeclaration[propertyName];
          if (ruleValue && (!matchValue || matchValue === ruleValue)) {
            return ruleValue;
          }
        });
      }
      /**
   * [This function allows the targeting of styles, such as "cursor", and invokes a callback
   * that gets passed the style and the rule associated with it for any CSS selector]
   * @param  {fn} matchingFn takes a cssStyleDecl and returns a truthy/falsey value
   * @return  {[]} Array of objects with rule (selector) and value (CSS property affected)
   */
      function getAllMatchingStylesCustom(matchingRuleFn) {
        var rule, ruleValue, cssStyleDeclaration, styleResults = [], index = 0;
        function getMediaTypeFromCssText(rule) {
          // Change @media MEDIA_QUERY_RULES { to just MEDIA_QUERY_RULES
          return rule.cssText.split("{")[0].substr(7);
        }
        function addMatchingRules(rulesContainer) {
          var rules = rulesContainer.cssRules, ruleIndex = 0, numRules = rules ? rules.length : 0;
          for (;ruleIndex < numRules; ruleIndex++) {
            rule = rules[ruleIndex];
            cssStyleDeclaration = rule.style;
            if (cssStyleDeclaration && rule.selectorText) {
              // Could be null if rule is CSSMediaRule / @font-face
              ruleValue = matchingRuleFn(cssStyleDeclaration, rule.selectorText);
              if (ruleValue) {
                styleResults.push({
                  rule: rule,
                  value: ruleValue
                });
              }
            } else {
              if (rule.media) {
                // Only add CSS rules where the media query fits
                // TODO Unfortunately, this means that if the window size or zoom changes,
                //      we won't have those rules anymore. Do we reanalyze at that point?
                var media = getMediaTypeFromCssText(rule);
                if (mediaQueries.isActiveMediaQuery(media)) {
                  // if (SC_DEV) { console.log('@media matched: ' + media); }
                  addMatchingRules(rule);
                }
              }
            }
          }
        }
        if (!isCssComplete) {
          return [];
        }
        for (;index < domStylesheetObjects.length; index++) {
          addMatchingRules(domStylesheetObjects[index]);
        }
        return styleResults;
      }
      /**
   * Get the DOM object for the stylesheet that lets us traverse the style rules.
   * Annoying that we have to do this.
   * Uses callback instead of Promises because we want to be synchronous if possible.
   * This allows us to disable style sheets before they can cause a rerendering
   * @param $stylesheet
   * @returns {*}
   */
      function getDOMStylesheet($stylesheet, callback) {
        var cachedDOMStylesheet = $stylesheet.data(DOM_STYLESHEET_KEY);
        if (cachedDOMStylesheet) {
          callback(cachedDOMStylesheet);
          return;
        }
        var tries = 1, MAX_TRIES = 20, TRY_INTERVAL_MS = 10, id = $stylesheet[0].id;
        function getStyleSheet() {
          var domSheet, i = 0, numSheets = document.styleSheets.length;
          for (;i < numSheets; i++) {
            domSheet = document.styleSheets[i];
            if (domSheet.ownerNode.id === id) {
              $stylesheet.data(DOM_STYLESHEET_KEY, domSheet);
              callback(domSheet);
              return;
            }
          }
          if (++tries <= MAX_TRIES) {
            if (true) {
              console.log("Could not find stylesheet " + id);
            }
            nativeGlobal.setTimeout(getStyleSheet, TRY_INTERVAL_MS);
          }
        }
        getStyleSheet();
      }
      /**
   * Lazily get the style sheet to be used for applying the theme.
   * @returns {jQuery}
   */
      function updateSheet(id, options) {
        var $sheet = $("#" + id), text = options.text, doDisable = options.doDisable, doCreate = !$sheet.length;
        if (doCreate) {
          // Create the stylesheet
          // Note: be sure to insert text into stylesheet before inserting into DOM
          // measured in IE11 to be more performant
          $sheet = $("<style>").attr("id", id);
        }
        // Update text
        if ("string" === typeof text) {
          $sheet.text(text);
        }
        // Update disabled state
        if ("boolean" === typeof doDisable) {
          if (doDisable) {
            // Same as disabling but works without access to DOMStyleSheet object, which is hard to get to
            // This can always be done right away
            // We use the media attribute as an easier cross-browser way to disable sheets
            // Once IE11 goes away we may want to go back to using .disabled property access
            $sheet.attr("media", "(max-width:0px)");
          } else {
            $sheet.removeAttr("media");
          }
        }
        if (doCreate) {
          // Insert in DOM
          $sheet.appendTo("html");
        }
        return $sheet;
      }
      /**
   * Get the CSS text that would be needed to create a new stylesheet from these styles
   */
      function getStyleText(styles, propertyName) {
        // Get CSS text for styles
        var styleIndex = 0, css = "", numStyles = styles.length;
        for (;styleIndex < numStyles; styleIndex++) {
          var rule = styles[styleIndex].rule;
          css += rule.selectorText + " { " + propertyName + ": " + styles[styleIndex].value + "; }\n";
        }
        return css;
      }
      function clearCallbacks() {
        var index = callbackFns.length;
        while (index--) {
          callbackFns[index]();
        }
        callbackFns = [];
      }
      function init(callbackFn) {
        if (callbackFn) {
          callbackFns.push(callbackFn);
        }
        if (isInitialized) {
          if (isCssComplete) {
            clearCallbacks();
          }
          return;
        }
        isInitialized = true;
        requestCss();
      }
      return {
        isReady: isReady,
        requestCss: requestCss,
        init: init,
        getAllMatchingStyles: getAllMatchingStyles,
        getAllMatchingStylesCustom: getAllMatchingStylesCustom,
        getDOMStylesheet: getDOMStylesheet,
        updateSheet: updateSheet,
        getStyleText: getStyleText
      };
    }($, page_style_service_css_aggregator, page_style_service_media_queries, run_platform, mini_core_native_global);
    page_util_color = function(inlineStyle) {
      var TRANSPARENT = "rgba(0, 0, 0, 0)", MIN_LUMINOSITY_LIGHT_TONE = .62;
      function isDarkColor(colorValue, optionalThreshold) {
        var rgba = getRgba(colorValue);
        return getPerceivedLuminance(rgba) < (optionalThreshold || MIN_LUMINOSITY_LIGHT_TONE);
      }
      function isOnDarkBackground(current, optionalThreshold) {
        var currentBackgroundColor, currentRect, origRect, origElement = current;
        while (current) {
          currentBackgroundColor = getRgba(window.getComputedStyle(current).backgroundColor);
          // Only care about non-transparent backgrounds
          if (currentBackgroundColor.a > .5) {
            origRect = origRect || origElement.getBoundingClientRect();
            currentRect = current.getBoundingClientRect();
            if (currentRect.right > origRect.left && currentRect.left < origRect.right && currentRect.bottom > origRect.top && currentRect.top < origRect.bottom) {
              return isDarkColor(currentBackgroundColor, optionalThreshold);
            }
          }
          current = current.parentElement;
        }
        return false;
      }
      // Convert color names such as 'white', 'black', 'transparent' to rgba object or TRANSPARENT
      function convertColorNameToRgbFormat(colorName) {
        // APPROACH #1 is fast but bloats library by 1.6k with COLOR_NAMES_MAP
        //    var hexVal = colorUtil.COLOR_NAMES_MAP[colorName];
        //    if (typeof hexVal === 'undefined') {
        //      return 'rgba(0, 0, 0, 0)';
        //    }
        //
        //    var red = Math.floor(hexVal / 0x10000) % 256,
        //      green = Math.floor(hexVal / 0x100) % 256,
        //      blue = hexVal % 256;
        //
        //    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';
        // APPROACH #2 is slower (~34ms on Chrome) but does not require COLOR_NAMES_MAP
        // Setting the border on the <body> and then immediately resetting will not cause a visible change
        var rgb, docElem = document.documentElement;
        if ("initial" === colorName || "inherit" === colorName || "transparent" === colorName) {
          return TRANSPARENT;
        }
        inlineStyle.override(docElem, {
          outlineColor: colorName
        });
        var isLegalColor = inlineStyle(docElem).outlineColor;
        // Browser didn't set the border color -> not a legal color
        rgb = isLegalColor && getComputedStyle(docElem).outlineColor;
        inlineStyle.restore(docElem, "outline-color");
        return rgb;
      }
      function getColorString(rgba) {
        function isAlphaRelevant(alpha) {
          return alpha >= 0 && alpha < 1;
        }
        var rgb = Math.round(rgba.r) + "," + Math.round(rgba.g) + "," + Math.round(rgba.b);
        return isAlphaRelevant(rgba.a) ? "rgba(" + rgb + "," + rgba.a + ")" : "rgb(" + rgb + ")";
      }
      function getRgbaIfLegalColor(color) {
        if (!color) {
          return;
        }
        if ("object" === typeof color) {
          return color;
        }
        // In some browsers, sometimes the computed style for a color is 'transparent' instead of rgb/rgba
        var rgb;
        if ("rgb" !== color.substr(0, 3)) {
          rgb = convertColorNameToRgbFormat(color);
          if (!rgb) {
            return;
          }
        } else {
          rgb = color;
        }
        var MATCH_COLORS = /rgba?\((\d+), ?(\d+), ?(\d+),?( ?[\d?.]+)?\)/, match = MATCH_COLORS.exec(rgb) || {};
        return {
          r: parseInt(match[1] || 0),
          g: parseInt(match[2] || 0),
          b: parseInt(match[3] || 0),
          a: parseFloat(match[4] || 1)
        };
      }
      /**
   * Ensure that an rgba object is returned. Will use TRANSPARENT if necessary.
   * @param color
   */
      function getRgba(color) {
        return getRgbaIfLegalColor(color) || {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        };
      }
      //  colorUtil.COLOR_NAMES_MAP = {
      //    // System color names -- currently based on OS X colors
      //    // To get a color code for a certain system color, do the following:
      //    // function getHexCode(color) {
      //    //   document.body. style.color = color; var rgb = getRgba(getComputedStyle(document.body).color); var num = rgb.r * 256 * 256 + rgb.g * 256 + rgb.b; console.log('0x' + num.toString(16));
      //    // }
      //
      //    buttonface: 0xc0c0c0,
      //    buttonhighlight: 0xe9e9e9,
      //    buttonshadow: 0x9fa09f,
      //    buttontext: 0,
      //    captiontext: 0,
      //    graytext: 0x7f7f7f,
      //    highlighttext: 0,
      //    inactiveborder: 0xffffff,
      //    inactivecaption: 0xffffff,
      //    inactivecaptiontext: 0,
      //    infobackground: 0xfbfcc5,
      //    infotext: 0,
      //    menu: 0xf6f6f6,
      //    menutext: 0xffffff,
      //    scrollbar: 0xaaaaaa,
      //    threeddarkshadow: 0,
      //    threedface: 0xc0c0c0,
      //    threedhighlight: 0xffffff,
      //    threedlightshadow: 0xffffff,
      //    threedshadow: 0,
      //    window: 0xececec,
      //    windowtext: 0,
      //    windowframe: 0xaaaaaa,
      //
      //    // Traditional color names
      //    aliceblue: 0xf0f8ff,
      //    antiquewhite: 0xfaebd7,
      //    aqua: 0x00ffff,
      //    aquamarine: 0x7fffd4,
      //    azure: 0xf0ffff,
      //    beige: 0xf5f5dc,
      //    bisque: 0xffe4c4,
      //    black: 0x000000,
      //    blanchedalmond: 0xffebcd,
      //    blue: 0x0000ff,
      //    blueviolet: 0x8a2be2,
      //    brown: 0xa52a2a,
      //    burlywood: 0xdeb887,
      //    cadetblue: 0x5f9ea0,
      //    chartreuse: 0x7fff00,
      //    chocolate: 0xd2691e,
      //    coral: 0xff7f50,
      //    cornflowerblue: 0x6495ed,
      //    cornsilk: 0xfff8dc,
      //    crimson: 0xdc143c,
      //    cyan: 0x00ffff,
      //    darkblue: 0x00008b,
      //    darkcyan: 0x008b8b,
      //    darkgoldenrod: 0xb8860b,
      //    darkgray: 0xa9a9a9,
      //    darkgreen: 0x006400,
      //    darkkhaki: 0xbdb76b,
      //    darkmagenta: 0x8b008b,
      //    darkolivegreen: 0x556b2f,
      //    darkorange: 0xff8c00,
      //    darkorchid: 0x9932cc,
      //    darkred: 0x8b0000,
      //    darksalmon: 0xe9967a,
      //    darkseagreen: 0x8fbc8f,
      //    darkslateblue: 0x483d8b,
      //    darkslategray: 0x2f4f4f,
      //    darkturquoise: 0x00ced1,
      //    darkviolet: 0x9400d3,
      //    deeppink: 0xff1493,
      //    deepskyblue: 0x00bfff,
      //    dimgray: 0x696969,
      //    dodgerblue: 0x1e90ff,
      //    firebrick: 0xb22222,
      //    floralwhite: 0xfffaf0,
      //    forestgreen: 0x228b22,
      //    fuchsia: 0xff00ff,
      //    gainsboro: 0xdcdcdc,
      //    ghostwhite: 0xf8f8ff,
      //    gold: 0xffd700,
      //    goldenrod: 0xdaa520,
      //    gray: 0x808080,
      //    green: 0x008000,
      //    greenyellow: 0xadff2f,
      //    honeydew: 0xf0fff0,
      //    hotpink: 0xff69b4,
      //    indianred: 0xcd5c5c,
      //    indigo: 0x4b0082,
      //    ivory: 0xfffff0,
      //    khaki: 0xf0e68c,
      //    lavender: 0xe6e6fa,
      //    lavenderblush: 0xfff0f5,
      //    lawngreen: 0x7cfc00,
      //    lemonchiffon: 0xfffacd,
      //    lightblue: 0xadd8e6,
      //    lightcoral: 0xf08080,
      //    lightcyan: 0xe0ffff,
      //    lightgoldenrodyellow: 0xfafad2,
      //    lightgray: 0xd3d3d3,
      //    lightgreen: 0x90ee90,
      //    lightpink: 0xffb6c1,
      //    lightsalmon: 0xffa07a,
      //    lightseagreen: 0x20b2aa,
      //    lightskyblue: 0x87cefa,
      //    lightslategray: 0x778899,
      //    lightsteelblue: 0xb0c4de,
      //    lightyellow: 0xffffe0,
      //    lime: 0x00ff00,
      //    limegreen: 0x32cd32,
      //    linen: 0xfaf0e6,
      //    magenta: 0xff00ff,
      //    maroon: 0x800000,
      //    mediumaquamarine: 0x66cdaa,
      //    mediumblue: 0x0000cd,
      //    mediumorchid: 0xba55d3,
      //    mediumpurple: 0x9370db,
      //    mediumseagreen: 0x3cb371,
      //    mediumslateblue: 0x7b68ee,
      //    mediumspringgreen: 0x00fa9a,
      //    mediumturquoise: 0x48d1cc,
      //    mediumvioletred: 0xc71585,
      //    midnightblue: 0x191970,
      //    mintcream: 0xf5fffa,
      //    mistyrose: 0xffe4e1,
      //    moccasin: 0xffe4b5,
      //    navajowhite: 0xffdead,
      //    navy: 0x000080,
      //    oldlace: 0xfdf5e6,
      //    olive: 0x808000,
      //    olivedrab: 0x6b8e23,
      //    orange: 0xffa500,
      //    orangered: 0xff4500,
      //    orchid: 0xda70d6,
      //    palegoldenrod: 0xeee8aa,
      //    palegreen: 0x98fb98,
      //    paleturquoise: 0xafeeee,
      //    palevioletred: 0xdb7093,
      //    papayawhip: 0xffefd5,
      //    peachpuff: 0xffdab9,
      //    peru: 0xcd853f,
      //    pink: 0xffc0cb,
      //    plum: 0xdda0dd,
      //    powderblue: 0xb0e0e6,
      //    purple: 0x800080,
      //    rebeccapurple: 0x663399,
      //    red: 0xff0000,
      //    rosybrown: 0xbc8f8f,
      //    royalblue: 0x4169e1,
      //    saddlebrown: 0x8b4513,
      //    salmon: 0xfa8072,
      //    sandybrown: 0xf4a460,
      //    seagreen: 0x2e8b57,
      //    seashell: 0xfff5ee,
      //    sienna: 0xa0522d,
      //    silver: 0xc0c0c0,
      //    skyblue: 0x87ceeb,
      //    slateblue: 0x6a5acd,
      //    slategray: 0x708090,
      //    snow: 0xfffafa,
      //    springgreen: 0x00ff7f,
      //    steelblue: 0x4682b4,
      //    tan: 0xd2b48c,
      //    teal: 0x008080,
      //    thistle: 0xd8bfd8,
      //    tomato: 0xff6347,
      //    turquoise: 0x40e0d0,
      //    violet: 0xee82ee,
      //    wheat: 0xf5deb3,
      //    white: 0xffffff,
      //    whitesmoke: 0xf5f5f5,
      //    yellow: 0xffff00,
      //    yellowgreen: 0x9acd32
      //  };
      /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * @param   Number  h       The monochromeHue
   * @param   Number  s       The saturation
   * @param   Number  l       The lightness
   * @return  Object          The RGB representation
   */
      function hslToRgb(h, s, l) {
        var r, g, b;
        if (!s) {
          r = g = b = l;
        } else {
          var hue2rgb = function(p, q, t) {
            if (t < 0) {
              t += 1;
            }
            if (t > 1) {
              t -= 1;
            }
            if (t < 1 / 6) {
              return p + 6 * (q - p) * t;
            }
            if (t < .5) {
              return q;
            }
            if (t < 2 / 3) {
              return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
          };
          var q = l < .5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1 / 3);
        }
        return {
          r: Math.round(255 * r),
          g: Math.round(255 * g),
          b: Math.round(255 * b)
        };
      }
      // From http://www.w3.org/TR/2006/WD-WCAG20-20060427/complete.html#luminosity-contrastdef
      function getLuminanceFromColorName(colorName) {
        return getPerceivedLuminance(getRgba(colorName));
      }
      // Perceived luminance must apply inverse gamma correction (the ^2.2)
      // See https://en.wikipedia.org/wiki/Luma_(video)
      //     https://en.wikipedia.org/wiki/Luminous_intensity
      //     https://en.wikipedia.org/wiki/Gamma_correction
      //     http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
      function getPerceivedLuminance(rgb) {
        var gammaReversed = .299 * getValue("r") + .587 * getValue("g") + .114 * getValue("b");
        function getValue(channel) {
          var rawValue = rgb[channel] / 255;
          return rawValue * rawValue;
        }
        return Math.sqrt(gammaReversed);
      }
      // Trades accuracy for performance
      function getFastLuminance(rgb) {
        var DIVISOR = 2550;
        // 255 * (2 + 7 + 1)
        return (2 * rgb.r + 7 * rgb.g + rgb.b) / DIVISOR;
      }
      function getContrastRatio(color1, color2) {
        var L1 = getLuminanceFromColorName(color1), L2 = getLuminanceFromColorName(color2);
        var ratio = (L1 + .05) / (L2 + .05);
        if (ratio >= 1) {
          return ratio;
        }
        return (L2 + .05) / (L1 + .05);
      }
      /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h, s, and l in the set [0, 1].
   *
   * @param   Number  r       The red color value
   * @param   Number  g       The green color value
   * @param   Number  b       The blue color value
   * @return  Object          The HSL representation
   */
      function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;
        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;
        if (max === min) {
          h = s = 0;
        } else {
          var d = max - min;
          s = l > .5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
           case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;

           case g:
            h = (b - r) / d + 2;
            break;

           case b:
            h = (r - g) / d + 4;
          }
          h /= 6;
        }
        return {
          h: h,
          s: s,
          l: l
        };
      }
      // Get the current background color
      function getDocumentBackgroundColor() {
        var color = getComputedStyle(document.documentElement).backgroundColor, rgba = getRgba(color), WHITE = {
          r: 255,
          g: 255,
          b: 255
        };
        return rgba.a > 0 ? rgba : WHITE;
      }
      if (true) {
        sitecues.getRgba = getRgba;
        sitecues.rgbToHsl = rgbToHsl;
        sitecues.hslToRgb = hslToRgb;
        sitecues.getLuminanceFromColorName = getLuminanceFromColorName;
        sitecues.getPerceivedLuminance = getPerceivedLuminance;
        sitecues.getContrastRatio = getContrastRatio;
        sitecues.getColorString = getColorString;
      }
      return {
        isDarkColor: isDarkColor,
        isOnDarkBackground: isOnDarkBackground,
        getColorString: getColorString,
        getRgbaIfLegalColor: getRgbaIfLegalColor,
        getRgba: getRgba,
        getLuminanceFromColorName: getLuminanceFromColorName,
        getFastLuminance: getFastLuminance,
        getPerceivedLuminance: getPerceivedLuminance,
        getContrastRatio: getContrastRatio,
        rgbToHsl: rgbToHsl,
        hslToRgb: hslToRgb,
        getDocumentBackgroundColor: getDocumentBackgroundColor
      };
    }(run_inline_style_inline_style);
    page_cursor_cursor_css = function(platform, ZOOM_CONST, colorUtil, urls) {
      // Viewbox coordinates are multiplied by 10 so that we can remove coordinates from our decimal places
      // Also, viewbox left side begins at -10px (-100) so that the left side of the thumb shows up in the hand cursor on Windows
      var PREFIX = '<svg xmlns="http://www.w3.org/2000/svg" width="SIDE" height="SIDE" viewBox="-100,0,SIDE0,SIDE0"><defs><filter id="d" width="200%" height="200%"><feOffset result="offOut" in="SourceAlpha" dx="2.5" dy="5" /><feGaussianBlur result="blurOut" in="offOut" stdDeviation="5" /><feBlend in="SourceGraphic" in2="blurOut" mode="normal" /></filter></defs><g transform="scale(SIZE)" filter="url(#d)">', POSTFIX = "</g><defs/></svg>", CURSOR_SVG = {
        // Optimized to 2 decimal places via the SVG optimizer at https://petercollingridge.appspot.com/svg-editor
        // Turned into relative paths via the SVG editor at http://svg-edit.googlecode.com/svn-history/r1771/trunk/editor/svg-editor.html
        // (first paste in markup, accept the markup, then go back to markup view via <SVG> button)
        win: {
          _default: '<path d="M0,0L03,172L42,136L81,213L113,196L74,120L128,113L0,0z"/><path fill="HUE" d="M10,10L11,154L45,120L85,201L102,192L61,112L109,108L10,20z"/>',
          _pointer: '<path d="m166,143c0,15 -1,16 -2,20c-2,5 -7,16 -12,24l-5,6l0,12l0,15l-49,0c-39,0 -49,0 -49,0c0,-9 -8,-31 -11,-40c-7,-18 -13,-28 -30,-51c-10,-14 -10,-16 -10,-23c-1,-10 3,-17 16,-16c7,0 11,3 20,8l4,4l1,-45c0,-44 0,-45 1,-47c2,-3 8,-6 12,-8c2,0 6,0 9,0c9,0 15,4 17,11c0,2 1,11 1,23l0,19l3,0c7,-1 17,3 20,8c2,3 3,3 4,3c11,-2 19,0 26,6c1,2 3,3 3,3c0,1 2,1 4,1c6,-1 12,0 15,2c3,1 7,5 9,8c1,4 2,4 3,23c0,10 0,26 0,34z"/><path fill="HUE" d="m155,164c1,-5 2,-14 1,-49c-1,-16 -1,-20 -2,-22c-2,-5 -8,-8 -14,-7l-4,0l0,15c0,14 0,16 -1,16c-1,1 -5,1 -6,0c-2,0 -2,-1 -2,-15l0,-16l-2,-3c-3,-4 -7,-6 -13,-6c-2,0 -4,0 -5,0c0,0 -1,5 -1,15c0,10 0,15 0,15c-1,1 -2,1 -4,1c-5,0 -5,0 -5,-17c0,-17 0,-19 -5,-22c-3,-2 -4,-2 -9,-2l-5,0l0,20c0,17 -1,20 -2,20c-1,1 -4,1 -6,0c-1,0 -1,-1 -1,-44l0,-45l-2,-1c-1,-1 -3,-2 -4,-3c-5,-1 -9,0 -12,3l-2,1l0,54c0,60 1,56 -5,56c-3,-1 -4,-1 -4,-7l0,-7l-5,-4c-5,-3 -9,-8 -13,-9c-3,-1 -8,-2 -10,0c-5,4 -3,9 -2,12c3,6 4,7 9,14c20,27 19,28 37,78l1,6l40,0l41,0l0,-8l0,-9l5,-7c6,-9 10,-16 12,-23z"/>'
        },
        mac: {
          _default: '<path fill="HUE" d="M10 4L10 168 43 133 65 185 103 170 81 119 125 119 10 4z"/><path d="M19 29L20 142 45 116 70 173 90 166 67 109 100 109"/>',
          _pointer: '<path d="m51,13c-3,1 -6,3 -7,5c-5,7 -5,20 -2,39c2,7 5,23 6,25c0,1 -1,0 -3,-1c-6,-6 -11,-9 -17,-9c-6,0 -12,4 -15,10c-1,3 -1,4 -1,8c0,8 2,12 14,27c6,8 8,11 13,20c2,2 5,6 13,14l11,11l0,6l0,6l19,1l18,0l6,-6l6,-6l5,6l6,6l9,0l9,-1l1,-10l0,-10l2,-3c1,-2 4,-6 6,-9c3,-4 6,-9 8,-11c7,-10 7,-10 7,-37c0,-21 0,-21 -2,-24c-1,-3 -4,-5 -7,-7c-2,-1 -3,-1 -7,-1c-3,0 -4,0 -7,1c-2,1 -3,2 -3,2c0,0 -1,-2 -2,-3c-1,-4 -4,-6 -8,-8c-2,-1 -3,-2 -7,-2c-6,0 -8,1 -12,4c-1,2 -2,2 -2,1c0,-2 -6,-6 -9,-7c-4,-2 -9,-2 -12,0c-2,1 -4,2 -5,3c-1,0 -2,1 -2,0c0,-1 -1,-11 -2,-14c-3,-13 -8,-21 -15,-24c-3,-2 -9,-2 -12,-2z"/><path fill="HUE" d="m0,0l60,22c3,2 6,6 8,12c2,6 2,9 4,22c1,6 1,13 2,15c2,11 5,15 8,12c1,-1 1,-2 1,-10c0,-5 1,-10 1,-10c1,-3 5,-5 9,-5c2,0 6,2 8,4c1,2 1,2 1,7c0,7 1,12 2,14c1,0 2,0 3,0c3,0 4,-1 5,-10l0,-8l2,-1c3,-3 7,-4 11,-3c6,1 7,2 8,13c0,9 1,10 4,10c2,0 4,-1 5,-6c2,-6 5,-8 10,-7c2,1 4,2 4,5c1,4 1,26 0,34c0,7 0,7 -2,11c-2,4 -8,12 -15,21c-1,2 -3,4 -3,4c-1,1 -2,14 -2,19l0,2l-4,0l-5,0l-6,-7c-3,-4 -6,-7 -7,-7c0,0 -3,3 -7,7l-6,7l-14,0l-13,0l0,-5l0,-4l-5,-4c-2,-2 -6,-5 -8,-7c-6,-5 -9,-9 -14,-17c-2,-3 -8,-12 -13,-19c-12,-17 -12,-18 -12,-20c0,-4 5,-10 9,-10c5,0 16,8 22,17c4,6 5,7 8,5c2,0 2,-1 2,-3c1,-3 -1,-11 -3,-21c-7,-24 -10,-36 -10,-44c0,-10 2,-14 8,-14c1,0 3,0 4,1l-60,-22z"/><path d="m87,103l0,0c2,0 4,1 4,3l0,34c0,2 -2,3 -4,3l0,0c-2,0 -3,-1 -3,-3l0,-34c0,-2 1,-3 3,-3z"/><path d="m108,103l0,0c2,0 4,1 4,3l0,34c0,2 -2,3 -4,3l0,0c-2,0 -4,-1 -4,-3l0,-34c0,-2 2,-3 4,-3z"/><path d="m127,103l0,0c2,0 4,1 4,3l0,34c0,2 -2,3 -4,3l0,0c-2,0 -4,-1 -4,-3l0,-34c0,-2 2,-3 4,-3z"/>'
        }
      }, CURSOR_HUE_LIGHTNESS = .7, MAX_CURSOR_SIZE_DEFAULT = 128, MAX_CURSOR_PIXELS_WIN = 71, CURSOR_ZOOM_MAX = platform.os.isWin ? 3.15 : 4, CURSOR_OFFSETS = {
        // TODO do we need different values for each platform?
        _default: {
          x: 10,
          y: 5,
          xStep: 0,
          yStep: 2.5
        },
        _pointer: {
          x: 12,
          y: 5,
          xStep: 3.6,
          yStep: 1.7
        }
      };
      /**
   * Get a URL for the cursor given the current platform
   * @param type 'default' or 'pointer'  (for auto cursor, use 'default')
   * @param sizeRatio a number > 1 (e.g. 2 = 2x)
   * @param pixelRatio = 1 for normal, 2 for retina cursor
   */
      function getCursorCss(type, sizeRatio, doUseAjaxCursors, hue) {
        var doUseRetinaCursors = platform.isRetina() && platform.canUseRetinaCursors, pixelRatio = doUseRetinaCursors ? 2 : 1, cursorGeneratorFn = doUseRetinaCursors ? generateCursorStyle2x : generateCursorStyle1x;
        var url = getUrl(type, sizeRatio, pixelRatio, doUseAjaxCursors, hue), hotspotOffset = getCursorHotspotOffset(type, sizeRatio);
        return cursorGeneratorFn(url, hotspotOffset, type);
      }
      function getUrl(type, sizeRatio, pixelRatio, doUseAjaxCursors, hue) {
        if (sizeRatio > CURSOR_ZOOM_MAX) {
          sizeRatio = CURSOR_ZOOM_MAX;
        }
        if (doUseAjaxCursors) {
          return urls.resolveResourceUrl("images/cursors/win_" + type + "_" + getAjaxCursorSize(sizeRatio) + ".cur");
        }
        var maxCursorSize = platform.os.isWin ? MAX_CURSOR_PIXELS_WIN : MAX_CURSOR_SIZE_DEFAULT, hueString = hue ? colorUtil.getColorString(colorUtil.hslToRgb(hue, 1, CURSOR_HUE_LIGHTNESS)) : "#FFF", prefix = PREFIX.replace(/SIZE/g, "" + sizeRatio * pixelRatio).replace(/SIDE/g, "" + maxCursorSize * pixelRatio), middle = CURSOR_SVG[platform.os.is]["_" + type].replace(/HUE/g, hueString), cursorSvg = prefix + middle + POSTFIX;
        // TODO: escape() is deprecated, replace with custom helper
        return "data:image/svg+xml," + escape(cursorSvg);
      }
      /**
   * Generates the cursor url for a given type and zoom level for NON retina displays
   * @param  {string} type
   * @param  {number} zoom
   * @return {string}
   */
      function generateCursorStyle1x(image, hotspotOffset, type) {
        return "url(" + image + ")" + hotspotOffset + ", " + type;
      }
      // EQ-723: Cursor URLs have offset for their hotspots. Let's add the coordinates, using CSS 3 feature.
      // The maths below based on experience and doesn't use any kind of specific logic.
      // We are likely to change it better one when we have final images.
      // There's no need for specific approach while we constantly change images and code.
      /**
   * Gets custom cursor's hotspot offset.
   * @param zl Number or string, represents zoom level.
   * @return {string} result A string in format 'x y' which is later used a part of cursor property value.
   */
      function getCursorHotspotOffset(type, zl) {
        if (platform.browser.isMS) {
          // Don't use in IE or Edge -- it will be part of .cur file
          return "";
        }
        var zoomDiff = zl - 1, // Lowest zoom level is 1, this is the difference from that
        offset = CURSOR_OFFSETS["_" + type];
        return (offset.x + offset.xStep * zoomDiff).toFixed(0) + " " + (offset.y + offset.yStep * zoomDiff).toFixed(0);
      }
      /**
   * Generates the cursor url for a given type and zoom level for retina displays
   * @param  {string} type
   * @param  {number} zoom
   * @return {string}
   */
      function generateCursorStyle2x(image, hotspotOffset, type) {
        return "-webkit-image-set(    url(" + image + ") 1x,    url(" + image + ") 2x) " + hotspotOffset + ", " + type;
      }
      function getAjaxCursorSize(sizeRatio) {
        var MIN_AJAX_CURSOR_SIZE = 1.2, MAX_AJAX_CURSOR_SIZE = 3, rounded = Math.round(5 * sizeRatio) / 5;
        return Math.max(Math.min(rounded, MAX_AJAX_CURSOR_SIZE), MIN_AJAX_CURSOR_SIZE);
      }
      function getCursorZoom(pageZoom) {
        var zoomDiff = pageZoom - ZOOM_CONST.MIN_ZOOM, // SC-1431 Need to keep the cursor smaller than MAX_CURSOR_SIZE_WIN (defined in custom.js)
        // when on Windows OS, otherwise the cursor intermittently can become a large black square.
        // Therefore, on Windows we cannot zoom the cursor up as much as on the Mac (3.5x instead of 4x)
        CURSOR_ZOOM_MIN = 1, CURSOR_ZOOM_RANGE = CURSOR_ZOOM_MAX - CURSOR_ZOOM_MIN;
        // ALGORITHM - SINUSOIDAL EASING OUT HOLLADAY SPECIAL: Decelerating to zero velocity, more quickly.
        return CURSOR_ZOOM_RANGE * Math.sin(zoomDiff / ZOOM_CONST.ZOOM_RANGE * (Math.PI / 2.8)) + CURSOR_ZOOM_MIN;
      }
      return {
        getCursorCss: getCursorCss,
        getCursorZoom: getCursorZoom
      };
    }(run_platform, page_zoom_constants, page_util_color, run_conf_urls);
    page_cursor_cursor = function($, styleService, pref, cursorCss, platform, events, nativeGlobal) {
      var isInitialized, // URLs for IE cursors that have already been fetched via AJAX
      $stylesheet, $bpStylesheet, // For BP cursors, having a min size of MIN_BP_CURSOR_SIZE -- cursor is always large in BP
      cursorStylesheetObject, bpCursorStylesheetObject, // If > 1.0 then use white
      autoSize, userSpecifiedSize, userSpecifiedHue, // Regexp is used to match URL in the string given(see below).
      URL_REGEXP = "//[a-z0-9-_]+(.[a-z0-9-_]+)+([a-z0-9-_.,@?^=%&;:/~+#]*[a-z0-9-@?^=%&;/~+#])?", CURSOR_TYPES = [ "default", "pointer" ], CURSOR_SYNONYMS = {
        _default: "auto"
      }, // Map cursor: auto -> cursor: default
      SITECUES_CURSOR_CSS_ID = "sitecues-js-cursor", SITECUES_BP_CURSOR_CSS_ID = "sitecues-js-bp-cursor", MIN_BP_CURSOR_SIZE = 1.9, REENABLE_CURSOR_MS = 20, ajaxCursors = {}, MAX_USER_SPECIFIED_CURSOR_SIZE = 3.5, MAX_USER_SPECIFIED_MOUSE_HUE = 1.09;
      /*
   * Change a style rule in the sitecues-cursor stylesheet to use the new cursor URL
   * @param {Object CSSStyleRule} rule CSSStyleRule
   * @param {String} cursorValueURL  Example: 'url(data:image/svg+xml,%3....)0 8, default'
   * @returns {void}
   */
      function setCursorStyle(rule, cursorValueURL) {
        try {
          if (true) {
            // Hack .. wake up Chrome and Safari! They weren't refreshing the rule on hue-only changes
            // E.g. when you drag the mouse hue slider you should see instant changes
            rule.style.setProperty("cursor", "", "important");
          }
          rule.style.setProperty("cursor", cursorValueURL, "important");
        } catch (e) {
          if (true) {
            console.log("Catch setting cursor property: %o", e);
          }
        }
      }
      function isCursorReadyToUse(url) {
        if (!ajaxCursors[url]) {
          return false;
        }
        // Ready to use if it's fetch is complete
        return ajaxCursors[url].isComplete;
      }
      function flushPendingCursorRules(url) {
        var ajaxCursor = ajaxCursors[url], cursorValue = ajaxCursor.cursorValue;
        ajaxCursor.isComplete = true;
        ajaxCursor.pendingRules.forEach(function(rule) {
          setCursorStyle(rule, cursorValue);
        });
      }
      // Begin to fetch the cursor if it's the first
      // attempt to use
      function beginCursorFetchIfFirst(rule, url, cursorValue) {
        if (ajaxCursors[url]) {
          // Fetch for this URL has already begin, don't start another one
          ajaxCursors[url].pendingRules.push(rule);
          return;
        }
        ajaxCursors[url] = {
          isFetched: false,
          cursorValue: cursorValue,
          pendingRules: [ rule ]
        };
        !function(xhr) {
          xhr.get({
            url: url,
            crossDomain: true,
            headers: {
              Accept: "application/octet-stream"
            },
            success: function() {
              if (true) {
                console.log("Loading of CUR file completed!");
              }
              flushPendingCursorRules(url);
            },
            error: function() {
              if (true) {
                console.log("[Error] Unable to fetch cursor image from server: " + url);
              }
            }
          });
        }(run_util_xhr);
      }
      /**
   * We want to async load the cursor images before they used, for performance benefit.
   * For ex., if the image isn't available for some reason then don't wait for it,
   * go to another operation.
   *
   * @param {String} cursorValue  Example: "url(data:image/svg+xml,%3....)0 8, auto"
   * @param {Function} callback A function called after the ajax request completed
   * @returns {void}
   */
      function setCursorStyleWhenReady(rule, cursorValue) {
        function getUrlFromCursorValue() {
          var urlRegexp = new RegExp(URL_REGEXP, "i"), cursorValueArray = urlRegexp.exec(cursorValue);
          return cursorValueArray[0];
        }
        var url = getUrlFromCursorValue();
        if (!platform.browser.isMS || isCursorReadyToUse(url)) {
          // No prefetch needed
          setCursorStyle(rule, cursorValue);
        } else {
          beginCursorFetchIfFirst(rule, url, cursorValue);
        }
      }
      /**
   * Does the given URL value match the cursor type?
   * @param cursorType
   * @param url
   * @returns {boolean}
   */
      function isCursorOfType(cursorType, url) {
        if (url.indexOf(cursorType) > -1) {
          return true;
        }
        var synonym = CURSOR_SYNONYMS["_" + cursorType];
        return synonym && url.indexOf(synonym) > -1;
      }
      /**
   * Refresh all cursor rules in the sitecues-cursor stylesheet, mapping them to cursorTypeUrls
   * @param cursorTypeUrls
   */
      function refreshCursorStyles(styleSheet, cursorTypeUrls) {
        if (!styleSheet || !styleSheet.cssRules) {
          return;
        }
        var cursorTypeIndex, cursorType, rules = styleSheet.cssRules, numRules = rules.length, ruleIndex = 0;
        for (;ruleIndex < numRules; ruleIndex++) {
          var rule = rules[ruleIndex], value = rule.style.cursor;
          // Find the cursor type (auto, pointer, etc) and replace the style with our generated image.
          for (cursorTypeIndex = 0; cursorTypeIndex < CURSOR_TYPES.length; cursorTypeIndex++) {
            cursorType = CURSOR_TYPES[cursorTypeIndex];
            if (isCursorOfType(cursorType, value)) {
              var cursorValueURL = cursorTypeUrls[cursorType];
              setCursorStyleWhenReady(rule, cursorValueURL);
            }
          }
        }
      }
      // Turning off custom cursor improves zoom animation in IE
      function toggleZoomOptimization(doDisable) {
        if (platform.browser.isMS) {
          // Only necessary for MS Browsers
          // Still seems to help in Edge as of version 13
          // The style service may not have initialized
          if (cursorStylesheetObject) {
            cursorStylesheetObject.disabled = Boolean(doDisable);
          }
        }
      }
      function createStyleSheet(id, cssText) {
        return $("<style>").appendTo("head").attr("id", id).text(cssText);
      }
      function getCursorStylesAsText() {
        // Use all cursor styles from the user agent stylesheet and the page
        var cursorStyleSubset = styleService.getAllMatchingStyles("cursor");
        return styleService.getStyleText(cursorStyleSubset, "cursor");
      }
      // Create a stylesheet with only the cursor-related style rules
      function constructCursorStylesheet(callback) {
        var cssText = getCursorStylesAsText();
        // Create the sitecues <style id="sitecues-js-cursor"> element and content
        $stylesheet = createStyleSheet(SITECUES_CURSOR_CSS_ID, cssText);
        // Now set the cursorStyles global to the rules in the cursor style sheet.
        // The refresh methods will iterate over these styles and modify them
        styleService.getDOMStylesheet($stylesheet, function(styleSheetObject) {
          cursorStylesheetObject = styleSheetObject;
          callback();
        });
        // While zooming, turn off our CSS rules so that the browser doesn't spend
        // CPU cycles recalculating the custom cursor rules to apply during each frame
        // This makes a difference in IE 9/10 -- doesn't seem to help in other browsers.
        events.on("zoom/begin", function() {
          toggleZoomOptimization(true);
        });
      }
      // Stylesheet just for BP cursors
      // The cursors have a minimum size, and are NOT disabled during smooth zoom for performance,
      // as opposed to the page cursors, which can be disabled during smooth zoom for performance
      function constructBPCursorStylesheet() {
        var cssText = "#scp-bp-container,.scp-toolbar {cursor:default;}\n.scp-hand-cursor {cursor:pointer}";
        $bpStylesheet = createStyleSheet(SITECUES_BP_CURSOR_CSS_ID, cssText);
        styleService.getDOMStylesheet($bpStylesheet, function(styleSheetObject) {
          bpCursorStylesheetObject = styleSheetObject;
        });
      }
      /**
   * Generates a CSS cursor property for every supported
   * cursor type at the current zoom level and then changes
   * all cursor properties in the <style id="sitecues-js-cursor">
   */
      function doRefresh() {
        // Get cursor URLs for current zoom levels
        var useCursorZoom = userSpecifiedSize || autoSize, cursorTypeUrls = getCursorTypeUrls(useCursorZoom), useDifferentBpSizes = !userSpecifiedSize && autoSize < MIN_BP_CURSOR_SIZE, bpCursorTypeUrls = useDifferentBpSizes ? getCursorTypeUrls(MIN_BP_CURSOR_SIZE) : cursorTypeUrls;
        // Refresh document cursor stylesheet if we're using one
        if (cursorStylesheetObject) {
          refreshCursorStyles(cursorStylesheetObject, cursorTypeUrls);
          nativeGlobal.setTimeout(toggleZoomOptimization, REENABLE_CURSOR_MS);
        }
        // Refresh BP cursor stylesheet
        if (bpCursorStylesheetObject) {
          refreshCursorStyles(bpCursorStylesheetObject, bpCursorTypeUrls);
        }
      }
      function isCustomCursorNeeded() {
        return autoSize > 1 || userSpecifiedSize || userSpecifiedHue;
      }
      function refreshStylesheetsIfNecessary() {
        if (!isCustomCursorNeeded()) {
          // Cursor is normal size or no custom cursor allowed right now
          if ($stylesheet) {
            $stylesheet.remove();
            $stylesheet = null;
          }
          doRefresh();
        } else {
          if (!$stylesheet) {
            styleService.init(function() {
              constructCursorStylesheet(doRefresh);
            });
          } else {
            doRefresh();
          }
        }
      }
      /**
   * Get the cursor URLs to support the current cursorZoom level
   * @returns {Array} Array of cursor URLS
   */
      function getCursorTypeUrls(size) {
        var cursorTypeUrls = [], i = 0, doUseMSCursors = platform.browser.isMS;
        // Generate cursor images for every cursor type...
        for (;i < CURSOR_TYPES.length; i++) {
          // Don't use hotspotOffset in IE because that's part of the .cur file.
          var type = CURSOR_TYPES[i], css = cursorCss.getCursorCss(type, size, doUseMSCursors, getRealUserHue());
          cursorTypeUrls[CURSOR_TYPES[i]] = css;
        }
        return cursorTypeUrls;
      }
      function onMouseSizeSetting(size) {
        userSpecifiedSize = size;
        styleService.init(refreshStylesheetsIfNecessary);
      }
      function onMouseHueSetting(hue) {
        userSpecifiedHue = hue;
        styleService.init(refreshStylesheetsIfNecessary);
      }
      function sanitizeMouseSize(size) {
        return Math.min(Math.max(size, 1), MAX_USER_SPECIFIED_CURSOR_SIZE);
      }
      function sanitizeMouseHue(hue) {
        if (!hue || hue < 0 || hue > MAX_USER_SPECIFIED_MOUSE_HUE) {
          return 0;
        }
        return hue;
      }
      function getRealUserHue() {
        return userSpecifiedHue > 0 && userSpecifiedHue <= 1 ? userSpecifiedHue : 0;
      }
      // Get the auto size for the cursor at the supplied page zoom level, or at the current page zoom if none supplied
      function getSize(pageZoom) {
        return userSpecifiedSize || cursorCss.getCursorZoom(pageZoom || pref.get("zoom") || 1);
      }
      function onPageZoom(pageZoom) {
        if (userSpecifiedSize) {
          toggleZoomOptimization();
          // Re-enable cursors -- they were disabled for zoom performance in IE
          return;
        }
        // At page zoom level 1.0, the cursor is the default size (same as us being off).
        // After that, the cursor grows faster than the zoom level, maxing out at 4x at zoom level 3
        var newCursorZoom = cursorCss.getCursorZoom(pageZoom);
        if (autoSize !== newCursorZoom) {
          autoSize = newCursorZoom;
          refreshStylesheetsIfNecessary();
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        pref.defineHandler("mouseSize", sanitizeMouseSize);
        pref.defineHandler("mouseHue", sanitizeMouseHue);
        pref.bindListener("mouseSize", onMouseSizeSetting);
        pref.bindListener("mouseHue", onMouseHueSetting);
        events.on("zoom", onPageZoom);
        constructBPCursorStylesheet();
        autoSize = getSize();
        refreshStylesheetsIfNecessary();
      }
      return {
        init: init,
        getSize: getSize
      };
    }($, page_style_service_style_service, run_conf_preferences, page_cursor_cursor_css, run_platform, run_events, mini_core_native_global);
    bp_secondary_settings = function(BP_CONST, helper, pref, state, metric, platform, cursor, events, domEvents, nativeGlobal, inlineStyle) {
      var isInitialized, settingsPanel, byId = helper.byId, isActive = false, lastDragUpdateTime = 0, SLIDER_DRAG_UPDATE_MIN_INTERVAL = 50, rangeValueMap = {};
      function onPanelUpdate() {
        var willBeActive = "settings" === state.getSecondaryPanelName() && state.get("isSecondaryExpanded"), settingsCards = byId(BP_CONST.SETTINGS_CONTENT_ID);
        if (isActive !== willBeActive) {
          if (willBeActive) {
            mouseSlidersInit();
            // Always use current mouse size as starting point
            if (!settingsPanel) {
              initContents();
            }
            settingsCards.addEventListener("click", onSettingsClick);
            settingsCards.addEventListener("change", onSettingsNativeInputChange);
            settingsCards.addEventListener("input", onSettingsNativeInputChangeDrag);
          } else {
            settingsCards.removeEventListener("click", onSettingsClick);
            settingsCards.removeEventListener("change", onSettingsNativeInputChange);
            settingsCards.removeEventListener("input", onSettingsNativeInputChangeDrag);
          }
        }
        isActive = willBeActive;
      }
      function initContents() {
        settingsPanel = byId(BP_CONST.SETTINGS_CONTENT_ID);
        if (platform.featureSupport.themes) {
          !function(theme) {
            theme.init(true);
          }(theme_theme);
        }
        initButtons();
        initRanges();
        themeSlidersInit();
      }
      // Set up setting synchronization
      function initButtons() {
        var name, allSettingNames = {}, allSettingElems = settingsPanel.querySelectorAll("[data-setting-name]"), index = allSettingElems.length;
        // For each setting name, get a list of elements
        while (index--) {
          name = allSettingElems[index].getAttribute("data-setting-name");
          allSettingNames[name] = 1;
        }
        function themeListener(newValue) {
          newValue = newValue || "none";
          // Will now be 'none', 'warm', 'bold' or 'dark'
          var elem, currentButtonValue, isCurrentValue, settingElems = settingsPanel.querySelectorAll('sc-button[data-setting-name="' + name + '"]'), index = settingElems.length;
          while (index--) {
            elem = settingElems[index];
            // This button is used for what theme? 'none', 'warm', 'bold' or 'dark'
            currentButtonValue = elem.getAttribute("data-setting-value") || "none";
            isCurrentValue = newValue === currentButtonValue;
            elem.setAttribute("aria-pressed", isCurrentValue);
          }
        }
        Object.keys(allSettingNames).forEach(function(name) {
          pref.bindListener(name, themeListener);
        });
      }
      function getThemePowerGroup() {
        return byId(BP_CONST.THEME_POWER_ID);
      }
      function getThemeTextHueGroup() {
        return byId(BP_CONST.THEME_TEXT_HUE_ID);
      }
      function getMouseSizeRange() {
        return byId(BP_CONST.MOUSE_SIZE_ID);
      }
      function initRangeListener(settingName, rangeElem) {
        pref.bindListener(settingName, function(val) {
          rangeElem.value = val;
        });
      }
      function initRanges() {
        var rangeElem, settingName, rangeElems = settingsPanel.querySelectorAll('input[type="range"]'), index = rangeElems.length;
        while (index--) {
          rangeElem = rangeElems[index];
          settingName = rangeElem.getAttribute("data-setting-name");
          initRangeListener(settingName, rangeElem);
          domEvents.on(rangeElem, "blur", fireInputRangeMetric);
          rangeValueMap[settingName] = pref.get(settingName);
          adjustRangeBackground(rangeElem);
        }
      }
      function themeNameListener(name) {
        var isThemePowerEnabled = Boolean(name), isThemeTextHueEnabled = "dark" === name;
        getThemePowerGroup().setAttribute("data-show", isThemePowerEnabled);
        getThemeTextHueGroup().setAttribute("data-show", isThemeTextHueEnabled);
      }
      function themeSlidersInit() {
        pref.bindListener("themeName", themeNameListener);
      }
      function mouseSlidersInit() {
        var size = cursor.getSize(), MIN_BP_CURSOR_SIZE = 1.9;
        if (!pref.get("mouseSize")) {
          // No setting, so start from current cursor size means using the BP cursor size as a minimum
          size = Math.max(size, MIN_BP_CURSOR_SIZE);
        }
        getMouseSizeRange().value = size;
      }
      function getGeometryTargets(cssValues) {
        return cssValues;
      }
      function isNativeInput(elem) {
        return "undefined" !== typeof elem.value;
      }
      function onSettingsClick(evt) {
        var settingName, target = helper.getEventTarget(evt);
        if (target && !isNativeInput(target)) {
          settingName = target.getAttribute("data-setting-name");
          if (settingName) {
            pref.set(settingName, target.getAttribute("data-setting-value"));
          }
        }
      }
      function fireInputRangeMetric(event) {
        var target = event.target, id = target.id, settingName = target.getAttribute("data-setting-name"), oldValue = rangeValueMap[settingName], newValue = pref.get(settingName);
        if (oldValue !== newValue) {
          // Only fire on change
          rangeValueMap[settingName] = newValue;
          new metric.SliderSettingChange({
            id: id.split("scp-")[1] || id,
            // Trim off scp- prefix
            settingName: settingName,
            old: oldValue,
            new: newValue
          }).send();
        }
      }
      // Use native value for things like <input type="range">
      // For sliders, this occurs when user drops the thumb (lets go of mouse button)
      function onSettingsNativeInputChange(evt) {
        var target = helper.getEventTarget(evt);
        if (target) {
          var settingName = target.getAttribute("data-setting-name"), newValue = +target.value;
          if (settingName) {
            pref.set(settingName, newValue);
          }
        }
      }
      // Firefox doesn't have a pure CSS way of adjusting the background
      function adjustRangeBackground(slider) {
        if (platform.browser.isMS) {
          // Not needed for IE/Edge, which do this via -ms- CSS
          // We prefer CSS approach in IE, because JS may have trouble keeping up with slider thumb movements
          return;
        }
        if (slider.className.indexOf("scp-normal-range") < 0) {
          return;
        }
        var value = +slider.value, min = parseFloat(slider.min), max = parseFloat(slider.max), percent = 100 * (value - min) / (max - min) + "%", LEFT_COLOR = "#538eca", RIGHT_COLOR = "#e2e2e2", gradient = "linear-gradient(to right, " + LEFT_COLOR + " 0%," + LEFT_COLOR + " " + percent + "," + RIGHT_COLOR + " " + percent + "," + RIGHT_COLOR + " 100%)";
        inlineStyle(slider).backgroundImage = gradient;
      }
      // Native input change
      // For sliders, this occurs when thumb moves at all, it doesn't need to be dropped there
      // We don't want to update too much, hence the timer
      function onSettingsNativeInputChangeDrag(evt) {
        adjustRangeBackground(evt.target);
        var currTime = +Date.now();
        if (currTime - lastDragUpdateTime > SLIDER_DRAG_UPDATE_MIN_INTERVAL) {
          lastDragUpdateTime = currTime;
          nativeGlobal.setTimeout(function() {
            onSettingsNativeInputChange(evt);
          }, 0);
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        events.on("bp/did-open-subpanel", onPanelUpdate);
      }
      return {
        getGeometryTargets: getGeometryTargets,
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_conf_preferences, run_bp_model_state, run_metric_metric, run_platform, page_cursor_cursor, run_events, run_dom_events, mini_core_native_global, run_inline_style_inline_style);
    bp_secondary_feedback = function(BP_CONST, helper, state, metric, view, events, nativeGlobal, inlineStyle) {
      var isInitialized, // Zero = no rating defined
      currentStatus, byId = helper.byId, isActive = false, currentRating = 0;
      function getFeedbackArea() {
        return byId(BP_CONST.FEEDBACK_TEXTAREA);
      }
      function getFeedbackInputRect() {
        return byId(BP_CONST.FEEDBACK_INPUT_RECT);
      }
      function getRating() {
        return byId(BP_CONST.RATING);
      }
      function getFeedbackSendButton() {
        return byId(BP_CONST.FEEDBACK_SEND_BUTTON);
      }
      // Child of button: handles clicks
      function getFeedbackSendLink() {
        return byId(BP_CONST.FEEDBACK_SEND_LINK);
      }
      function getBPContainer() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      function autoSizeTextarea() {
        var feedbackTextarea = getFeedbackArea(), feedbackInputRect = getFeedbackInputRect().getBoundingClientRect(), scale = state.get("scale"), ROOM_FOR_ROUNDED_OUTLINE = 22, ROOM_FOR_SCROLLBAR = 20, // Scrollbar will be hidden via css clip
        width = (feedbackInputRect.width - ROOM_FOR_ROUNDED_OUTLINE) / scale, height = (feedbackInputRect.height - ROOM_FOR_ROUNDED_OUTLINE) / scale;
        inlineStyle.set(feedbackTextarea, {
          width: width + "px",
          height: height + "px",
          // Hide scrollbar by clipping horizontally - don't clip vertically (just large height of 999px for that)
          clip: "rect(0," + (width - ROOM_FOR_SCROLLBAR) + "px,999px,0)"
        });
      }
      function onPanelUpdate() {
        var willBeActive = "feedback" === state.getSecondaryPanelName(), addOrRemoveFn = willBeActive ? "addEventListener" : "removeEventListener";
        if (isActive !== willBeActive) {
          getFeedbackArea()[addOrRemoveFn]("keyup", updateSendButton);
          getRating()[addOrRemoveFn]("click", onRatingClick);
          if (false) {
            getFeedbackSendLink()[addOrRemoveFn]("click", onSendFeedbackClick);
          }
          if (willBeActive) {
            !function(status) {
              status(function(statusObj) {
                currentStatus = statusObj;
              });
            }(status_status);
          } else {
            currentStatus = null;
            state.set("isFeedbackSent", false);
          }
        }
        isActive = willBeActive;
      }
      function onRatingClick(evt) {
        var star, ratingElem = getRating(), stars = getBPContainer().getElementsByClassName(BP_CONST.RATING_STAR_CLASS), // svgElem.children not supported in IE
        index = stars.length, targetStar = helper.getEventTarget(evt);
        currentRating = 0;
        while (index--) {
          star = stars[index];
          if (star === targetStar) {
            currentRating = index + 1;
          }
          star.setAttribute("aria-pressed", currentRating > 0);
        }
        // Copy current rating to group
        // TODO need to test usability of ratings with screen reader
        ratingElem.setAttribute("aria-label", targetStar.getAttribute("aria-label"));
        updateMailtoLink();
        toggleSendEnabled(true);
      }
      function getFeedbackText() {
        return getFeedbackArea().value;
      }
      // User's feedback text + status text
      function getFeedbackTextToSend() {
        if (false || !currentStatus) {
          return getFeedbackText();
        }
        // Add status text to mail messages because we don't have a metrics details field in that case.
        // Prepend blank lines so that status is on next screen of mail message in order not to confuse the user.
        var NUM_NEWLINES = 99, STATUS_PREFIX = Array(NUM_NEWLINES).join("\n") + "---- User configuration: ----\n\n", currentStatusText = nativeGlobal.JSON.stringify(currentStatus, null, "    ");
        return getFeedbackText() + STATUS_PREFIX + currentStatusText;
      }
      function getCurrentRatingText() {
        var ratingElem = getRating();
        return ratingElem.getAttribute("aria-label");
      }
      // Need to use mailto link instead of xhr in local (e.g. extension) mode
      function updateMailtoLink() {
        if (true) {
          var sendButton = getFeedbackSendLink(), mailto = sendButton.getAttribute("data-mailto") + "?subject=" + encodeURIComponent(getCurrentRatingText()) + "&body=" + encodeURIComponent(getFeedbackTextToSend());
          sendButton.setAttribute("href", mailto);
        }
      }
      function updateSendButton() {
        updateMailtoLink();
        var isEnabled = getFeedbackText().length > 0 || currentRating > 0;
        toggleSendEnabled(isEnabled);
      }
      function toggleSendEnabled(doEnable) {
        // We do both a fake button and a link child -- the link is for the mailto: we do in the extension
        getFeedbackSendButton().setAttribute("aria-disabled", !doEnable);
        getFeedbackSendLink().setAttribute("aria-disabled", !doEnable);
      }
      function isSendEnabled() {
        return "true" !== getFeedbackSendButton().getAttribute("aria-disabled");
      }
      function onSendFeedbackClick() {
        if (isSendEnabled()) {
          var details = {
            feedbackText: getFeedbackTextToSend(),
            rating: currentRating,
            // 0 = no rating, otherwise 1-5 stars
            statusText: nativeGlobal.JSON.stringify(currentStatus)
          };
          if (true) {
            console.log("Sending feedback: %o", details);
          }
          new metric.Feedback(details).send();
          toggleSendEnabled(false);
          // Disable feedback button after sent, so that feedback isn't accidentally clicked twice
          state.set("isFeedbackSent", true);
          view.update(true);
        }
      }
      function getGeometryTargets(cssValues) {
        return cssValues;
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          events.on("bp/did-open-subpanel", onPanelUpdate);
          events.on("bp/will-show-secondary-feature", function(name) {
            if ("feedback" === name) {
              autoSizeTextarea();
            }
          });
        }
      }
      return {
        getGeometryTargets: getGeometryTargets,
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_bp_model_state, run_metric_metric, run_bp_view_view, run_events, mini_core_native_global, run_inline_style_inline_style);
    bp_secondary_about = function(BP_CONST, helper, urls) {
      var isInitialized, byId = helper.byId;
      function loadImage() {
        byId("scp-sitecues-text").setAttributeNS("http://www.w3.org/1999/xlink", "href", urls.resolveResourceUrl("images/sitecues-logo-text.svg"));
      }
      function getGeometryTargets(cssValues) {
        // Which additional animations
        cssValues[false].menuImageTranslateX = 0;
        // About logo transitions to the left following the rolling icon
        cssValues[true].menuBtnTranslateX = 175;
        // The about icon, which rolls to the left
        cssValues[true].menuBtnTranslateY = BP_CONST.TRANSFORMS[BP_CONST.ABOUT_BUTTON_ID].translateY;
        // The about icon
        cssValues[true].menuBtnScale = 1;
        // About icon scales to 1
        cssValues[true].menuBtnRotate = -359.5;
        // Roll the about icon counter-clockwise
        cssValues[true].menuImageTranslateX = -500;
        return cssValues;
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          loadImage();
          byId("scp-about-rate-button").addEventListener("click", function() {
            !function(secondaryPanel) {
              secondaryPanel.toggleFeature("feedback");
            }(bp_secondary_bp_secondary);
          });
        }
      }
      return {
        getGeometryTargets: getGeometryTargets,
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_conf_urls);
    run_util_xhr = function(nativeGlobal) {
      // -- PRIVATE --
      // Cross-browser XHR requests
      function initRequest(postData, requestObj, optionalContentTypeOverride, successFnOverride) {
        var xhr = new XMLHttpRequest(), type = postData ? "POST" : "GET", contentType = optionalContentTypeOverride || requestObj.contentType;
        xhr.open(type, requestObj.url, true);
        if (contentType) {
          // If post, the content type is what we're sending, if get it's what we're receiving
          xhr.setRequestHeader(postData ? "Content-Type" : "Accept", contentType);
        }
        xhr.onload = function() {
          if (xhr.status < 400) {
            var successFn = successFnOverride || requestObj.success;
            if (successFn) {
              successFn(xhr.responseText);
            }
          } else {
            var errorFn = requestObj.error;
            if (errorFn) {
              errorFn(xhr.statusText);
            }
          }
        };
        // Send it!
        xhr.send(postData);
      }
      // -- PUBLIC ---
      // Gets the JSON text and returns a JS object
      function getJSON(requestObj) {
        initRequest(null, requestObj, "application/json", function(jsonText) {
          requestObj.success(nativeGlobal.JSON.parse(jsonText));
        });
      }
      function get(requestObj) {
        initRequest(null, requestObj, null);
      }
      function post(requestObj) {
        // Sending with text/plain instead of application/json avoids the extra CORS preflight requests
        // This is called a "Simple CORS Request" and has a number of requirements.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Simple_requests
        initRequest(nativeGlobal.JSON.stringify(requestObj.data), requestObj, "text/plain");
      }
      return {
        getJSON: getJSON,
        get: get,
        post: post
      };
    }(mini_core_native_global);
    bp_secondary_cards = function(BP_CONST, helper, locale, state, xhr, urls, events, platform, inlineStyle) {
      var isInitialized, activePanelName, activePanel, PANELS_WITH_CARDS = {
        tips: 1,
        settings: 1
      }, byId = helper.byId, isActive = false, NUM_PANELS_WITH_CARDS = 2, // can also be computed via PANELS_WITH_CARDS.keys().length;
      panelsToLoad = NUM_PANELS_WITH_CARDS;
      function loadPanelContents(panelName) {
        var localizedPanelName = panelName + "-" + locale.getUiLocale(), panelUrl = urls.resolveResourceUrl("html/" + panelName + "/" + localizedPanelName + ".html");
        xhr.get({
          url: panelUrl,
          success: function(html) {
            var panelElement, finalHTML = addSemanticSugar(html), htmlContainer = document.createElement("div");
            // Just a container where we can parse out the desired contents
            htmlContainer.innerHTML = finalHTML;
            panelElement = htmlContainer.firstElementChild;
            removeUnsupportedContent(panelElement);
            getContainer().appendChild(panelElement);
            toggleCardActive(panelElement.firstElementChild, true);
            if (0 === --panelsToLoad) {
              events.emit("bp/content-loaded");
            }
          }
        });
      }
      function getContainer() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      function getPanelElement(panelName) {
        return document.getElementById("scp-" + panelName);
      }
      // Add useful attributes to various elements, based on elemTypes
      function addSemanticSugar(html) {
        var INTERACTIVE = ' class="scp-hand-cursor scp-tabbable';
        return html.replace(/(<sc-button )/g, '<sc-button role="button" ').replace(/<sc-menuitem /g, '<sc-menuitem role="button"' + INTERACTIVE + '" ').replace(/<sc-card /g, '<sc-card role="tabpanel" ').replace(/<sc-link /g, '<sc-link role="button"' + INTERACTIVE + '" ').replace(/<sc-tab /g, '<sc-link role="tab" aria-selected="false"' + INTERACTIVE + '" ').replace(/<\/sc-tab/g, "</sc-link").replace(/<sc-normal-range /g, '<input type="range"' + INTERACTIVE + ' scp-normal-range" ').replace(/<\/sc-normal-range>/g, "</input>").replace(/<sc-hue-range /g, '<input type="range"' + INTERACTIVE + ' scp-hue-range" ').replace(/<\/sc-hue-range>/g, "</input>");
      }
      // Remove elements unless required by the site config
      function removeAllElements(panelElement, elementsToRemoveSelector) {
        function hide(elements) {
          var element, index = elements.length;
          while (index--) {
            element = elements[index];
            element.parentNode.removeChild(element);
          }
        }
        var elementsToRemove = panelElement.querySelectorAll(elementsToRemoveSelector);
        hide(elementsToRemove);
      }
      function removeUnsupportedContent(panelElement) {
        if (!platform.featureSupport.themes) {
          removeAllElements(panelElement, "#scp-theme-settings,#scp-theme-settings-tab");
        }
      }
      function onPanelUpdate() {
        var panelName = state.getSecondaryPanelName(), willBeActive = panelName && PANELS_WITH_CARDS.hasOwnProperty(panelName), addOrRemoveFn = willBeActive ? "addEventListener" : "removeEventListener", bpContainer = byId(BP_CONST.BP_CONTAINER_ID);
        // Event listeners
        if (isActive !== willBeActive) {
          byId(BP_CONST.PREV_ID)[addOrRemoveFn]("click", prevCard);
          byId(BP_CONST.NEXT_ID)[addOrRemoveFn]("click", nextCard);
          // TODO: This should be moved into the controller, somehow.
          // bpContainer[addOrRemoveFn]('keydown', onKeyDown);
          bpContainer[addOrRemoveFn]("click", onClick);
          bpContainer[addOrRemoveFn]("keydown", onKeyDown);
        }
        // Active state
        if (willBeActive) {
          if (activePanelName !== panelName) {
            activePanelName = panelName;
            activePanel = getPanelElement(panelName);
            moveIndicator();
            newCardNotification();
          }
        } else {
          activePanelName = null;
          activePanel = null;
        }
        isActive = willBeActive;
      }
      function onClick(evt) {
        var clickedElem = helper.getEventTarget(evt), linkTarget = clickedElem.getAttribute("data-target");
        if (linkTarget) {
          if ("#" === linkTarget.charAt(0)) {
            !function(info) {
              info.showHelp(linkTarget.substring(1));
            }(info_info);
          } else {
            // Card link
            selectNewCard(byId(linkTarget), true);
          }
        }
      }
      function onKeyDown(event) {
        var LEFT = 37, RIGHT = 39;
        if ("input" !== event.target.localName) {
          if (event.keyCode === LEFT) {
            switchCard(-1);
          } else {
            if (event.keyCode === RIGHT) {
              switchCard(1);
            }
          }
        }
      }
      function newCardNotification(isFromLink) {
        events.emit("bp/did-show-card", getActiveCard().id, getActiveTab(), isFromLink);
      }
      // This interferes with slider usage which also needs left/right arrow keys
      //    function onKeyDown(evt) {
      //      var LEFT     = 37,
      //        RIGHT    = 39;
      //
      //      if (evt.keyCode === LEFT) {
      //        prevCard();
      //      }
      //      else if (evt.keyCode === RIGHT) {
      //        nextCard();
      //      }
      //    }
      function toggleCardActive(cardElement, isActive) {
        if (isActive) {
          cardElement.className = cardElement.className + " scp-active";
        } else {
          cardElement.className = cardElement.className.replace("scp-active", "");
        }
      }
      function getActiveTab() {
        var activeCard = getActiveCard(), tabId = activeCard.getAttribute("aria-labelledby");
        return document.getElementById(tabId);
      }
      function moveIndicator() {
        if (!activePanel) {
          return;
        }
        var chosenItem = getActiveTab(), bpScale = state.get("scale"), indicator = activePanel.querySelector(".scp-card-indicator"), indicatorRect = indicator.getBoundingClientRect(), chosenItemRect = chosenItem.getBoundingClientRect(), choseItemLeft = chosenItemRect.left - indicatorRect.left, indicatorLeft = -442 + (choseItemLeft + chosenItemRect.width / 2) / bpScale, previouslyChosen = chosenItem.parentNode.querySelector('[aria-selected="true"]');
        // Reset old selection
        if (previouslyChosen) {
          previouslyChosen.setAttribute("aria-selected", "false");
        }
        // Set indicator
        inlineStyle(indicator).backgroundPosition = indicatorLeft + "px 0";
        chosenItem.setAttribute("aria-selected", "true");
      }
      function isDisabled(id) {
        return byId(id).hasAttribute("aria-disabled");
      }
      function getActiveCard() {
        return activePanel && activePanel.getElementsByClassName("scp-active")[0];
      }
      /**
   * Switch to a new card
   * @param direction 1 for next card, -1 for previous
   * @param fromCard (optional) Card to navigate to next/prev from. If not specified will use current active card
   */
      function switchCard(direction, fromCard) {
        var cardToSelect, activeCard = fromCard || getActiveCard();
        if (activeCard) {
          cardToSelect = 1 === direction ? activeCard.nextElementSibling : activeCard.previousElementSibling;
          if (!cardToSelect) {
            cardToSelect = 1 === direction ? activePanel.firstElementChild : activePanel.lastElementChild;
          }
          if (!selectNewCard(cardToSelect)) {
            switchCard(direction, cardToSelect);
          }
        }
      }
      // Returns true on success
      function selectNewCard(cardToSelect, isFromLink) {
        if (cardToSelect) {
          // Always skip advanced cards for now
          if ("sc-card" === cardToSelect.localName && !cardToSelect.hasAttribute("data-advanced")) {
            toggleCardActive(getActiveCard(), false);
            toggleCardActive(cardToSelect, true);
            moveIndicator();
            newCardNotification(isFromLink);
            // At first, back button is disabled when on first card
            // However, once we've gone forward we allow backwards cycling
            byId(BP_CONST.PREV_ID).removeAttribute("aria-disabled");
            return true;
          }
        }
      }
      function nextCard() {
        switchCard(1);
      }
      function prevCard() {
        if (!isDisabled(BP_CONST.PREV_ID)) {
          switchCard(-1);
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        loadPanelContents("settings");
        loadPanelContents("tips");
        events.on("bp/did-open-subpanel", onPanelUpdate);
      }
      return {
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_locale, run_bp_model_state, run_util_xhr, run_conf_urls, run_events, run_platform, run_inline_style_inline_style);
    bp_secondary_bp_secondary_features = function(BP_CONST, tips, settings, feedback, about, cards) {
      var featureDefs = {
        tips: {
          module: tips,
          menuButtonId: BP_CONST.TIPS_BUTTON_ID,
          labelId: BP_CONST.TIPS_LABEL_ID,
          panelId: BP_CONST.TIPS_CONTENT_ID
        },
        settings: {
          module: settings,
          menuButtonId: BP_CONST.SETTINGS_BUTTON_ID,
          labelId: BP_CONST.SETTINGS_LABEL_ID,
          panelId: BP_CONST.SETTINGS_CONTENT_ID
        },
        feedback: {
          module: feedback,
          menuButtonId: BP_CONST.FEEDBACK_BUTTON_ID,
          labelId: BP_CONST.FEEDBACK_LABEL_ID,
          panelId: BP_CONST.FEEDBACK_CONTENT_ID
        },
        about: {
          module: about,
          menuButtonId: BP_CONST.ABOUT_BUTTON_ID,
          menuButtonHelperId: BP_CONST.ABOUT_ROTATE_HELPER_ID,
          animatedImageId: BP_CONST.ABOUT_CONTENT_IMAGE_ID,
          labelId: BP_CONST.ABOUT_LABEL_ID,
          panelId: BP_CONST.ABOUT_CONTENT_ID,
          heightAnimationDelay: 1200
        }
      };
      function init() {
        about.init();
        feedback.init();
        settings.init();
        tips.init();
        cards.init();
      }
      return {
        featureDefs: featureDefs,
        init: init
      };
    }(run_bp_constants, bp_secondary_tips, bp_secondary_settings, bp_secondary_feedback, bp_secondary_about, bp_secondary_cards);
    bp_secondary_bp_secondary = function(BP_CONST, state, view, helper, animate, transformUtil, locale, platform, markup, secondaryFeatures, events, nativeGlobal, inlineStyle) {
      var origPanelContentsRect, origOutlineHeight, origFillHeight, isInitialized, hasOpened, fadeInTimer, animateHeightTimer, animationsCompleteTimer, BUTTON_DROP_ANIMATION_MS = 800, ENABLED_PANEL_TRANSLATE_Y = 0, DISABLED_PANEL_TRANSLATE_Y = -198, MORE_BUTTON_ROTATION_ENABLED = -180, runningAnimations = [], isActive = false, features = secondaryFeatures.featureDefs, // Oft-used functions. Putting it in a variable helps minifier, convenience, brevity
      byId = helper.byId, CONTENTS_HEIGHT = 780;
      /********************** UTIL **************************/
      // TODO code related to the individual features should move into bp-secondary-features.js
      function forEachFeature(fn) {
        for (var feature in features) {
          if (features.hasOwnProperty(feature)) {
            fn(features[feature]);
          }
        }
      }
      /**
   * Notify the entire panel that changes have occurred
   * @param featureName or falsey value for button menu
   */
      function updateGlobalState(featureName, isSecondaryExpanding) {
        state.set("secondaryPanelName", featureName || "button-menu");
        state.set("isSecondaryExpanding", isSecondaryExpanding);
        state.set("wasMouseInPanel", false);
        // When panel shrinks mouse needs to go back inside of it before mouseout closes again
        view.update();
      }
      function getBPContainer() {
        return byId(BP_CONST.BP_CONTAINER_ID);
      }
      function getSecondary() {
        return byId(BP_CONST.SECONDARY_ID);
      }
      function getMoreButton() {
        return byId(BP_CONST.MORE_BUTTON_CONTAINER_ID);
      }
      function getBottom() {
        return byId(BP_CONST.BOTTOM_MORE_ID);
      }
      function getShadow() {
        return byId("scp-shadow");
      }
      function getOutlineFill() {
        return byId("scp-secondary-fill");
      }
      function getSecondaryOutline() {
        return byId("scp-secondary-outline");
      }
      /********************** ANIMATIONS **************************/
      // When something major happens, such as an action to open a new panel, we cancel all current animations
      function finishAllAnimations() {
        runningAnimations.forEach(function(animation) {
          animation.finishNow();
        });
        clearTimeout(fadeInTimer);
        clearTimeout(animateHeightTimer);
        clearTimeout(animationsCompleteTimer);
        runningAnimations.length = 0;
      }
      // Create an animation and store it in runningAnimations so we can cancel it if need be
      function createAnimation(elems, values, duration, onFinishFn) {
        nativeGlobal.setTimeout(function() {
          var newAnimation = animate.animateTransforms(elems, values, duration, onFinishFn);
          runningAnimations.push(newAnimation);
        }, 18);
      }
      // Move up to make sure we fit onscreen when the secondary feature expands
      function getAmountToShiftSecondaryTop() {
        var panelTop = byId(BP_CONST.MAIN_OUTLINE_ID).getBoundingClientRect().top, secondaryBottom = panelTop + CONTENTS_HEIGHT, FUDGE_FACTOR = 190, // Extra space at bottom -- for more button and just space itself
        MIN_TOP = 10, screenBottomOverlap = secondaryBottom - FUDGE_FACTOR - window.innerHeight;
        // Don't shift above top of screen, and only shift up (or not at all)
        return Math.max(Math.min(screenBottomOverlap, panelTop - MIN_TOP), 0);
      }
      function animateButtonMenuDrop(willEnable) {
        var secondaryId = BP_CONST.SECONDARY_ID, secondaryPanel = byId(secondaryId), fromTranslateY = willEnable ? DISABLED_PANEL_TRANSLATE_Y : ENABLED_PANEL_TRANSLATE_Y, toTranslateY = willEnable ? ENABLED_PANEL_TRANSLATE_Y : DISABLED_PANEL_TRANSLATE_Y, moreBtnEndRotation = willEnable ? MORE_BUTTON_ROTATION_ENABLED : 0, moreButtonTransform = {
          translateY: willEnable ? toTranslateY : 0,
          rotate: moreBtnEndRotation
        }, secondaryPanelTransform = {
          translateY: toTranslateY
        };
        function onFinish() {
          secondaryFeatures.init();
          state.set("isSecondaryPanel", willEnable);
          view.update(true);
          updateMoreButtonLabel(willEnable);
        }
        finishAllAnimations();
        transformUtil.setElemTransform(secondaryPanel, {
          translateY: fromTranslateY
        });
        // Starting point
        createAnimation([ secondaryPanel, getMoreButton() ], [ secondaryPanelTransform, moreButtonTransform ], BUTTON_DROP_ANIMATION_MS, onFinish);
      }
      function getGeometryTargets(featureName, menuButton) {
        var feature = features[featureName], origMenuBtnTransforms = BP_CONST.TRANSFORMS[menuButton.id], panelContentsHeight = CONTENTS_HEIGHT, baseGeometryTargets = {
          false: {
            // Feature disabled
            outlineHeight: origOutlineHeight,
            menuBtnTranslateX: origMenuBtnTransforms.translateX,
            menuBtnRotate: 0,
            // Will be used by icons that roll
            bpContainerTranslateY: 0
          },
          true: {
            // Feature enabled
            outlineHeight: panelContentsHeight + 103,
            // The outline
            menuBtnTranslateX: 26,
            // The icon rolls left by default
            menuBtnRotate: 0,
            // Will be used by the icons that roll
            bpContainerTranslateY: getAmountToShiftSecondaryTop()
          }
        };
        return feature.module.getGeometryTargets(baseGeometryTargets);
      }
      function getCurrentOutlineHeight() {
        function getOutlineSVG() {
          return byId(BP_CONST.MAIN_OUTLINE_BORDER_ID);
        }
        var outlinePath = getOutlineSVG().getAttribute("d");
        return parseInt(outlinePath.split(" ")[2]);
      }
      function animateFeature(name, doEnable) {
        var feature = features[name], animatedImageElem = byId(feature.animatedImageId), rotationHelperElem = byId(feature.menuButtonHelperId), menuButton = byId(feature.menuButtonId), bpContainer = getBPContainer(), currentBpContainerTransforms = transformUtil.getStyleTransformMap(bpContainer), geometryTargets = getGeometryTargets(name, menuButton), toGeo = geometryTargets[doEnable], ENABLE_ANIMATION_MS = 1500, DISABLE_ANIMATION_MS = 750, wasEnabled = !!getFeaturePanelName(), percentRemaining = wasEnabled === doEnable ? 0 : 1, heightAnimationDuration = (doEnable ? ENABLE_ANIMATION_MS : DISABLE_ANIMATION_MS) * percentRemaining, heightAnimationDelay = doEnable && feature.heightAnimationDelay || 0, openFeatureDuration = doEnable && feature.heightAnimationDelay ? ENABLE_ANIMATION_MS : heightAnimationDuration, animationsCompleteMs = Math.max(openFeatureDuration, heightAnimationDelay + heightAnimationDuration);
        // When is feature fully visible
        function fadeInTextContentWhenLargeEnough() {
          fadeInTimer = nativeGlobal.setTimeout(function() {
            state.set("isSecondaryExpanding", false);
            view.update();
          }, heightAnimationDelay + .7 * heightAnimationDuration);
        }
        function onAnimationsComplete() {
          state.set("isSecondaryExpanded", doEnable);
          view.update(true);
        }
        function animateHeight() {
          var newPanelHeight = toGeo.outlineHeight, newTranslateY = currentBpContainerTransforms.translateY - toGeo.bpContainerTranslateY, bottomTranslateY = newPanelHeight - origOutlineHeight, BOTTOM_Y_OFFSET = -188, moreButtonTransform = {
            translateY: newPanelHeight + BOTTOM_Y_OFFSET
          }, bottomTransform = {
            translateY: newPanelHeight + BOTTOM_Y_OFFSET
          }, outlineFillTransform = {
            scale: newPanelHeight / origFillHeight,
            scaleType: "scaleY"
          }, secondaryOutlineTransform = {
            translateY: bottomTranslateY
          }, shadowTransform = {
            translateY: doEnable ? 435 : 0
          }, bpContainerTransform = {
            translateY: newTranslateY
          };
          createAnimation([ getMoreButton(), getBottom(), getOutlineFill(), getSecondaryOutline(), getShadow(), bpContainer ], [ moreButtonTransform, bottomTransform, outlineFillTransform, secondaryOutlineTransform, shadowTransform, bpContainerTransform ], heightAnimationDuration);
        }
        function openFeatureAnimation() {
          var // Rotations (for the about button) need to be done half and half, otherwise the rotation does not happen
          // Basically, the browser optimizes a -360deg rotation as 0!
          // So we do -180 on the parent and -180 on the child
          // Don't need to use in IE where CSS transitions aren't used with SVG
          toRotation = toGeo.menuBtnRotate / 2, menuButtonTransform = {
            translateX: toGeo.menuBtnTranslateX,
            rotate: toRotation
          }, rotationHelperTransform = {
            rotate: toRotation
          }, animatedImageTransform = {
            translateX: toGeo.menuImageTranslateX
          };
          createAnimation([ menuButton, rotationHelperElem, animatedImageElem ], [ menuButtonTransform, rotationHelperTransform, animatedImageTransform ], openFeatureDuration);
        }
        finishAllAnimations();
        if (doEnable && getFeaturePanelName()) {
          // If we are switching from one panel to another, make sure buttons start from initial state
          resetButtonStyles();
        }
        updateGlobalState(doEnable && name, doEnable);
        // Animate the menu button and anything else related to opening the feature
        openFeatureAnimation();
        // Animate the height at the right time
        animateHeightTimer = nativeGlobal.setTimeout(animateHeight, heightAnimationDelay);
        animationsCompleteTimer = nativeGlobal.setTimeout(onAnimationsComplete, animationsCompleteMs);
        fadeInTextContentWhenLargeEnough();
        events.emit("bp/will-show-secondary-feature", name);
      }
      /********************** INTERACTIONS **************************/
      function onMenuButtonClick(e) {
        var featureName = e.currentTarget.getAttribute("data-feature");
        if (featureName) {
          toggleFeature(featureName);
        }
      }
      function getFeaturePanelName() {
        var secondaryPanelName = state.getSecondaryPanelName();
        return features[secondaryPanelName] && secondaryPanelName;
      }
      /**
   * Toggle back and forth between main panel and secondary panel
   */
      function toggleSecondaryPanel(feature) {
        var featurePanelName = feature || getFeaturePanelName();
        if (featurePanelName) {
          toggleFeature(featurePanelName);
          return;
        }
        var ENABLED = BP_CONST.SECONDARY_PANEL_ENABLED, DISABLED = BP_CONST.SECONDARY_PANEL_DISABLED, willEnable = state.get("secondaryPanelTransitionTo") !== ENABLED;
        state.set("secondaryPanelTransitionTo", willEnable ? ENABLED : DISABLED);
        updateGlobalState();
        if (true) {
          console.log("Transitioning secondary panel to mode: " + state.get("secondaryPanelTransitionTo"));
        }
        //Text anchors don't work in Edge, and furthermore the secondary panel isn't rendered in Edge until it is enabled
        //So this is where we have access to the length of the string and can reposition the text elements correctly
        if (!hasOpened) {
          hasOpened = true;
          if (platform.browser.isEdge) {
            helper.fixTextAnchors(byId(BP_CONST.SECONDARY_ID));
          }
        }
        animateButtonMenuDrop(willEnable);
        toggleMouseListeners(willEnable);
      }
      function updateMoreButtonLabel(doPointToMainPanel) {
        nativeGlobal.setTimeout(function() {
          var labelName = doPointToMainPanel ? "sitecues_main_panel" : "more_features", localizedLabel = locale.translate(labelName);
          byId(BP_CONST.MORE_BUTTON_GROUP_ID).setAttribute("aria-label", localizedLabel);
        }, 500);
      }
      /**
   * Return truthy value if feature is loaded and available
   * @param featureName
   * @returns {*|HTMLElement}
   */
      function isFeatureAvailable(featureName) {
        return byId(features[featureName].panelId);
      }
      /**
   * Toggle back and forth between button menu and a feature
   * @param featureName
   */
      function toggleFeature(featureName) {
        var willEnable = state.getSecondaryPanelName() !== featureName;
        updateMoreButtonLabel(!willEnable);
        if (willEnable && !isFeatureAvailable(featureName)) {
          // The feature was not loaded yet -- wait until loaded
          events.on("bp/content-loaded", function() {
            if (state.isButtonMenu()) {
              // Make sure user hasn't left the 4 button menu while we waited
              toggleFeature(featureName);
            }
          });
        } else {
          events.emit("bp/will-toggle-feature");
          animateFeature(featureName, willEnable);
        }
      }
      function toggleMouseListeners(willBeActive) {
        if (isActive === willBeActive) {
          return;
        }
        isActive = willBeActive;
        var addOrRemoveFn = isActive ? "addEventListener" : "removeEventListener";
        function addOrRemoveClick(id) {
          var elem = byId(id);
          elem[addOrRemoveFn]("click", onMenuButtonClick);
        }
        forEachFeature(function(feature) {
          addOrRemoveClick(feature.menuButtonId);
          addOrRemoveClick(feature.labelId);
        });
      }
      /********************** INIT / RESET **************************/
      function resetStyles() {
        var moreButton = getMoreButton(), HEIGHT_RELATED_ELEMS = [ getSecondary(), moreButton, getBottom(), getOutlineFill(), getSecondaryOutline(), getShadow() ];
        HEIGHT_RELATED_ELEMS.forEach(function(elem) {
          transformUtil.setElemTransform(elem, {});
          if (true) {
            // Do not use will-change in Firefox as it caused SC-3421 on some sites
            inlineStyle(elem).willChange = "transform";
          }
        });
        resetWebKitLayout(moreButton);
        resetButtonStyles();
      }
      function resetWebKitLayout(elem) {
        // Hack to fix Chrome/Safari bug where the more button was in the wrong place after resetting styles
        // This forces WebKit to reflow the element's layout.
        var style = inlineStyle(elem), display = style.display;
        style.display = "none";
        // jshint unused:false
        getBPContainer().offsetHeight;
        // Force layout refresh
        style.display = display;
      }
      function resetButtonStyles() {
        // Menu buttons
        forEachFeature(function(feature) {
          var button = feature.menuButtonId, transform = BP_CONST.TRANSFORMS[button], buttonElem = byId(button);
          transformUtil.setElemTransform(buttonElem, transform);
          if (feature.menuButtonHelperId) {
            transformUtil.setElemTransform(byId(feature.menuButtonHelperId), {});
          }
          if (feature.animatedImageId) {
            transformUtil.setElemTransform(byId(feature.animatedImageId), {});
          }
          resetWebKitLayout(buttonElem);
        });
      }
      function onPanelClose() {
        if (state.isSecondaryPanelRequested()) {
          // Toggle current panel off
          events.emit("bp/did-toggle-" + state.getSecondaryPanelName(), false);
        }
        finishAllAnimations();
        resetStyles();
        // Next time panel opens, it will be at the main panel;
        // Therefore, the more button label for screen readers needs to indicate the secondary panel will open
        updateMoreButtonLabel();
        state.set("secondaryPanelTransitionTo", BP_CONST.SECONDARY_PANEL_DISABLED);
        updateGlobalState();
        toggleMouseListeners(false);
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          // Insert the markup for the secondary panel
          markup.init();
          resetButtonStyles();
          origOutlineHeight = getCurrentOutlineHeight();
          origFillHeight = parseFloat(getOutlineFill().getAttribute("height"));
          origPanelContentsRect = document.getElementById(BP_CONST.MAIN_CONTENT_FILL_ID).getBoundingClientRect();
          events.on("bp/will-shrink", onPanelClose);
          events.emit("bp/did-init-secondary");
        }
      }
      return {
        init: init,
        toggleSecondaryPanel: toggleSecondaryPanel,
        toggleFeature: toggleFeature
      };
    }(run_bp_constants, run_bp_model_state, run_bp_view_view, run_bp_helper, bp_expanded_view_transform_animate, bp_expanded_view_transform_util, run_locale, run_platform, bp_secondary_insert_secondary_markup, bp_secondary_bp_secondary_features, run_events, mini_core_native_global, run_inline_style_inline_style);
    bp_toolbar_badge_bp_toolbar_badge = function(Promise, site, BP_CONST, state, helper, palette, baseView) {
      var TOOLBAR_HEIGHT = 38;
      function adjustFixedElementsBelowToolbar() {
        return new Promise(function(resolve) {
          !function(positioner, scrollbars) {
            // In the case of the toolbar, we must always move fixed position elements
            // down, so that they are not obscured by our toolbar.
            scrollbars.init();
            positioner.initFromToolbar(resolve, TOOLBAR_HEIGHT);
          }(page_positioner_positioner, page_viewport_scrollbars);
        });
      }
      function init() {
        var toolbarElement = document.createElement("sc"), docElem = document.documentElement;
        function insertOptionsMenu() {
          if (site.get("hasOptionsMenu")) {
            !function(bpToolbarMenuButton) {
              bpToolbarMenuButton.init(toolbarElement);
            }(bp_toolbar_menu_button_bp_toolbar_menu_button);
          }
        }
        docElem.setAttribute("data-sitecues-toolbar", "");
        // Enable default.css rules
        docElem.appendChild(toolbarElement);
        helper.setAttributes(toolbarElement, BP_CONST.DEFAULT_TOOLBAR_ATTRS);
        state.set("isPageBadge", false);
        state.set("isToolbarBadge", true);
        return palette.init(null).then(function() {
          baseView.init(toolbarElement);
        }).then(adjustFixedElementsBelowToolbar).then(insertOptionsMenu);
      }
      return {
        init: init
      };
    }(Promise, run_conf_site, run_bp_constants, run_bp_model_state, run_bp_helper, run_bp_view_palette, run_bp_view_view);
    bp_toolbar_menu_button_bp_toolbar_menu_button = function(urls, domEvents, locale, CORE_CONST, Promise, nativeGlobal) {
      var menuButtonElement, hideTimeout, bpToolbarMenu, lastOpenTime, KEY_CODES = CORE_CONST.KEY_CODE, WAIT_BEFORE_CLOSE_MS = 300;
      function insertSheet(name) {
        return new Promise(function(resolve, reject) {
          var cssLink = document.createElement("link"), cssUrl = urls.resolveResourceUrl("css/" + name + ".css");
          cssLink.setAttribute("rel", "stylesheet");
          cssLink.setAttribute("href", cssUrl);
          cssLink.id = "sitecues-js-" + name;
          domEvents.on(cssLink, "load", resolve);
          domEvents.on(cssLink, "error", reject);
          document.querySelector("head").appendChild(cssLink);
        });
      }
      function setOpen(doExpand) {
        menuButtonElement.setAttribute("aria-expanded", doExpand);
      }
      function isExpanded() {
        return "true" === menuButtonElement.getAttribute("aria-expanded");
      }
      function requestOpen(willOpen) {
        var isOpen = isExpanded();
        if (willOpen !== isOpen) {
          if (!bpToolbarMenu || !bpToolbarMenu.hasFocus()) {
            // Don't close while interacting with keyboard
            toggle();
          }
          if (willOpen) {
            lastOpenTime = getCurrentTime();
          }
        }
      }
      function getCurrentTime() {
        return new Date().getTime();
      }
      function toggle() {
        var willOpen = !isExpanded(), ready = Promise.resolve();
        function doToggle() {
          setOpen(willOpen);
          bpToolbarMenu.requestOpen(willOpen);
        }
        if (willOpen && !bpToolbarMenu) {
          // Styles for menu
          var sheetLoaded = insertSheet("bp-toolbar-menu"), toolbarInitialized = new Promise(function(resolve) {
            !function(_bpToolbarMenu) {
              bpToolbarMenu = _bpToolbarMenu;
              bpToolbarMenu.init(menuButtonElement, resolve);
            }(bp_toolbar_menu_bp_toolbar_menu);
          });
          ready = Promise.all([ sheetLoaded, toolbarInitialized ]);
        }
        ready.then(doToggle);
      }
      function onBlur() {
        clearTimeout(hideTimeout);
        requestOpen(false);
      }
      function init(toolbarElement) {
        // Styles for menu button
        insertSheet("bp-toolbar-menu-button");
        // Create element
        menuButtonElement = document.createElement("sc");
        menuButtonElement.id = "scp-toolbar-menu-button";
        // Hide until stylesheet loaded
        menuButtonElement.style.display = "none";
        // Accessibility
        menuButtonElement.setAttribute("role", "button");
        menuButtonElement.setAttribute("aria-label", locale.translate("options_menu"));
        menuButtonElement.setAttribute("aria-haspopup", true);
        menuButtonElement.setAttribute("tabindex", 0);
        setOpen(false);
        // Mouse cursor
        menuButtonElement.className = "scp-hand-cursor";
        // Interactions
        domEvents.on(menuButtonElement, "click", function(event) {
          if (event.target !== menuButtonElement) {
            return;
          }
          if (!isExpanded() || getCurrentTime() - lastOpenTime > 1e3) {
            toggle();
          }
        });
        domEvents.on(menuButtonElement, "mouseenter", function() {
          clearTimeout(hideTimeout);
          requestOpen(true);
        });
        domEvents.on(toolbarElement, "mouseleave", function(event) {
          if (event.target === toolbarElement) {
            // You have to leave the toolbar itself in order to close the menu
            // (We tried just putting mouseleave on the button, but the menu would close too easily while moving from the button to the menu)
            clearTimeout(hideTimeout);
            hideTimeout = nativeGlobal.setTimeout(function() {
              requestOpen(false);
            }, WAIT_BEFORE_CLOSE_MS);
          }
        });
        domEvents.on(menuButtonElement, "blur", function() {
          nativeGlobal.setTimeout(onBlur, 0);
        });
        domEvents.on(menuButtonElement, "keydown", function(event) {
          if (event.target === menuButtonElement) {
            var keyCode = event.keyCode;
            if (keyCode === KEY_CODES.ENTER || keyCode === KEY_CODES.SPACE_KEY || keyCode === KEY_CODES.DOWN) {
              requestOpen(true);
            }
          }
        });
        // Append to document
        toolbarElement.appendChild(menuButtonElement);
      }
      return {
        toggle: toggle,
        init: init
      };
    }(run_conf_urls, run_dom_events, run_locale, run_constants, Promise, mini_core_native_global);
    bp_toolbar_menu_bp_toolbar_view = function(nativeGlobal) {
      var menuElement, origClasses, closeDelay;
      function toggleClass(name, doForce) {
        var classList = menuElement.classList;
        if (doForce) {
          classList.add(name);
        } else {
          classList.remove(name);
        }
      }
      function setSize(rect) {
        menuElement.style.width = rect.width + "px";
        menuElement.style.height = rect.height + "px";
      }
      function showBlurb(blurbName) {
        var targetRect, BLURB_ANIMATION_MS = 300, origRect = menuElement.getBoundingClientRect(), blurbElement = document.getElementById("scp-blurb-" + blurbName), previouslyVisibleBlurb = menuElement.getAttribute("data-blurb");
        function updateDomForBlurb() {
          if (previouslyVisibleBlurb) {
            toggleClass("scp-blurb-" + previouslyVisibleBlurb, false);
          }
          toggleClass("scp-blurb-" + blurbName, true);
          toggleClass("scp-blurb", true);
          menuElement.setAttribute("data-blurb", blurbName);
          blurbElement.removeAttribute("data-blurb-ready");
        }
        // Fix to current screen position -- don't roll up with toolbar as it slides up
        function fixScreenPosition() {
          menuElement.style.position = "fixed";
          menuElement.style.top = origRect.top + "px";
          menuElement.style.right = window.innerWidth - origRect.right + "px";
        }
        function animateToTargetSize() {
          // Animate from original width:height
          targetRect = menuElement.getBoundingClientRect();
          setSize(origRect);
          // Animate to target width:height
          // jshint -W030
          menuElement.offsetHeight;
          // Ask layout engine to update
          menuElement.style.transition = "width " + BLURB_ANIMATION_MS + "ms, height " + BLURB_ANIMATION_MS + "ms";
          menuElement.offsetHeight;
          // Ask layout engine to update
          // Set target size
          setSize(targetRect);
          toggleClass("scp-blurb-fade-in-text", true);
          menuElement.offsetHeight;
        }
        function enableKeyboard() {
          // Focus the blurb so that it is spoken
          // Pressing escape or clicking outside will close it
          // (Mousing out won't close while focus is there)
          // Overall, the experience of the blurb is that it stays on screen unless intentionally dismissed with click/Escape,
          // to ensure that it is read before accidentally disappearing.
          blurbElement.setAttribute("tabindex", "-1");
          blurbElement.focus();
        }
        function onAnimationComplete() {
          blurbElement.setAttribute("data-blurb-ready", "");
        }
        updateDomForBlurb();
        menuElement.style.cssText = "";
        // Reset styles
        fixScreenPosition();
        animateToTargetSize();
        enableKeyboard();
        nativeGlobal.setTimeout(onAnimationComplete, BLURB_ANIMATION_MS);
      }
      function enableFocus(isFocusEnabled) {
        toggleClass("scp-has-focus", isFocusEnabled);
        toggleClass("scp-no-focus", !isFocusEnabled);
      }
      function reset() {
        menuElement.className = origClasses;
        menuElement.style.cssText = "";
        menuElement.removeAttribute("data-blurb");
        closeDelay = 0;
      }
      function init(_menuElement) {
        menuElement = _menuElement;
        origClasses = menuElement.className;
      }
      return {
        reset: reset,
        showBlurb: showBlurb,
        enableFocus: enableFocus,
        init: init
      };
    }(mini_core_native_global);
    bp_toolbar_menu_bp_toolbar_features = function(metric, constants, bpToolbarView, events, domEvents, nativeGlobal) {
      function hideMenu() {
        !function(bpToolbarMenuButton) {
          bpToolbarMenuButton.toggle();
        }(bp_toolbar_menu_button_bp_toolbar_menu_button);
      }
      // Provide basic info on Sitecues and allow user to jump directly to tips panel
      function whatIsThis() {
        var EXTRA_DELAY_BETWEEN_VIEWS = 800;
        function showTips() {
          events.off("bp/did-open-subpanel", showTips);
          !function(bpSecondary) {
            nativeGlobal.setTimeout(function() {
              bpSecondary.toggleFeature("tips");
            }, EXTRA_DELAY_BETWEEN_VIEWS);
          }(bp_secondary_bp_secondary);
        }
        function showSecondaryPanel() {
          events.off("bp/did-expand", showSecondaryPanel);
          !function(moreButton) {
            moreButton.init();
            moreButton.show(function() {
              nativeGlobal.setTimeout(moreButton.activate, EXTRA_DELAY_BETWEEN_VIEWS);
            });
            events.on("bp/did-open-subpanel", showTips);
          }(bp_expanded_view_more_button);
        }
        function beginTipsTour() {
          events.on("bp/did-expand", showSecondaryPanel);
          expandPanel();
        }
        function expandPanel() {
          hideMenu();
          !function(expandController) {
            expandController.init();
            expandController.expandPanel();
          }(run_bp_controller_expand_controller);
        }
        bpToolbarView.showBlurb("what-is");
        enableBlurbItem("scp-blurb-tour-tips", beginTipsTour);
        enableBlurbItem("scp-blurb-slider-bar", expandPanel);
      }
      // Reset Sitecues settings
      function turnOff() {
        !function(reset) {
          // Reset Sitecues settings
          reset.init();
          reset.resetAll();
          // Enable option to completely hide Sitecues
          bpToolbarView.showBlurb("hide");
          enableBlurbItem("scp-blurb-hide-button", hide);
        }(page_reset_reset);
      }
      // Hide Sitecues
      function hide() {
        var sitecuesToolbar = document.getElementById("sitecues-badge");
        function checkF8(event) {
          if (event.keyCode === constants.KEY_CODE.F8) {
            // Reenable Sitecues
            unhide();
          }
        }
        function unhide() {
          // Unhide Sitecues:
          // User has pressed F8 or clicked unhide option (after initially hiding Sitecues)
          document.removeEventListener("keydown", checkF8);
          localStorage.removeItem("sitecues-disabled");
          sitecuesToolbar.style.top = "";
          var currentFocus = document.activeElement;
          if ("sc-blurb" === currentFocus.localName) {
            currentFocus.blur();
          }
        }
        // Animate hiding of Sitecues toolbar
        sitecuesToolbar.style.transition = "top 500ms linear";
        requestAnimationFrame(function() {
          sitecuesToolbar.style.top = "-40px";
        });
        // Disable for next time, on this site
        localStorage.setItem("sitecues-disabled", true);
        // F8 can reenable
        document.addEventListener("keydown", checkF8);
        // Show new blurb on how to unhide
        bpToolbarView.showBlurb("unhide");
        enableBlurbItem("scp-blurb-unhide", unhide);
      }
      function enableBlurbItem(id, activateFn) {
        var blurb = document.getElementById(id);
        domEvents.on(blurb, "click", activateFn);
        domEvents.on(blurb, "keydown", function(event) {
          if (event.keyCode === constants.KEY_CODE.ENTER || event.keyCode === constants.KEY_CODE.SPACE) {
            activateFn();
          }
        });
      }
      function activateFeatureById(id, hasFocus) {
        var ALL_FEATURES = {
          "scp-toolbar-what-is": whatIsThis,
          "scp-toolbar-turn-off": turnOff
        };
        var feature = ALL_FEATURES[id];
        if (feature) {
          new metric.OptionMenuItemSelection({
            target: id
          }).send();
          feature(hasFocus);
        }
      }
      return {
        activateFeatureById: activateFeatureById
      };
    }(run_metric_metric, run_constants, bp_toolbar_menu_bp_toolbar_view, run_events, run_dom_events, mini_core_native_global);
    bp_toolbar_menu_bp_toolbar_menu = function(bpToolbarFeatures, bpToolbarView, locale, urls, xhr, CORE_CONST, metric, events, domEvents, nativeGlobal) {
      var menuButtonElement, menuElement, origViewClasses, KEY_CODES = CORE_CONST.KEY_CODE;
      function requestOpen(doOpen) {
        if (isOpen() !== doOpen) {
          events.emit("bp/did-toggle-menu", doOpen);
          if (doOpen) {
            bpToolbarView.reset();
            new metric.OptionMenuOpen().send();
          }
          var doFocusMenuItem = doOpen && isMenuButtonFocused();
          if (doFocusMenuItem) {
            nativeGlobal.setTimeout(function() {
              menuElement.firstElementChild.focus();
            }, 0);
          }
          bpToolbarView.enableFocus(doFocusMenuItem);
          // jshint -W030
          menuElement.offsetHeight;
          // Browser: wke up from your slumber!
          // jshint +W030
          menuElement.setAttribute("aria-hidden", !doOpen);
        }
      }
      // Specify menu item element to focus.
      // If none specified, first menu item will receive focus
      function focusAdjacentVisibleItem(startElement, direction) {
        var nextProp = 1 === direction ? "nextElementSibling" : "previousElementSibling", wrapAroundProp = 1 === direction ? "firstElementChild" : "lastElementChild", element = startElement;
        function getVisibleItemInDirection() {
          while (true) {
            element = element[nextProp] || element.parentElement[wrapAroundProp];
            if ("none" !== getComputedStyle(element).display) {
              return element;
            }
            if (element === startElement) {
              return element;
            }
          }
        }
        getVisibleItemInDirection().focus();
      }
      function hasFocus() {
        var focusedElem = document.activeElement;
        return focusedElem.parentElement === menuElement;
      }
      function isOpen() {
        return "false" === menuElement.getAttribute("aria-hidden");
      }
      function addSemanticSugar(html) {
        return html.replace(/<sc-toolbar-menuitem/g, '<sc-toolbar-menuitem role="menuitem" class="scp-hand-cursor scp-tabbable"');
      }
      function isMenuButtonFocused() {
        return document.activeElement === menuButtonElement;
      }
      function isFocusable(element) {
        return element.hasAttribute("tabindex");
      }
      function onHover(event) {
        if (hasFocus()) {
          // We don't want a separate focus from hover -- too confusing
          // If a menuitem is focused and we hover over a different one, just focus it
          if (isFocusable(event.target)) {
            event.target.focus();
          }
        }
      }
      function activateMenuItem(event) {
        var menuItem = event.target;
        if (!isFocusable(menuItem)) {
          menuItem = menuItem.parentElement;
        }
        bpToolbarFeatures.activateFeatureById(menuItem.id, hasFocus());
      }
      function onKeyDown(event) {
        switch (event.keyCode) {
         case KEY_CODES.SPACE:
         case KEY_CODES.ENTER:
          activateMenuItem(event);
          break;

         case KEY_CODES.ESCAPE:
          requestOpen(false);
          document.activeElement.blur();
          break;

         case KEY_CODES.DOWN:
          focusAdjacentVisibleItem(event.target, 1);
          break;

         case KEY_CODES.UP:
          focusAdjacentVisibleItem(event.target, -1);
        }
      }
      function initInteractions() {
        domEvents.on(menuElement, "mouseenter", onHover);
        domEvents.on(menuElement, "keydown", onKeyDown);
        domEvents.on(menuElement, "click", activateMenuItem);
      }
      // Remove elements unless required by the site config
      function removeAllElements(panelElement, elementsToRemoveSelector) {
        function hide(elements) {
          var element, index = elements.length;
          while (index--) {
            element = elements[index];
            element.parentNode.removeChild(element);
          }
        }
        var elementsToRemove = panelElement.querySelectorAll(elementsToRemoveSelector);
        hide(elementsToRemove);
      }
      function removeUnsupportedContent(menuElement) {
        var whatToRemove = true ? "page" : "extension";
        removeAllElements(menuElement, '[data-sitecues-type="' + whatToRemove + '"]');
      }
      function init(_menuButtonElement, callback) {
        if (menuButtonElement) {
          callback();
          return;
        }
        menuButtonElement = _menuButtonElement;
        var localizedPanelName = "toolbar-menu-" + locale.getUiLocale(), panelUrl = urls.resolveResourceUrl("html/toolbar-menu/" + localizedPanelName + ".html");
        xhr.get({
          url: panelUrl,
          success: function(html) {
            var finalHTML = addSemanticSugar(html);
            menuButtonElement.innerHTML = finalHTML;
            menuElement = menuButtonElement.firstElementChild;
            bpToolbarView.init(menuElement);
            removeUnsupportedContent(menuElement);
            initInteractions();
            origViewClasses = menuElement.className;
            requestAnimationFrame(callback);
          }
        });
      }
      return {
        init: init,
        requestOpen: requestOpen,
        hasFocus: hasFocus
      };
    }(bp_toolbar_menu_bp_toolbar_features, bp_toolbar_menu_bp_toolbar_view, run_locale, run_conf_urls, run_util_xhr, run_constants, run_metric_metric, run_events, run_dom_events, mini_core_native_global);
    bp_img_placeholder_bp_img_placeholder = function(BP_CONST, helper, inlineStyle) {
      // Create <div> and put the existing badge inside it.
      // Transfer necessary styles from the <img> to the <div>
      function convertExistingBadge(badgeImg) {
        var newBadge = document.createElement("sc"), badgeImgBoundingBox = helper.getRect(badgeImg), badgeComputedStyles = window.getComputedStyle(badgeImg), stylesToTransfer = [ "marginTop", "marginBottom", "marginLeft", "marginRight", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight" ];
        // Transfer styles from placeholder <img> to <div>
        // Remove those styles from placeholder <img>
        function transferStylesFromExistingBadge(styles) {
          var len = styles.length, newBadgeStyles = {}, badgeImageStyles = {};
          for (var i = 0; i < len; i++) {
            newBadgeStyles[styles[i]] = helper.getNumberFromString(badgeComputedStyles[styles[i]]) + "px";
            badgeImageStyles[styles[i]] = 0;
          }
          inlineStyle.set(newBadge, newBadgeStyles);
          inlineStyle.set(badgeImg, badgeImageStyles);
        }
        // Added to fix issue on ruhglobal.com
        if ("relative" === inlineStyle(badgeImg).position) {
          stylesToTransfer.push("top");
          stylesToTransfer.push("left");
        }
        transferStylesFromExistingBadge(stylesToTransfer);
        // Set other styles that cannot be abstracted into a helper function.
        inlineStyle(newBadge).display = "inline-block";
        var newHeight = badgeImgBoundingBox.height, WIDTH_TO_HEIGHT_RATIO = 6.5, newBadgeStyle = {};
        newBadgeStyle.height = newHeight + "px";
        newBadgeStyle.width = newHeight * WIDTH_TO_HEIGHT_RATIO + "px";
        newBadgeStyle.float = badgeComputedStyles.float;
        inlineStyle.set(newBadge, newBadgeStyle);
        // Existing badge is hidden from screen readers, because the new <sc> parent will be the real badge
        badgeImg.setAttribute("aria-hidden", true);
        badgeImg.parentElement.insertBefore(newBadge, badgeImg);
        moveBadgeIdToParent(badgeImg, newBadge);
        badgeImg.parentElement.removeChild(badgeImg);
        return newBadge;
      }
      function moveBadgeIdToParent(badgeImg, newBadge) {
        newBadge.id = BP_CONST.BADGE_ID;
        // Invalidate the id in the cache because we just removed the BADGE_ID
        // from the <img> and set it on the <div>
        helper.invalidateId(BP_CONST.BADGE_ID);
      }
      function init(badgeImg) {
        // Will automatically use a different palette when dark theme is used
        badgeImg.setAttribute("data-sc-reversible", false);
        return convertExistingBadge(badgeImg);
      }
      return {
        init: init
      };
    }(run_bp_constants, run_bp_helper, run_inline_style_inline_style);
    page_reset_reset = function(zoomMod, pref) {
      function resetZoom() {
        zoomMod.resetZoom();
      }
      function resetAudio(callback) {
        !function(audio) {
          audio.init();
          audio.setSpeechState(false, true);
          audio.stopAudio();
          if (callback) {
            callback();
          }
        }(audio_audio);
      }
      function resetMinorSettings() {
        pref.reset();
      }
      function resetAll() {
        resetZoom();
        resetAudio(resetMinorSettings);
      }
      function init() {
        // Redefine (previously exported as noop function when Sitecues was off)
        sitecues.reset = resetAll;
      }
      return {
        resetZoom: resetZoom,
        resetAudio: resetAudio,
        resetMinorSettings: resetMinorSettings,
        resetAll: resetAll,
        init: init
      };
    }(page_zoom_zoom, run_conf_preferences);
    page_highlight_traitcache = function($, zoomMod) {
      var uniqueIdCounter = 0, styleCache = {}, rectCache = {}, cachedViewSize = {
        // If any of these view size metrics change, we must invalidate the cache
        height: null,
        width: null,
        zoom: null
      }, // Scrolling does not invalidate the cache
      cachedViewPosition = {
        x: 0,
        y: 0
      };
      // ------- PUBLIC ----------
      // Call this before using cache if view may have changed
      function resetCache() {
        updateCachedViewSize();
        updateCachedViewPosition();
        styleCache = {};
        rectCache = {};
      }
      function updateCachedViewPosition() {
        var pageXOffset = window.pageXOffset, pageYOffset = window.pageYOffset;
        if (cachedViewPosition.x !== pageXOffset || cachedViewPosition.y !== pageYOffset) {
          cachedViewPosition.x = pageXOffset;
          cachedViewPosition.y = pageYOffset;
          return true;
        }
      }
      function getCachedViewPosition() {
        return cachedViewPosition;
      }
      function getCachedViewSize() {
        return cachedViewSize;
      }
      // Can be used in the context of the highlighter, as the picker caches these values (expensive to get from browser)
      function getStyle(element) {
        var id = getUniqueId(element), style = styleCache[id];
        if (!style) {
          style = window.getComputedStyle(element);
          styleCache[id] = style;
        }
        return style;
      }
      // Convenience method to get one cached style trait
      function getStyleProp(element, propName) {
        var styleObj = getStyle(element);
        return styleObj[propName];
      }
      // Get rectangle in SCREEN coordinates
      function getScreenRect(element) {
        var rect = $.extend({}, getRect(element)), top = cachedViewPosition.y, left = cachedViewPosition.x;
        rect.top -= top;
        rect.bottom -= top;
        rect.left -= left;
        rect.right -= left;
        return rect;
      }
      // Get rectangle in DOCUMENT coordinates
      function getRect(element) {
        var id = getUniqueId(element), rect = rectCache[id];
        if (!rect) {
          // Copy rect object into our own object so we can modify values
          if (true && !element.getBoundingClientRect) {
            console.log("Error in traitcache#getRect");
            console.log(element);
            console.trace();
          }
          rect = $.extend({}, element.getBoundingClientRect());
          // Use the scroll height when the overflow is visible, as it shows the full height
          if ("visible" === getStyleProp(element, "overflowY") && !parseFloat(getStyleProp(element, "borderRightWidth"))) {
            var scrollHeight = element.scrollHeight;
            if (scrollHeight > 1 && scrollHeight > element.clientHeight) {
              rect.height = Math.max(rect.height, scrollHeight * cachedViewSize.zoom);
            }
          }
          // Use the scroll width when the overflow is visible, as it shows the full height
          if ("visible" === getStyleProp(element, "overflowX") && !parseFloat(getStyleProp(element, "borderBottomWidth"))) {
            rect.width = Math.max(rect.width, element.scrollWidth * cachedViewSize.zoom);
          }
          // Add scroll values so that rectangles are not invalid after user scrolls.
          // This effectively makes them absolutely positioned rects vs. fixed.
          // This means we're caching the rectangle relative to the top-left of the document.
          var scrollTop = cachedViewPosition.y, scrollLeft = cachedViewPosition.x;
          rect.top += scrollTop;
          rect.left += scrollLeft;
          rect.bottom = rect.top + rect.height;
          rect.right = rect.left + rect.width;
          // Store results in cache
          rectCache[id] = rect;
        }
        return rect;
      }
      // Hidden for any reason? Includes offscreen or dimensionless, or tiny (if doTreatTinyAsHidden == true)
      function isHidden(element, doTreatTinyAsHidden) {
        var rect = getRect(element), MIN_RECT_SIDE_TINY = 5, minRectSide = doTreatTinyAsHidden ? MIN_RECT_SIDE_TINY * getCachedViewSize().zoom : 1;
        return rect.right < 0 || rect.top < 0 || rect.width < minRectSide || rect.height < minRectSide;
      }
      function getUniqueId(element) {
        var currId = getStoredUniqueId(element);
        if (currId) {
          return currId;
        }
        $(element).data("sc", ++uniqueIdCounter);
        // Possibly a memory issue
        return uniqueIdCounter;
      }
      // ------- PRIVATE -----------
      function getStoredUniqueId(element) {
        return $(element).data("sc");
      }
      // Call before getting traits so that global/document values can be used
      function updateCachedViewSize() {
        cachedViewSize.height = window.innerHeight;
        cachedViewSize.width = window.innerWidth;
        cachedViewSize.zoom = zoomMod.getCompletedZoom();
      }
      return {
        resetCache: resetCache,
        updateCachedViewPosition: updateCachedViewPosition,
        getCachedViewPosition: getCachedViewPosition,
        getCachedViewSize: getCachedViewSize,
        getStyle: getStyle,
        getStyleProp: getStyleProp,
        getScreenRect: getScreenRect,
        getRect: getRect,
        isHidden: isHidden,
        getUniqueId: getUniqueId
      };
    }($, page_zoom_zoom);
    page_highlight_highlight_position = function($, common, elemClassifier, zoomMod, traitcache, nativeGlobal, inlineStyle) {
      var MIN_RECT_SIDE = 4, MAX_TEXT_INDENT_USED_TO_HIDE = -499;
      // text-indent less than this we consider as something used to hide alternative text for bg image sprites
      /**
   * Get the fixed position rectangles for the target's actual rendered content.
   * This is necessary when an inline element such as a link wraps at the end of a line -- there are multiple rects
   * DOM function object.getClientRects() returns rectangle objects for each rectangle associated with an object.
   * It also helps get just what's visible, as opposed to a parent element's rectangle which could bleed
   * over neighboring floats.
   * Recursive so that we don't miss any bounds (sometimes children escape the bounds of their parents).
   * For example, child images escape the bounds of inline parents and
   * relatively positioned children can be outside of the parent that way.
   * When adjacent rectangles are within |proximityBeforeRectsMerged| pixels,
   * they will be combined into a single rectangle.
   * @param selector -- what to get bounding boxes
   * @param proximityBeforeBoxesMerged -- if two boxes are less than this number of pixels apart, they will be merged into one
   * @param doStretchForSprites -- true if it's important to add rects for background sprites
   * @return {
   *   allRects: [],  // Array of rectangles
   *   hiddenElements: []   // Elements whose contents are not included in the highlight, e.g. have absolutely positioned or hidden subtrees
   * }
   */
      function getHighlightPositionInfo(selector, proximityBeforeBoxesMerged, doStretchForSprites, doIgnoreFloats) {
        var accumulatedPositionInfo = {
          allRects: [],
          hiddenElements: new WeakMap()
        }, $selector = $(selector);
        getHighlightInfoRecursive($selector, accumulatedPositionInfo, doStretchForSprites, doIgnoreFloats, true);
        combineIntersectingRects(accumulatedPositionInfo.allRects, proximityBeforeBoxesMerged);
        // Merge overlapping boxes
        return accumulatedPositionInfo;
      }
      // Get a single rectangle that covers the entire area defined by the selector
      // doIgnoreFloats is optional
      function getRect(selector, doIgnoreFloats) {
        var COMBINE_ALL_RECTS = 99999;
        return getHighlightPositionInfo(selector, COMBINE_ALL_RECTS, true, doIgnoreFloats).allRects[0];
      }
      function getZoom() {
        return zoomMod.getCompletedZoom();
      }
      function hasUnrenderedDescendants(node) {
        // Select elements have `option` descendants that don't have rendered dimensions until the dropdown menu is opened
        var tagNames = [ "select" ];
        return tagNames.indexOf(node.localName) !== -1;
      }
      // Get the rect for the contents of a node (text node or contents inside element node)
      // @param node -- an element that contains visible content, or a text node
      function getContentsRangeRect(node) {
        var parent, range = document.createRange(), // ********** Some browsers are fine **********
        isElement = node.nodeType === Node.ELEMENT_NODE;
        if (isElement && !hasUnrenderedDescendants(node)) {
          // Case 1: element -- get the rect for the element's descendant contents
          parent = node;
          range.selectNodeContents(node);
        } else {
          // Case 2: text node -- get the rect for the text
          parent = node.parentNode;
          range.selectNode(node);
        }
        var contentsRangeRect = $.extend({}, range.getBoundingClientRect());
        if (!contentsRangeRect.width || !contentsRangeRect.height) {
          return;
        }
        if (!isElement) {
          var textVerticalClipRect = getTextVerticalClipping(node, contentsRangeRect, range);
          if (textVerticalClipRect) {
            // Clip text to the bounding element, otherwise the top and bottom will
            // encompass the entire line-height, which can contain a lot of whitespace/
            // We only use this technique to clip the top and bottom -- left and right do not need this treatment.
            contentsRangeRect.top = Math.max(contentsRangeRect.top, textVerticalClipRect.top);
            contentsRangeRect.bottom = Math.min(contentsRangeRect.bottom, textVerticalClipRect.bottom);
            contentsRangeRect.height = contentsRangeRect.bottom - contentsRangeRect.top;
          }
        }
        return contentsRangeRect;
      }
      function getRectMinusPadding(rect, style) {
        // Reduce by padding amount -- useful for images such as Google Logo
        // which have a ginormous amount of padding on one side
        var paddingTop = parseFloat(style.paddingTop), paddingLeft = parseFloat(style.paddingLeft), paddingBottom = parseFloat(style.paddingBottom), paddingRight = parseFloat(style.paddingRight);
        return {
          top: rect.top + paddingTop,
          left: rect.left + paddingLeft,
          width: rect.width - paddingLeft - paddingRight,
          height: rect.height - paddingTop - paddingBottom,
          bottom: rect.top + rect.height - paddingBottom,
          // In case rect.right not set
          right: rect.left + rect.width - paddingRight
        };
      }
      function hasHiddenBullets(style) {
        return "none" === style.listStyleType && "none" === style.listStyleImage;
      }
      function getBulletRect(element, style) {
        if ("list-item" !== style.display || hasHiddenBullets(style)) {
          // Do not perform the measurement on anything but a list item with visible bullets
          return;
        }
        var INSIDE_BULLET_PADDING = 5, // Add this extra space to the left of bullets if list-style-position: inside, otherwise looks crammed
        bulletWidth = "inside" === style.listStylePosition ? INSIDE_BULLET_PADDING : common.getBulletWidth(element.parentNode, style), boundingRect = traitcache.getScreenRect(element), paddingLeft = parseFloat(traitcache.getStyleProp(element, "paddingLeft"));
        return {
          top: boundingRect.top,
          height: boundingRect.height,
          left: boundingRect.left + paddingLeft - bulletWidth,
          width: bulletWidth
        };
      }
      function isTextIndentUsedToHide(style) {
        return parseInt(style.textIndent) < MAX_TEXT_INDENT_USED_TO_HIDE;
      }
      function getSpriteRect(element, style) {
        // Check special case for sprites, often used for fake bullets
        // The following cases are unlikely to be sprites:
        // - Repeating backgrounds
        // - Percentage-positioned or centered (computed background-position-x is 50%)
        // Check for elements with only a background-image
        var rect = $.extend({}, traitcache.getScreenRect(element, true));
        if ($(element).is(":empty") || isTextIndentUsedToHide(style)) {
          // Empty elements have no other purpose than to show background sprites
          // Also, background image elements with text-indent are used to make accessible images
          // (the text is offscreen -- screen readers see it but the eye doesn't)
          return rect;
        }
        var backgroundPos = style.backgroundPosition;
        if ("none" === style.backgroundImage || "no-repeat" !== style.backgroundRepeat || parseFloat(backgroundPos) > 0 && backgroundPos.indexOf("%") > 0) {
          return;
        }
        // Background sprites tend to be to the left side of the element
        var backgroundLeftPos = backgroundPos ? parseFloat(backgroundPos) : 0, // Use positive background positions (used for moving the sprite to the right within the element)
        // Ignore negative background positions (used for changing which sprite is used within a larger image)
        actualLeft = isNaN(backgroundLeftPos) || backgroundLeftPos < 0 ? 0 : backgroundLeftPos, currZoom = getZoom();
        rect.left += actualLeft;
        rect.width = parseFloat(style.paddingLeft) * currZoom;
        return rect.width > MIN_RECT_SIDE * currZoom ? rect : null;
      }
      function getLineHeight(style) {
        // Values possible from computed style: normal | <number>px
        return parseFloat(style.lineHeight) || 1.5 * parseFloat(style.fontSize);
      }
      function getOverflowRect(element, style) {
        if ("body" === element.localName) {
          return;
        }
        var clientHeight = element.clientHeight;
        if (!clientHeight) {
          return;
        }
        var hasOverflowX = "visible" === style.overflowX && element.scrollWidth - element.clientWidth > 1, hasOverflowY = "visible" === style.overflowY && element.scrollHeight - clientHeight >= getLineHeight(style);
        if (!hasOverflowX && !hasOverflowY) {
          return;
        }
        // Check hidden or out-of-flow descendants -- those break our overflow check.
        // Example: google search results with hidden drop down menu
        // For now, we will not support overflow in this case.
        var hasHiddenDescendant = false, MAX_ELEMENTS_TO_CHECK = 40;
        $(element).find("*").each(function(index) {
          if (index > MAX_ELEMENTS_TO_CHECK) {
            return false;
          }
          var rect = traitcache.getRect(this), style = traitcache.getStyle(this);
          if (rect.right < 0 || rect.bottom < 0 || "hidden" === style.visibility || "absolute" === style.position || "fixed" === style.position) {
            hasHiddenDescendant = true;
            return false;
          }
        });
        if (hasHiddenDescendant) {
          return;
        }
        // Overflow is visible: add right and bottom sides of overflowing content
        var rect = traitcache.getScreenRect(element), zoom = getZoom(), newRect = {
          left: rect.left,
          top: rect.top,
          width: hasOverflowX ? element.scrollWidth * zoom : Math.min(rect.width, MIN_RECT_SIDE),
          height: hasOverflowY ? element.scrollHeight * zoom : Math.min(rect.height, MIN_RECT_SIDE)
        };
        return getRectMinusPadding(newRect, style);
      }
      function normalizeRect(rect) {
        var newRect = $.extend({}, rect);
        newRect.right = rect.left + rect.width;
        newRect.bottom = rect.top + rect.height;
        return newRect;
      }
      // Add rectangle to collected list of all rectangles
      function addRect(allRects, rect, doLoosenMinSizeRule) {
        if (!rect) {
          return;
        }
        var zoom = getZoom(), minRectSide = MIN_RECT_SIDE * zoom;
        if (!doLoosenMinSizeRule && (rect.width < minRectSide || rect.height < minRectSide)) {
          return;
        }
        rect = normalizeRect(rect);
        allRects.push(rect);
      }
      function isInvisible(style) {
        return "hidden" === style.visibility || "collapse" === style.visibility || "none" === style.display;
      }
      function isOutOfFlow(elem, style, rect) {
        if ("absolute" === style.position || "fixed" === style.position) {
          var parentRect = traitcache.getScreenRect(elem.parentNode), FUZZ_FACTOR = 4;
          // If the child bounds pop out of the parent bounds by more
          // than FUZZ_FACTOR, it will need to be kept separate and
          // not included in the current bounds calculation for this subtree
          if (Math.abs(rect.left - parentRect.left) > FUZZ_FACTOR || Math.abs(rect.top - parentRect.top) > FUZZ_FACTOR || Math.abs(rect.right - parentRect.right) > FUZZ_FACTOR || Math.abs(rect.bottom - parentRect.bottom) > FUZZ_FACTOR) {
            return true;
          }
        }
      }
      function getHighlightInfoRecursive($selector, accumulatedResults, doStretchForSprites, doIgnoreFloats, isTop) {
        var allRects = accumulatedResults.allRects, hiddenElements = accumulatedResults.hiddenElements, viewPos = traitcache.getCachedViewPosition();
        $selector.each(function() {
          var isElement = this.nodeType === Node.ELEMENT_NODE;
          // --- Leaf nodes ---
          if (!isElement) {
            if (this.nodeType === Node.TEXT_NODE && "" !== this.data.trim()) {
              /* Non-empty text node */
              // ----------------------------------------------------------------------------------------------------
              // --- FAST PATH -- REMOVED BECAUSE SOME CHILD ELEMENTS MAY USING CLIPPING! SC-2047 --
              // Fast path for text containers:
              // We found a child text node, so get the bounds of all children at once via a DOM range.
              // This is much faster than iterating through all of the sibling text/inline nodes, by
              // reducing the number of nodes we touch.
              // Note: this would not work if any of the children were display: block, because
              // the returned rectangle would be the larger element rect, rather for just the visible content.
              //
              // var parentContentsRect = getContentsRangeRect(this.parentNode);
              // addRect(allRects, parentContentsRect);
              // return false;  // Don't keep iterating over text/inlines in this container
              // ----------------------------------------------------------------------------------------------------
              // ----------------------------------------------------------------------------------------------------
              // -- NORMAL -- NO LONGER NEED TO USE ABOVE 'FAST PATH' METHOD --
              // Our other performance fixes (such as traitcache, and better picking) have removed the need
              // for the above old 'fast path' method which fixed slow sites like http://en.wikipedia.org/wiki/Cat
              // This 'normal' method goes through the nodes one at a time, so that we can be sure to deal with
              // hidden and clipped elements.
              // ----------------------------------------------------------------------------------------------------
              var rect = getContentsRangeRect(this);
              addRect(allRects, rect);
              // --- Overflowing content ---
              addRect(allRects, getOverflowRect(this.parentNode, traitcache.getStyle(this.parentNode)));
            }
            return;
          }
          var style = traitcache.getStyle(this);
          // --- Invisible elements ---
          if (isInvisible(style)) {
            hiddenElements.set(this, true);
            return;
          }
          if (doIgnoreFloats && "none" !== style.float) {
            return;
          }
          var thisRect = traitcache.getScreenRect(this);
          if (thisRect.right < -viewPos.x || thisRect.bottom < -viewPos.y) {
            // Hidden off the page
            // This is a technique used to hide contents offscreen without hiding it from screen readers
            hiddenElements.set(this, true);
            return;
          }
          // -- Out of flow and is not the top element --
          if (!isTop && isOutOfFlow(this, style, thisRect)) {
            hiddenElements.set(this, true);
            return;
          }
          // --- Media elements ---
          if (elemClassifier.isVisualMedia(this)) {
            // Elements with rendered content such as images and videos
            addRect(allRects, getRectMinusPadding(thisRect, style));
            return;
          }
          // --- Form controls ---
          if (elemClassifier.isFormControl(this)) {
            if ($(this).is('select[size="1"],select:not([size])')) {
              addRect(allRects, getComboboxRect(this, thisRect));
              return;
            }
            addRect(allRects, thisRect);
          } else {
            if (common.isVisualRegion(this, style, traitcache.getStyle(this.parentNode))) {
              addRect(allRects, thisRect);
            }
          }
          // --- List bullets ---
          addRect(allRects, getBulletRect(this, style), true);
          // --- Background sprites ---
          if (doStretchForSprites) {
            addRect(allRects, getSpriteRect(this, style));
          }
          // --- Elements with children ---
          // Ignore children when text-indent is negative, as this indicates hidden offscreen content,
          // most commonly a background image sprite with a text child being used as alternative text.
          if (this.hasChildNodes() && !isTextIndentUsedToHide(style)) {
            // Use bounds of visible descendants
            getHighlightInfoRecursive($(this.childNodes), accumulatedResults, doStretchForSprites, doIgnoreFloats);
            // Recursion
            return;
          }
        });
      }
      // A text range is clipped by the vertical bounds of it's parent element
      // when the line height of the text is larger than the text rect's height --
      // this avoids extra spacing above and below, especially around headings.
      // Return either nothing for no clip, or an object with a top: and bottom: to clip to
      function getTextVerticalClipping(textNode, textRect, range) {
        var clipInfo, parent = textNode.parentNode, zoom = getZoom(), lineHeight = parseFloat(traitcache.getStyleProp(parent, "lineHeight")) * zoom, numLines = range.getClientRects().length, // TODO Can we clip always? Unfortunately we did not document the counter-case. Maybe we can always do it.
        shouldClip = lineHeight * (numLines + .7) > textRect.height;
        if (shouldClip) {
          // Clip the text vertically to the parent element, because the large
          // line-height causes the element bounds to be larger than the text
          clipInfo = traitcache.getScreenRect(parent);
          while ("inline" === traitcache.getStyleProp(parent, "display")) {
            parent = parent.parentNode;
            if (parent) {
              var parentRect = parent.getBoundingClientRect();
              if (parentRect.top > clipInfo.top) {
                clipInfo.top = parentRect.top;
              }
              if (parentRect.bottom < clipInfo.bottom) {
                clipInfo.bottom = parentRect.bottom;
              }
            }
          }
          return clipInfo;
        }
      }
      // Our hacky zoom combobox fixes can mess up highlight rects -- this corrects for that case
      function getComboboxRect(comboElem, comboRect) {
        var isHackedCombobox = traitcache.getStyleProp(comboElem, "zoom") > 1;
        if (isHackedCombobox) {
          // Turn off zoom CSS hacks for comboboxes
          comboElem.setAttribute("data-sc-dropdown-fix-off", "");
          // Turn off transition temporarily if it's there, otherwise it prevents us from getting the correct rect
          inlineStyle.override(comboElem, {
            transitionProperty: "none"
          });
          // Get what the rect would have been
          comboRect = comboElem.getBoundingClientRect();
          // Restore CSS
          nativeGlobal.setTimeout(function() {
            // Do this on a timeout otherwise it may animate our return changes
            inlineStyle.restore(comboElem, "transition-property");
          }, 0);
          comboElem.removeAttribute("data-sc-dropdown-fix");
        }
        return comboRect;
      }
      /**
   * Combine intersecting rects. If they are within |extraSpace| pixels of each other, merge them.
   */
      function combineIntersectingRects(rects, extraSpace) {
        function intersects(r1, r2) {
          return !(r2.left - extraSpace > r1.left + r1.width + extraSpace || r2.left + r2.width + extraSpace < r1.left - extraSpace || r2.top - extraSpace > r1.top + r1.height + extraSpace || r2.top + r2.height + extraSpace < r1.top - extraSpace);
        }
        function merge(r1, r2) {
          var left = Math.min(r1.left, r2.left);
          var top = Math.min(r1.top, r2.top);
          var right = Math.max(r1.left + r1.width, r2.left + r2.width);
          var bottom = Math.max(r1.top + r1.height, r2.top + r2.height);
          return {
            left: left,
            top: top,
            width: right - left,
            height: bottom - top,
            right: right,
            bottom: bottom
          };
        }
        // TODO O(n^2), not ideal.
        // Probably want to use well-known algorithm for merging adjacent rects
        // into a polygon, such as:
        // http://stackoverflow.com/questions/643995/algorithm-to-merge-adjacent-rectangles-into-polygon
        // http://www.raymondhill.net/puzzle-rhill/jigsawpuzzle-rhill-3.js
        // http://stackoverflow.com/questions/13746284/merging-multiple-adjacent-rectangles-into-one-polygon
        for (var index1 = 0; index1 < rects.length - 1; index1++) {
          var index2 = index1 + 1;
          while (index2 < rects.length) {
            if (intersects(rects[index1], rects[index2])) {
              rects[index1] = merge(rects[index1], rects[index2]);
              rects.splice(index2, 1);
            } else {
              index2++;
            }
          }
        }
      }
      return {
        getHighlightPositionInfo: getHighlightPositionInfo,
        getRect: getRect,
        getContentsRangeRect: getContentsRangeRect,
        combineIntersectingRects: combineIntersectingRects
      };
    }($, page_util_common, page_util_element_classifier, page_zoom_zoom, page_highlight_traitcache, mini_core_native_global, run_inline_style_inline_style);
    page_highlight_traits = function($, traitcache, mhpos, bodyGeo, elemClassifier) {
      var bodyWidth, viewSize;
      // ---- PUBLIC ----
      function getTraitStack(nodes) {
        var traitStack;
        viewSize = traitcache.getCachedViewSize();
        bodyWidth = bodyGeo.getBodyWidth();
        traitStack = nodes.map(getTraits);
        return traitStack;
      }
      // ---- PRIVATE ----
      // Properties that depend only on the node itself, and not other traits in the stack
      function getTraits(node) {
        // Basic properties
        var zoom = viewSize.zoom, traits = {
          computedStyle: traitcache.getStyle(node),
          tag: node.localName,
          role: node.getAttribute("role"),
          childCount: node.childElementCount
        };
        traits.isVisualMedia = isVisualMedia(traits, node);
        var fastRect = traitcache.getRect(node);
        traits.normDisplay = getNormalizedDisplay(traits.computedStyle, node, fastRect.height, zoom, traits);
        traits.rect = getRect(node, traits, fastRect);
        traits.fullWidth = fastRect.width;
        // Full element width, even if visible text content is much less
        traits.unzoomedRect = {
          width: traits.rect.width / zoom,
          height: traits.rect.height / zoom,
          top: traits.rect.top / zoom,
          bottom: traits.rect.bottom / zoom,
          left: traits.rect.left / zoom,
          right: traits.rect.right / zoom
        };
        // Style-based
        $.extend(traits, {
          topPadding: parseFloat(traits.computedStyle.paddingTop),
          bottomPadding: parseFloat(traits.computedStyle.paddingBottom),
          leftPadding: parseFloat(traits.computedStyle.paddingLeft),
          rightPadding: parseFloat(traits.computedStyle.paddingRight),
          topBorder: parseFloat(traits.computedStyle.borderTopWidth),
          bottomBorder: parseFloat(traits.computedStyle.borderBottomWidth),
          leftBorder: parseFloat(traits.computedStyle.borderLeftWidth),
          rightBorder: parseFloat(traits.computedStyle.borderRightWidth),
          topMargin: Math.max(0, parseFloat(traits.computedStyle.marginTop)),
          bottomMargin: Math.max(0, parseFloat(traits.computedStyle.marginBottom)),
          leftMargin: Math.max(0, parseFloat(traits.computedStyle.marginLeft)),
          rightMargin: Math.max(0, parseFloat(traits.computedStyle.marginRight))
        });
        // Visible size at 1x (what it would be if not zoomed)
        $.extend(traits, {
          visualWidthAt1x: traits.unzoomedRect.width - traits.leftPadding - traits.rightPadding,
          visualHeightAt1x: traits.unzoomedRect.height - traits.topPadding - traits.bottomPadding
        });
        // Percentage of viewport
        $.extend(traits, {
          percentOfViewportHeight: 100 * traits.rect.height / viewSize.height,
          percentOfViewportWidth: 100 * traits.rect.width / viewSize.width
        });
        traits.percentOfBodyWidth = 100 * traits.rect.width / bodyWidth;
        return traits;
      }
      // Normalize treatment of CSS display for form controls across browsers.
      // Firefox says that form controls have an inline style, but really treats them as inline-block.
      // For example the label of an <input type="button"> will not wrap to the next line like a normal inline does.
      // Since they act like inline-block let's treat it as one while normalize the display trait across browsers --
      // this allows the form controls to be picked.
      function getNormalizedDisplay(style, node, height, zoom, traits) {
        function getApproximateLineHeight() {
          // See http://meyerweb.com/eric/thoughts/2008/05/06/line-height-abnormal/
          return 1.5 * (parseFloat(style.lineHeight) || parseFloat(style.fontSize));
        }
        var doTreatAsInlineBlock = false;
        if ("inline" === style.display) {
          // Treat forms as inline-block across browsers (and thus are pickable).
          // If we don't do this, some browsers call them "inline" and they would not get picked
          if (elemClassifier.isFormControl(node)) {
            doTreatAsInlineBlock = true;
          } else {
            if (1 === traits.childCount && elemClassifier.isVisualMedia(node.firstElementChild)) {
              doTreatAsInlineBlock = true;
            } else {
              var lineHeight = getApproximateLineHeight() * zoom;
              if (height < lineHeight) {
                var parentRect = mhpos.getContentsRangeRect(node.parentNode);
                if (parentRect && parentRect.height < lineHeight) {
                  // Treat single line inlines that are part of another single-line element as inline-block.
                  // This allows them to be picked -- they may be a row of buttons or part of a menubar.
                  doTreatAsInlineBlock = true;
                }
              }
            }
          }
        }
        return doTreatAsInlineBlock ? "inline-block" : style.display;
      }
      // Get an element's rectangle
      // In most cases, we use the fastest approach (cached getBoundingClientRect results)
      // However, a block parent of an inline or visible text needs the more exact approach, so that the element
      // does not appear to be much wider than it really is
      function getRect(element, traits, fastRect) {
        var exactRect, display = traits.normDisplay, WIDE_ELEMENT_TO_BODY_RATIO = .7;
        // Use exact approach for:
        // * inline-block, because it lies about height when media is inside
        // * wide blocks, because they lie about width when there is a float
        if ("inline-block" === display || "block" === display && fastRect.width > bodyWidth * WIDE_ELEMENT_TO_BODY_RATIO) {
          exactRect = mhpos.getContentsRangeRect(element);
          return $.extend({}, exactRect);
        }
        return fastRect;
      }
      function isVisualMedia(traits, node) {
        var style = traits.computedStyle;
        return elemClassifier.isVisualMedia(node) || 0 === traits.childCount && "none" !== style.backgroundImage && ("no-repeat" === style.backgroundRepeat || "cover" === style.backgroundSize || "contain" === style.backgroundSize) && $(node).is(":empty");
      }
      return {
        getTraitStack: getTraitStack
      };
    }($, page_highlight_traitcache, page_highlight_highlight_position, page_zoom_util_body_geometry, page_util_element_classifier);
    page_highlight_judge = function($, common, elemClassifier, traitcache) {
      // ** Semantic constants ***
      // For ARIA roles other tags could be used, but this is most likely and more performant than checking all possibilities
      var DIVIDER_SELECTOR = 'hr,div[role="separator"],img', SECTION_START_SELECTOR = 'h1,h2,h3,h4,h5,h6,hgroup,header,dt,div[role="heading"],hr,div[role="separator"]', GREAT_TAGS = {
        blockquote: 1,
        td: 1,
        ol: 1,
        menu: 1
      }, GOOD_TAGS = {
        a: 1,
        address: 1,
        button: 1,
        code: 1,
        dl: 1,
        fieldset: 1,
        form: 1,
        p: 1,
        pre: 1,
        li: 1,
        section: 1,
        tr: 1
      }, BAD_PARENTS_SELECTOR = "li,p,h1,h2,h3,h4,h5,h6,hgroup,button", HEADING_TAGS = {
        h1: 1,
        h2: 1,
        h3: 1,
        h4: 1,
        h5: 1,
        h6: 1,
        hgroup: 1
      }, // Because we prefer to select content with the heading
      // These are less likely to be used to layout a cell/box
      UNLIKELY_CELL_TAGS = {
        a: 1,
        ol: 1,
        ul: 1,
        p: 1,
        h1: 1,
        h2: 1,
        h3: 1,
        h4: 1,
        h5: 1,
        h6: 1,
        hgroup: 1,
        header: 1
      }, GOOD_ROLES = {
        list: 1,
        region: 1,
        complementary: 1,
        dialog: 1,
        alert: 1,
        alertdialog: 1,
        gridcell: 1,
        tabpanel: 1,
        tree: 1,
        treegrid: 1,
        listbox: 1,
        img: 1,
        heading: 1,
        rowgroup: 1,
        row: 1,
        toolbar: 1,
        menu: 1,
        menubar: 1,
        group: 1,
        form: 1,
        navigation: 1,
        main: 1
      }, MIN_BR_TAGS_IN_TALL_ARTICLE = 5, UNUSABLE_TAGS = {
        area: 1,
        base: 1,
        basefont: 1,
        bdo: 1,
        br: 1,
        col: 1,
        colgroup: 1,
        font: 1,
        legend: 1,
        link: 1,
        map: 1,
        optgroup: 1,
        option: 1,
        tbody: 1,
        tfoot: 1,
        thead: 1,
        hr: 1
      }, UNUSABLE_ROLES = {
        presentation: 1,
        separator: 1
      }, // ** Layout and geometrical constants ***
      MIN_COLUMN_CELL_HEIGHT = 25, // If fewer pixels than this, don't consider it to be a cell in a column
      MIN_AVERAGE_COLUMN_CELL_HEIGHT = 65, // If fewer pixels than this per item, don't consider it to be a cell in a column
      IDEAL_MIN_PERCENT_OF_VIEWPORT_HEIGHT = 20, // Smaller than this is bad
      IDEAL_MAX_PERCENT_OF_VIEWPORT_HEIGHT = 63, // Larger than this is bad
      IDEAL_MIN_PERCENT_OF_VIEWPORT_WIDTH = 20, // Smaller than this is bad
      IDEAL_MAX_PERCENT_OF_VIEWPORT_WIDTH = 63, // Larger than this is bad
      MEDIA_MAX_PERCENT_OF_VIEWPORT_WIDTH = 60, // Media larger than this is bad
      IDEAL_MAX_PERCENT_OF_BODY_WIDTH = 85, // If this percent or more of body width, it's bad. We don't like picking items almost as wide as body.
      NEAR_BODY_WIDTH_IMPACT_POWER = 2, // Exponent for impact of being close to body's width
      TALL_ELEMENT_PIXEL_THRESHOLD = 999, // Anything taller than this is considered very tall
      TINY_HEIGHT_PIXEL_THRESHOLD = 14, // Anything shorter than this is considered a tiny element (or at least very thin)
      TINY_WIDTH_PIXEL_THRESHOLD = 33, // Anything narrower than this is considered a tiny element (or at least very thin)
      TINY_ELEMENT_IMPACT_POWER = 1.2, // Exponential for the affect of smallness
      SIGNIFICANT_IMAGE_PIXELS = 20, // Number of pixels on a side before an image is significant
      SEPARATOR_IMAGE_PIXEL_THRESHOLD = 6, // Maximum thickness for a separator line
      SEPARATION_DIVISOR = 1.6, // The number of spacing pixels will be divided by this in separation impact algorithm
      SEPARATION_IMPACT_POWER = 1.3, // Exponent for visual impact of whitespace
      MAX_SPACE_SEPARATION_IMPACT = 14, // The maximum impact of whitespace, for a given edge
      MAX_BORDER_SEPARATION_IMPACT = 22, // The maximum impact of a border, for a given edge
      TABLE_CELL_SPACING_BONUS = 7, // Treat table cells as having 5 extra spaces around them
      BORDER_WIDTH_BONUS = 15, // Bonus points for each pixel of border width
      SIGNIFICANT_EDGE_PIXEL_GROWTH = 50, // Number of pixels of growth on a side that likely means additional content is encompassed on that side
      SIGNIFICANT_SEPARATION_IMPACT = 14, // Amount of separation impact on a side that clearly shows a visual separation
      EXTREME_GROWTH_FACTOR = 2.5, // If parent's height ratio of child is larger than this, we consider it significantly larger than child
      MODERATE_GROWTH_FACTOR = 1.3, // An amount of growth that is significant but not huge
      COLUMN_VERT_GROWTH_THRESHOLD = 1.3, // Sometimes there is a very small cell in a column of only 2 cells. We only require that the column be 30% taller than the cell
      ROW_HORIZ_GROWTH_THRESHOLD = 1.8, // Because text is horizontal, it is unlikely to have a narrow cell in a row. Generally the row width will be nearly 2x the cell width.
      MAX_CELL_GROUP_GROWTH_PER_SIBLING = 2, // For each sibling, allow the cell group's area to be this much larger than the cell
      VERY_SMALL_GROWTH_FACTOR = 1.04, SMALL_GROWTH_FACTOR = 1.2, MIN_IMAGE_GROUP_HEIGHT = 50, // Image groups must be taller than this
      MAX_CHILDREN_IMAGE_GROUP = 4, // If more children than this, it does not typically fit the pattern of an image group, so don't do the expensive check
      MAX_ANCESTOR_INDEX_IMAGE_GROUP = 5, // If ancestor index is larger than this, it does not typically fit the pattern of an image group, so don't do the expensive check
      ROUGHLY_SAME_SIZE_THRESHOLD = 120, // If parent grows by fewer pixels than this, it is considered roughly the same size as the child
      LINK_LIST_FACTOR = 1.5, // How much to multiply list score by if it's a list of links
      OUT_OF_FLOW_LIST_FACTOR = 6, // How much to multiply list score by if it's a positioned list (a menu)
      customJudgements = {};
      // ----------- PUBLIC  ----------------
      // Get a judgement for each node
      // The judgements, traits and nodes all correlate, such that index 0 of each array
      // stores information for the first candidate node, index 1 is the parent, etc.
      // When the node is unusable, judgements is set to null, rather than wasting cycles calculating the judgements.
      function getJudgementStack(traitStack, nodeStack) {
        var firstNonInlineTraits = getTraitsOfFirstNonInlineCandidate(traitStack), childJudgements = null, childTraits = traitStack[0], // For simplicity of calculations, not allowed to be null
        // Get cascaded spacing traits and add them to traitStack
        spacingInfoStack = getCascadedSpacingInfo(traitStack, nodeStack);
        // topSpacing, leftSpacing, topDivider, etc.
        // Return the judgements for the candidate at the given index
        // Return null if the candidate is unusable
        function mapJudgements(traits, index) {
          var node = nodeStack[index], judgements = getJudgements(traitStack, childTraits, firstNonInlineTraits, node, spacingInfoStack, childJudgements, index);
          childJudgements = judgements;
          childTraits = traits;
          return judgements;
        }
        return traitStack.map(mapJudgements);
      }
      // This is a hook for customization scripts, which can add their own judgements by overriding this method.
      // Pass in as { judgementName: fn(), judgementName2: fn2(), etc. }
      // Parameters to judgement functions are:
      //   judgements, traits, belowTraits, belowJudgements, parentTraits, firstNonInlineTraits, node, index
      // For each judgement, a weight of the same name must exist.
      function provideCustomJudgements(judgements) {
        customJudgements = judgements;
      }
      // ------------ PRIVATE -------------
      function getJudgements(traitStack, childTraits, firstNonInlineTraits, node, spacingStack, childJudgements, index) {
        var judgementGetter, traits = traitStack[index], numCandidates = traitStack.length, parentTraits = index < numCandidates - 1 ? traitStack[index + 1] : traits, firstTraits = traitStack[0], judgements = spacingStack[index];
        // Begin with cascaded spacing info
        // Computed judgements
        $.extend(judgements, getVisualSeparationJudgements(node, traits, parentTraits, childTraits, judgements, childJudgements));
        $.extend(judgements, getSizeJudgements(node, judgements, traits, firstNonInlineTraits, childJudgements));
        $.extend(judgements, getGrowthJudgements(traits, childTraits, parentTraits, firstNonInlineTraits, firstTraits, childJudgements));
        $.extend(judgements, getCellLayoutJudgements(node, judgements, traits, parentTraits, childJudgements, firstNonInlineTraits));
        $.extend(judgements, getDOMStructureJudgements(judgements, traits, childJudgements, childTraits, node, index));
        for (judgementGetter in customJudgements) {
          if (customJudgements.hasOwnProperty(judgementGetter)) {
            $.extend(judgements, judgementGetter(judgements, traits, childTraits, childJudgements, parentTraits, firstNonInlineTraits, node, index));
          }
        }
        judgements.isUsable = isUsable(traits, judgements);
        return judgements;
      }
      // Which edges of node are adjacent to parent's edge? E.g. top, left, bottom, right
      // Returns an array of edges, e.g. ["top", "left"]
      function getAdjacentEdges(traitStack, index) {
        var traits = traitStack[index], parentTraits = traitStack[index + 1], rect = traits.unzoomedRect, parentRect = parentTraits.unzoomedRect, adjacentEdges = [], FUZZ_FACTOR = 1;
        // If we're close by this many pixels, consider them adjacent
        if (parentRect.top + parentTraits.topPadding + FUZZ_FACTOR >= rect.top - traits.topMargin) {
          adjacentEdges.push("top");
        }
        if (parentRect.left + parentTraits.leftPadding + FUZZ_FACTOR >= rect.left - traits.leftMargin) {
          adjacentEdges.push("left");
        }
        if (parentRect.bottom - parentTraits.bottomPadding - FUZZ_FACTOR <= rect.bottom + traits.bottomMargin) {
          adjacentEdges.push("bottom");
        }
        if (parentRect.right - parentTraits.rightPadding - FUZZ_FACTOR <= rect.right + traits.rightMargin) {
          adjacentEdges.push("right");
        }
        return adjacentEdges;
      }
      // Get the true amount of spacing around each object.
      // For the top, left, bottom and rightmost objects in each container,
      // the parent container's margin/padding for that edge should be added to it
      // because we want the complete amount of visual spacing on that edge.
      function getCascadedSpacingInfo(traitStack, nodeStack) {
        // Create the spacing properties
        function getSpacingTraits(item, index) {
          var node = nodeStack[index], parent = node.parentNode, itemRect = traitcache.getRect(node), cellBonus = ("td" === traitStack[index].tag) * TABLE_CELL_SPACING_BONUS;
          return {
            topSpacing: item.topMargin + item.topPadding + cellBonus,
            leftSpacing: item.leftMargin + item.leftPadding + cellBonus,
            bottomSpacing: item.bottomMargin + item.bottomPadding + cellBonus,
            rightSpacing: item.rightMargin + item.rightPadding + cellBonus,
            topDivider: getDividerThickness(parent.firstElementChild, "top", itemRect.top - SIGNIFICANT_EDGE_PIXEL_GROWTH, itemRect.top),
            leftDivider: getDividerThickness(parent.firstElementChild, "left", itemRect.left - SIGNIFICANT_EDGE_PIXEL_GROWTH, itemRect.left),
            bottomDivider: getDividerThickness(parent.lastElementChild, "bottom", itemRect.bottom, itemRect.bottom + SIGNIFICANT_EDGE_PIXEL_GROWTH),
            rightDivider: getDividerThickness(parent.lastElementChild, "right", itemRect.right, itemRect.right + SIGNIFICANT_EDGE_PIXEL_GROWTH)
          };
        }
        var index, spacingTraitStack = traitStack.map(getSpacingTraits);
        function combineProperty(index, edge, type) {
          // Edges are adjacent, so use combined separation value for both, on that edge
          var propName = edge + type, // E.g. topSpacing
          sum = spacingTraitStack[index][propName] + spacingTraitStack[index + 1][propName];
          spacingTraitStack[index][propName] = sum;
          spacingTraitStack[index + 1][propName] = sum;
        }
        function combineAdjacentEdges(edge) {
          // Edges are adjacent, so use combined separation value for both, on that edge
          combineProperty(index, edge, "Spacing");
          combineProperty(index, edge, "Divider");
        }
        // Cascade the spacing of each edge on the parent to its child, as appropriate.
        // For example, if the element is at the top of the parent, treat both object's top as
        // having the same aggregated values.
        // Because we compare each element to its parent, we start with child of the top ancestor.
        for (index = spacingTraitStack.length - 2; index >= 0; index--) {
          var adjacentEdges = getAdjacentEdges(traitStack, index);
          adjacentEdges.forEach(combineAdjacentEdges);
        }
        return spacingTraitStack;
      }
      function getVisualSeparationJudgements(node, traits, parentTraits, childTraits, judgements, childJudgements) {
        var visualSeparationJudgements = {
          // Get a number that represents the visual impact of margin, padding, border
          topSeparationImpact: getSeparationImpact(judgements.topSpacing, judgements.topDivider + traits.topBorder),
          bottomSeparationImpact: getSeparationImpact(judgements.bottomSpacing, judgements.bottomDivider + traits.bottomBorder),
          leftSeparationImpact: getSeparationImpact(judgements.leftSpacing, judgements.leftDivider + traits.leftBorder),
          rightSeparationImpact: getSeparationImpact(judgements.rightSpacing, judgements.rightDivider + traits.rightBorder),
          // Check whether a CSS background creates a visual separation from the parent,
          // (for example, it has a different background-color or uses a background-image).
          // Don't include non-repeating sprites (positioned background images) -- these are used for bullets, etc.
          hasOwnBackground: !!common.hasOwnBackground(node, traits.computedStyle, parentTraits.computedStyle),
          hasSiblingBackground: hasSiblingBackground(node, parentTraits.computedStyle, traits.tag),
          hasDescendantWithRaisedZIndex: childJudgements && (childJudgements.hasRaisedZIndex || childJudgements.hasDescendantWithRaisedZIndex),
          hasDescendantOutOfFlow: childJudgements && (childJudgements.isOutOfFlow || childJudgements.hasDescendantOutOfFlow)
        };
        visualSeparationJudgements.hasRaisedZIndex = !visualSeparationJudgements.hasDescendantWithRaisedZIndex && common.hasRaisedZIndex(childTraits.computedStyle, traits.computedStyle);
        visualSeparationJudgements.isOutOfFlow = !visualSeparationJudgements.hasDescendantOutOfFlow && isOutOfFlow(node, traits, parentTraits);
        // Get effective separation impact vertically and horizontally
        // This is helpful because often a group of items will define spacing on one side of each
        // item, rather than both. For example, if each item in a list has a bottom margin,
        // then effectively each item looks like it also has a top margin.
        // If it's almost as wide as the body, don't let horizontal separation be considered a good thing --
        // it's probably just abutting the edge of the document.
        var isAlmostAsWideAsBody = traits.percentOfBodyWidth > IDEAL_MAX_PERCENT_OF_BODY_WIDTH;
        $.extend(visualSeparationJudgements, {
          vertSeparationImpact: Math.max(visualSeparationJudgements.topSeparationImpact, visualSeparationJudgements.bottomSeparationImpact),
          horizSeparationImpact: isAlmostAsWideAsBody ? 0 : Math.max(visualSeparationJudgements.leftSeparationImpact, visualSeparationJudgements.rightSeparationImpact)
        });
        return visualSeparationJudgements;
      }
      function getSizeJudgements(node, judgements, traits, firstNonInlineTraits, childJudgements) {
        var isSignificantlyWiderThanFirstOption = traits.rect.width < firstNonInlineTraits.rect.width + SIGNIFICANT_EDGE_PIXEL_GROWTH;
        return {
          // Avoid picking tiny icons or images of vertical lines
          tinyHeightFactor: (traits.isVisualMedia || judgements.hasOwnBackground) && // Make sure it's an image or bg image, otherwise we punish lines of text too much
          Math.pow(Math.max(0, TINY_HEIGHT_PIXEL_THRESHOLD - traits.visualHeightAt1x), TINY_ELEMENT_IMPACT_POWER),
          // Avoid picking tiny icons or images of horizontal lines
          tinyWidthFactor: Math.pow(Math.max(0, TINY_WIDTH_PIXEL_THRESHOLD - traits.visualWidthAt1x), TINY_ELEMENT_IMPACT_POWER),
          // Avoid picking extremely tall items
          isExtremelyTall: childJudgements && childJudgements.isExtremelyTall || traits.visualHeightAt1x > TALL_ELEMENT_PIXEL_THRESHOLD && childJudgements && traits !== firstNonInlineTraits && // Give super tall paragraphs in an article a chance
          node.getElementsByTagName("br").length > MIN_BR_TAGS_IN_TALL_ARTICLE,
          // We have a concept of percentage of viewport width and height, where under or over the ideal is not good.
          // Avoid picking things that are very small or large, which are awkward in the HLB according to users.
          percentOfViewportHeightUnderIdealMin: Math.max(0, IDEAL_MIN_PERCENT_OF_VIEWPORT_HEIGHT - traits.percentOfViewportHeight),
          percentOfViewportHeightOverIdealMax: Math.min(60, Math.max(0, traits.percentOfViewportHeight - IDEAL_MAX_PERCENT_OF_VIEWPORT_HEIGHT)),
          percentOfViewportWidthUnderIdealMin: Math.max(0, IDEAL_MIN_PERCENT_OF_VIEWPORT_WIDTH - traits.percentOfViewportWidth),
          // If no good child candidate, don't punish it for being almost as wide as the viewport
          percentOfViewportWidthOverIdealMax: isSignificantlyWiderThanFirstOption ? Math.max(0, traits.percentOfViewportWidth - IDEAL_MAX_PERCENT_OF_VIEWPORT_WIDTH) : 0,
          nearBodyWidthFactor: isSignificantlyWiderThanFirstOption ? 0 : // If we're not significantly wider than the first non-inline candidate, don't punish for being wide
          Math.pow(Math.max(0, traits.percentOfBodyWidth - IDEAL_MAX_PERCENT_OF_BODY_WIDTH), NEAR_BODY_WIDTH_IMPACT_POWER)
        };
      }
      // Judge different types of growth:
      // "Growth" is size comparison between an element and a descendant.
      // It can be measured as:
      // - A difference in pixels, as a ratio or as a percentage.
      // The comparisons can be between:
      // - A parent candidate to the child candidate
      // - From the current candidate to its child candidate
      // - From the current candidate to first non-inline candidate
      function getGrowthJudgements(traits, childTraits, parentTraits, firstNonInlineTraits, firstTraits, childJudgements) {
        var growthJudgements = {
          // Ratio of sizes between objects
          // Comparison with first non-inline candidate.
          // This is the first element can provide useful size to compare with.
          totalHorizGrowthFactor: traits.fullWidth / firstNonInlineTraits.fullWidth,
          totalVertGrowthFactor: traits.rect.height / firstNonInlineTraits.rect.height,
          // Comparison with the parent
          parentHorizGrowthFactor: parentTraits.fullWidth / traits.fullWidth,
          parentVertGrowthFactor: parentTraits.rect.height / traits.rect.height,
          // Comparison with the child
          childHorizGrowthFactor: traits.fullWidth / childTraits.fullWidth,
          childVertGrowthFactor: traits.rect.height / childTraits.rect.height,
          // Amount of growth in particular direction, in pixels.
          // We use unzoomedRect so that the numbers are not impacted by the amount of zoom.
          topGrowth: childTraits.unzoomedRect.top - traits.unzoomedRect.top,
          bottomGrowth: traits.unzoomedRect.bottom - childTraits.unzoomedRect.bottom,
          leftGrowth: childTraits.unzoomedRect.left - traits.unzoomedRect.left,
          rightGrowth: traits.unzoomedRect.right - childTraits.unzoomedRect.right
        };
        function getBadGrowth(edge) {
          if (!childJudgements) {
            return 0;
          }
          var separationImpact = childJudgements[edge + "SeparationImpact"];
          if (growthJudgements[edge + "Growth"] < SIGNIFICANT_EDGE_PIXEL_GROWTH || separationImpact < SIGNIFICANT_SEPARATION_IMPACT) {
            return 0;
          }
          return separationImpact;
        }
        // "Bad growth" is growth in a direction after there was already visual separation in that direction.
        // For example, a child element has right padding, and the parent element grows to the right over that.
        // It is more likely that choosing the child element is correct, because it was already a distinct visual unit.
        $.extend(growthJudgements, {
          badGrowthTop: getBadGrowth("top"),
          badGrowthBottom: getBadGrowth("bottom")
        });
        // Judge categories of growth
        growthJudgements.large2dGrowth = // Significantly larger both horizontally and vertically when compared with the first non-inline candidate.
        // This is rarely good. It generally means we're in a group of visual groups.
        // If we don't have this rule, we tend to pick very large containers that are used for 2d layout.
        // Do not do this punishment if the child was very small for picking, because this rule
        // is all about preferring reasonable child containers over those that are too big.
        // Only need moderate horizontal growth -- things tend to be wider than they are tall.
        // Also, by requiring extreme vertical growth we don't fire as much when the first non-inline was a single line of text.
        childJudgements && !childJudgements.percentOfViewportHeightUnderIdealMin && !childJudgements.percentOfViewportWidthUnderIdealMin && growthJudgements.totalHorizGrowthFactor > MODERATE_GROWTH_FACTOR && growthJudgements.totalVertGrowthFactor > EXTREME_GROWTH_FACTOR && growthJudgements.totalHorizGrowthFactor * growthJudgements.totalVertGrowthFactor;
        $.extend(growthJudgements, {
          // Moderate one dimensional growth often means the parent is just stretching to cover a little more
          // information. For example, adding a thumbnail or a caption. This is good for the parent and bad for the child.
          // This rule is used to give the child a penalty.
          // If we don't have this rule we tend to miss attaching supplemental information such as captions.
          isModeratelySmallerThanParentInOneDimension: !growthJudgements.large2dGrowth && ((firstTraits.isVisualMedia || traits.normDisplay.indexOf("inline") < 0) && // A little horizontal growth but none vertically
          growthJudgements.parentHorizGrowthFactor < MODERATE_GROWTH_FACTOR && growthJudgements.parentHorizGrowthFactor > VERY_SMALL_GROWTH_FACTOR && growthJudgements.parentVertGrowthFactor < VERY_SMALL_GROWTH_FACTOR || //traits.normDisplay !== 'block' && // Why? Broke captions
          growthJudgements.parentVertGrowthFactor < MODERATE_GROWTH_FACTOR && growthJudgements.parentVertGrowthFactor > VERY_SMALL_GROWTH_FACTOR && growthJudgements.parentHorizGrowthFactor < VERY_SMALL_GROWTH_FACTOR),
          // Similar rule, used to give the parent a bonus:
          // This is a good thing, we are just encompassing a little more information such as an image or caption.
          // If we don't have this rule we tend to miss attaching supplemental information such as captions.
          isModeratelyLargerThanChildInOneDimension: childJudgements && childJudgements.isModeratelySmallerThanParentInOneDimension,
          // Growing much larger horizontally is generally a bad thing unless the original item was an image.
          // This is often a horizontal row of cells -- better to pick the smaller cells.
          isLargeWidthExpansion: growthJudgements.totalHorizGrowthFactor > EXTREME_GROWTH_FACTOR && !firstTraits.isVisualMedia
        });
        // Roughly the same size if the total growth is less than a threshold
        growthJudgements.isRoughlySameSizeAsChild = growthJudgements.topGrowth + growthJudgements.bottomGrowth + growthJudgements.leftGrowth + growthJudgements.rightGrowth < ROUGHLY_SAME_SIZE_THRESHOLD;
        return growthJudgements;
      }
      // Heuristics to see if something looks like a cell/box based on box coordinate information.
      // By cell, we mean a box-shaped container of related information.
      // We call it a cell because it's generally grouped in rows and/or columns.
      // It is not necessarily a table cell.
      function getCellLayoutJudgements(node, judgements, traits, parentTraits, childJudgements, firstNonInlineTraits) {
        var cellLayoutJudgements = {};
        // Is any descendant of the candidate already a cell?
        // If yes, avoid picking this candidate because it's likely a super container.
        cellLayoutJudgements.isAncestorOfCell = !!(childJudgements && (childJudgements.isAncestorOfCell || childJudgements.isCellInCol || childJudgements.isCellInRow));
        // Is any descendant of the candidate already a cell and the candidate is much wider than the cell?
        // If yes, avoid picking this candidate because it's probably a row of cells.
        cellLayoutJudgements.isWideAncestorOfCell = cellLayoutJudgements.isAncestorOfCell && traits.percentOfViewportWidth > IDEAL_MAX_PERCENT_OF_VIEWPORT_WIDTH;
        cellLayoutJudgements.isCellInCol = false;
        cellLayoutJudgements.isCellInRow = false;
        cellLayoutJudgements.hasSimilarSiblingCells = false;
        cellLayoutJudgements.hasUniformlySizedSiblingCells = false;
        function getNumChildrenWithTag(parentElem, tag) {
          if (!parentElem) {
            return 0;
          }
          var children = parentElem.children, index = children.length, numWithTag = 0;
          while (index--) {
            if (children[index].localName === tag) {
              ++numWithTag;
            }
          }
          return numWithTag;
        }
        function isPossibleCell() {
          var numSiblings = parentTraits.childCount;
          // Need multiple children
          if (1 === numSiblings) {
            return false;
          }
          // Avoid parents of existing cells
          if (cellLayoutJudgements.isAncestorOfCell) {
            return false;
          }
          // Avoid certain tags
          if (UNLIKELY_CELL_TAGS.hasOwnProperty(traits.tag)) {
            return false;
          }
          // Avoid inline blocks
          // Are we sure about this rule?
          if ("inline-block" === traits.normDisplay) {
            return false;
          }
          // If area grows too much for the number of children
          if (2 === numSiblings) {
            var parentAreaGrowthSibling1 = traits.parentHorizGrowthFactor * traits.parentVertGrowthFactor, parentAreaGrowthSibling2 = 1 / (1 - 1 / parentAreaGrowthSibling1), maxParentAreaGrowth = 2 * MAX_CELL_GROUP_GROWTH_PER_SIBLING;
            if (parentAreaGrowthSibling1 > maxParentAreaGrowth || parentAreaGrowthSibling2 > maxParentAreaGrowth) {
              return false;
            }
            if (1 === node.parentNode.getElementsByTagName("img").length) {
              return false;
            }
          }
          // Do almost all of the siblings have the same tag name?
          var $parent = $(node).parent(), numSiblingsSameTag = getNumChildrenWithTag($parent[0], traits.tag), numSiblingsOtherTagAllowed = Math.min(2, Math.floor(.33 * numSiblingsSameTag));
          if (numSiblingsSameTag < numSiblings - numSiblingsOtherTagAllowed) {
            return false;
          }
          return true;
        }
        if (isPossibleCell()) {
          var isComplex = traits !== firstNonInlineTraits, hasExactWidthSiblingCells = true, hasExactHeightSiblingCells = true, siblingsToTry = $(node).children(), numSiblingsToTest = siblingsToTry.length;
          // Look for similar widths because heights can vary when the amount of text varies
          if (numSiblingsToTest < 2) {
            hasExactWidthSiblingCells = hasExactHeightSiblingCells = false;
          } else {
            var MAX_SIBLINGS_TO_TEST = 5;
            // At least two siblings to test
            $(siblingsToTry).each(function(index, sibling) {
              var rect = traitcache.getRect(sibling);
              if (rect.width !== traits.fullWidth) {
                hasExactWidthSiblingCells = false;
                return false;
              }
              if (rect.height !== traits.rect.height) {
                hasExactHeightSiblingCells = false;
                return false;
              }
              if (index > MAX_SIBLINGS_TO_TEST) {
                return false;
              }
            });
          }
          // If it is a float, is it a float to create an appearance of cells in a row?
          // We judge this as true if:
          // - The parent height growth is relatively small, and
          // - The parent width growth is large
          // Note: often the parent row is a lot taller than the current candidate,
          // so we have to be a little forgiving on parent height growth.
          // Do we look like a cell in a column of cells?
          cellLayoutJudgements.isCellInCol = judgements.parentHorizGrowthFactor < VERY_SMALL_GROWTH_FACTOR && // Approx. same width
          judgements.parentVertGrowthFactor > COLUMN_VERT_GROWTH_THRESHOLD && // Large vertical growth
          traits.percentOfViewportHeight < IDEAL_MAX_PERCENT_OF_VIEWPORT_HEIGHT && parentTraits.visualHeightAt1x > MIN_AVERAGE_COLUMN_CELL_HEIGHT * Math.min(12, parentTraits.childCount) && traits.visualHeightAt1x > MIN_COLUMN_CELL_HEIGHT && (hasExactHeightSiblingCells && hasExactWidthSiblingCells || isComplex || judgements.vertSeparationImpact > SIGNIFICANT_SEPARATION_IMPACT);
          // Do we look like a cell in a row of cells?
          cellLayoutJudgements.isCellInRow = // Standard cell rules
          judgements.parentVertGrowthFactor < VERY_SMALL_GROWTH_FACTOR && judgements.parentHorizGrowthFactor > ROW_HORIZ_GROWTH_THRESHOLD && // Large horizontal growth
          traits.percentOfViewportWidth < IDEAL_MAX_PERCENT_OF_VIEWPORT_WIDTH && judgements.horizSeparationImpact > SIGNIFICANT_SEPARATION_IMPACT || // Also try floating cell-in-row rule
          parentTraits && "none" !== traits.computedStyle.float && traits.computedStyle.float !== parentTraits.computedStyle.float && (judgements.parentVertGrowthFactor < SMALL_GROWTH_FACTOR && judgements.parentHorizGrowthFactor > ROW_HORIZ_GROWTH_THRESHOLD || judgements.parentVertGrowthFactor < MODERATE_GROWTH_FACTOR && judgements.parentHorizGrowthFactor > EXTREME_GROWTH_FACTOR);
          cellLayoutJudgements.hasUniformlySizedSiblingCells = cellLayoutJudgements.isCellInRow && hasExactHeightSiblingCells || cellLayoutJudgements.isCellInCol && hasExactHeightSiblingCells;
        }
        return cellLayoutJudgements;
      }
      // DOM judgements
      // Judgements based on the DOM, including tags, roles and hierarchical relationships.
      // Note: authors do not always use semantics in a reasonable way. Because of this, we do not
      // weigh the use of grouping tags and roles very highly.
      function getDOMStructureJudgements(judgements, traits, childJudgements, childTraits, node, index) {
        var domJudgements = {
          isGreatTag: GREAT_TAGS.hasOwnProperty(traits.tag),
          isGoodTag: GOOD_TAGS.hasOwnProperty(traits.tag),
          isGoodRole: GOOD_ROLES.hasOwnProperty(traits.role),
          isHeading: HEADING_TAGS.hasOwnProperty(traits.tag),
          badParents: $(node).parents(BAD_PARENTS_SELECTOR).length,
          horizontalListDescendantWidth: childJudgements ? childJudgements.listAndMenuFactor < 0 ? childTraits.percentOfBodyWidth : childJudgements.horizontalListDescendantWidth : 0,
          listAndMenuFactor: !judgements.isAncestorOfCell && getListAndMenuFactor(node, traits, judgements),
          isFormControl: elemClassifier.isFormControl(node),
          // Being grouped with a single image indicates something is likely good to pick
          isGroupedWithImage: traits.visualHeightAt1x > MIN_IMAGE_GROUP_HEIGHT && (index < MAX_ANCESTOR_INDEX_IMAGE_GROUP || childJudgements.isGroupedWithImage) && isGroupedWithImage(traits, node, index),
          // A child candidate was considered a section start container
          isAncestorOfSectionStartContainer: childJudgements && (childJudgements.isSectionStartContainer || childJudgements.isAncestorOfSectionStartContainer),
          // Avoid picking things like hero images or ancestors of them
          isWideMediaContainer: null !== childJudgements && childJudgements.isWideMediaContainer || traits.isVisualMedia && traits.percentOfViewportWidth > MEDIA_MAX_PERCENT_OF_VIEWPORT_WIDTH,
          // A divided group should be avoided. Rather, the subgroups should be picked.
          // Avoid picking the current candidate if it is divided by a heading or separator in the middle, because
          // it is probably an ancestor of smaller useful groups.
          numElementsDividingContent: childJudgements && childJudgements.numElementsDividingContent || numElementsDividingContent(node)
        };
        // A container that begins with a heading or dividing element is likely a good item to pick
        // Don't check if it's a section-start-container when it's an ancestor of another section start container,
        // unless the parent is about the same size as the child
        domJudgements.isSectionStartContainer = (!domJudgements.isAncestorOfSectionStartContainer || judgements.isRoughlySameSizeAsChild) && isSectionStartContainer(node) && getLeafElements(node).length > 1;
        domJudgements.isHeadingContentPair = domJudgements.isSectionStartContainer && !domJudgements.isAncestorOfSectionStartContainer && 2 === traits.childCount;
        // A heading grouped with a single item
        domJudgements.isParentOfOnlyChild = 1 === traits.childCount;
        return domJudgements;
      }
      // Is the content divided into 2 or more sections?
      // IOW, is there a heading/hr in the middle of it rather than just at the start?
      // This will return true even if there is something before the heading that is not grouped with <header>.
      function numElementsDividingContent(container) {
        // Find descendants which start a section
        var $dividingElements = $(container).find(SECTION_START_SELECTOR), // Get the last dividing element
        $lastDividingElement = $dividingElements.last();
        if (!$lastDividingElement.length) {
          return 0;
        }
        var // Used in while loop
        sibling, $sibling, // Get the dividing element we want to test
        // We use the last one that's not at the very end
        testDividingElement = $lastDividingElement[0] === container || $.contains(container, $lastDividingElement[0]) ? $dividingElements.get($dividingElements.length - 1) : $lastDividingElement, // Go up from last dividing element, to find the topmost dividing element.
        // This protects against nested dividing elements confusing us.
        parentSectionStart = $(testDividingElement).parentsUntil(container, SECTION_START_SELECTOR), // Starting point
        currentAncestor = (parentSectionStart.length ? parentSectionStart : $lastDividingElement)[0];
        if ($(currentAncestor).parents(BAD_PARENTS_SELECTOR).length) {
          return 0;
        }
        // Go up from starting point to see if a non-section-start exists before it in the container.
        while (currentAncestor && currentAncestor !== container) {
          sibling = currentAncestor.parentNode.firstElementChild;
          // Look at all the siblings before the currentAncestor
          while (sibling && sibling !== currentAncestor) {
            $sibling = $(sibling);
            if (!$sibling.is(SECTION_START_SELECTOR) && !$sibling.is(":empty") && !traitcache.isHidden(sibling, true) && !isSectionStartContainer(sibling) && !isVisualMediaSubtree(sibling)) {
              // A visible non-section-start element exists before the section-start-element, which means we are divided!
              // Return the number of section start elements
              return $dividingElements.length;
            }
            sibling = sibling.nextElementSibling;
          }
          currentAncestor = currentAncestor.parentElement;
        }
        return 0;
      }
      // Return true if visual media or the only contents are visual media
      function isVisualMediaSubtree(container) {
        if (elemClassifier.isVisualMedia(container)) {
          return true;
        }
        var leaves = getLeafElements(container);
        return 1 === leaves.length && elemClassifier.isVisualMedia(leaves[0]);
      }
      function getLeafElements(node) {
        return $(node).find("*").filter(function() {
          return 0 === this.childElementCount;
        });
      }
      // Should we even consider this node or not?
      function isUsable(traits) {
        // Don't use inlines unless they are images or other visual media
        return ("inline" !== traits.normDisplay || traits.isVisualMedia) && !UNUSABLE_TAGS.hasOwnProperty(traits.tag) && !UNUSABLE_ROLES.hasOwnProperty(traits.role);
      }
      // Menubars are bad
      // Vertical lists and menus are good
      // This attempts to provide a scoring factor for all of these similar objects
      // 0 if not a list
      // -1 if a horizontal list
      // +1 if a vertical list
      // Score is multiplied by LINK_LIST_FACTOR if a list of 3 or more links
      // Score is multiplied by OUT_OF_FLOW_LIST_FACTOR if an absolutely positioned list
      function getListAndMenuFactor(node, traits, judgements) {
        var isListOfLinks, listItems = $(node).children('li,[role|="menuitem"]'), // Also matches menuitemradio, menuitemcheckbox
        links = getLinks(node), numListItems = listItems.length, numLinks = links.length;
        function getLinks(node) {
          // First check for simple <a> direct children
          var links = $(node).children("a");
          if (links.length) {
            return links;
          }
          // If none, return <li> with a single <a> element child
          return $(node).children("li").filter(function(index, elem) {
            return 1 === elem.childElementCount && "a" === elem.firstElementChild.localName;
          });
        }
        function isMultiLine() {
          return (parseFloat(1.5 * traits.computedStyle.lineHeight) || parseFloat(2 * traits.computedStyle.fontSize)) < traits.visualHeightAt1x;
        }
        if ("ul" !== traits.tag && "menu" !== traits.role) {
          // Still check for horizontal link arrangement
          if (numLinks < 3 || judgements.totalVertGrowthFactor > 1.5 || isMultiLine() || !isArrangedHorizontally(links)) {
            return 0;
          }
          // At least 3 horizontal links -- really bad
          return -numLinks;
        }
        if (numListItems < 2) {
          return 0;
        }
        isListOfLinks = numListItems > 2 && numLinks === numListItems;
        // Same number of links as <li>
        return (isListOfLinks ? LINK_LIST_FACTOR : 1) * (judgements.isOutOfFlow ? OUT_OF_FLOW_LIST_FACTOR : 1) * (isArrangedHorizontally(listItems) ? -numListItems : 1);
      }
      function isArrangedHorizontally(items) {
        var rect1 = traitcache.getRect(items[0]), rect2 = traitcache.getRect(items[items.length - 1]);
        // If left sides line up we are vertical
        return rect1.top === rect2.top && rect1.left < rect2.left;
      }
      // Groups of related content often pair an image with text -- this is a noticeable pattern, e.g. on news sites
      function isGroupedWithImage(traits, node) {
        if (0 === traits.childCount || traits.childCount > MAX_CHILDREN_IMAGE_GROUP) {
          return false;
        }
        var images = $(node).find("img"), numGoodImages = 0, minSide = SIGNIFICANT_IMAGE_PIXELS * traitcache.getCachedViewSize().zoom;
        $(images).each(function() {
          var imageRect = traitcache.getRect(this);
          // Hidden or separator images don't count
          if (imageRect.width > minSide && imageRect.height > minSide) {
            ++numGoodImages;
          }
        });
        return 1 === numGoodImages && getLeafElements(node).length > 1;
      }
      // If the element a divider (such as <hr>), return it's thickness, otherwise return 0
      function getDividerThickness(node, side, validSideMin, validSideMax) {
        if ($(node).is(DIVIDER_SELECTOR)) {
          // Some images can be dividers as well, we will check the height and width
          // Is divider element: return the height
          var rect = traitcache.getRect(node), zoom = traitcache.getCachedViewSize().zoom, height = rect.height / zoom, width = rect.width / zoom;
          if (rect[side] >= validSideMin && rect[side] <= validSideMax && // Must be within these ranges
          height < SEPARATOR_IMAGE_PIXEL_THRESHOLD !== width < SEPARATOR_IMAGE_PIXEL_THRESHOLD) {
            // Must be thin (vert or horiz)
            return Math.min(height, width);
          }
        }
        return 0;
      }
      // Check first rendered descendant element to see if it's a heading, or any element
      // typically used to start a new section
      function isSectionStartContainer(node) {
        var child = node.firstElementChild;
        if (child && elemClassifier.isVisualMedia(child)) {
          child = child.nextElementSibling;
        }
        if (!child) {
          return false;
        }
        if ($(child).is(SECTION_START_SELECTOR)) {
          return true;
        }
        return isSectionStartContainer(child);
      }
      // Magic formula that provides a number for how impactful the margin, padding and border are for a given edge
      function getSeparationImpact(separation, borderWidth) {
        var separationImpact = Math.min(Math.pow(separation / SEPARATION_DIVISOR, SEPARATION_IMPACT_POWER), MAX_SPACE_SEPARATION_IMPACT), borderImpact = Math.min(borderWidth * BORDER_WIDTH_BONUS, MAX_BORDER_SEPARATION_IMPACT);
        return separationImpact + borderImpact;
      }
      // Position: absolute/fixed and rect sticks out from parent (not wholly encompassed by it)
      function isOutOfFlow(node, traits, parentTraits) {
        if ("absolute" !== traits.computedStyle.position && "fixed" !== traits.computedStyle.position) {
          return false;
        }
        if (0 === traits.childCount && $(node).is(":empty")) {
          return false;
        }
        // Return true if we stick out from parent
        var parentRect = parentTraits.rect, thisRect = traits.rect;
        return thisRect.left < parentRect.left || thisRect.top < parentRect.top || thisRect.right > parentRect.right || thisRect.bottom > parentRect.bottom;
      }
      // Also considered to have it's own background if the item before or after does,
      // because many times colors are alternated by even/odd row
      function hasSiblingBackground(element, parentStyle, tag) {
        // Note: don't use $.is() which uses matches with tag, since tag can be something with a : in it, and will cause an error
        var sibling = element.previousElementSibling || element.nextElementSibling, hasSiblingBg = sibling && sibling.localName === tag && sibling.hasChildNodes() && common.hasOwnBackground(sibling, traitcache.getStyle(sibling), parentStyle);
        return !!hasSiblingBg;
      }
      // Get the traits of the first non-inline element as we go up ancestor chain, because
      // inlines don't provide valuable bounding boxes for the judgement calculations.
      // At index 0 = original event target, index 1 is the parent of that, 2 is the grandparent, etc.
      // Non-inline includes block, table-cell, etc.
      function getTraitsOfFirstNonInlineCandidate(traitStack) {
        var displayStyle, index = 0, length = traitStack.length;
        for (;index < length; index++) {
          displayStyle = traitStack[index].normDisplay;
          if ("inline" !== displayStyle && "inline-block" !== displayStyle) {
            return traitStack[index];
          }
        }
        return traitStack[0];
      }
      return {
        getJudgementStack: getJudgementStack,
        provideCustomJudgements: provideCustomJudgements
      };
    }($, page_util_common, page_util_element_classifier, page_highlight_traitcache);
    page_highlight_pick = function($, common, pref, site, traitcache, traits, judge, nativeGlobal, inlineStyle, platform) {
      var isDebuggingOn, isVoteDebuggingOn, isAutoPickDebuggingOn, lastPicked, UNUSABLE_SCORE = -99999, // A score so low there is no chance of picking the item
      MAX_ANCESTORS_TO_ANALYZE = 14, // Maximum ancestors to climb looking for start.
      MIN_ANCESTORS_TO_ANALYZE = 4, // Three is enough -- after that, we can stop analyzing if things start to look unusable
      MAX_LEAVES_TO_VOTE = 5, // Maximum number of leaves to vote
      SECOND_BEST_IS_VIABLE_THRESHOLD = 32, // 2nd best is viable if within this many points of best score
      MIN_SCORE_TO_PICK = -200, // If nothing above this, will pick nothing
      // In order of precedence:
      PICK_RULE_DISABLE = "disable", // don't pick this anything -- not this item, any ancestor, or any descendant
      PICK_RULE_PREFER = "prefer", // pick this item
      PICK_RULE_IGNORE = "ignore", // don't pick this item
      // Use hack to avoid IE bugs where HLB on inputs does not allow editing
      GLOBAL_DISABLE_PICKER_SELECTOR = '#sitecues-badge,iframe[name="google_conversion_frame"],[data-sc-pick="' + PICK_RULE_DISABLE + '"]', // Don't pick invisible Google Adwords iframe
      // The following weights are used to multiple each judgement of the same name, defined in judgements.js
      // The score is a sum of these weights * judgements
      // Public in order to allow customizations
      judgementWeights = {
        isGreatTag: 13,
        isGoodTag: 3,
        isGoodRole: 8,
        isHeading: -8,
        badParents: -10,
        listAndMenuFactor: 18,
        horizontalListDescendantWidth: -.6,
        isGroupedWithImage: 15,
        isFormControl: 20,
        hasOwnBackground: 20,
        hasSiblingBackground: 5,
        hasRaisedZIndex: 20,
        hasDescendantWithRaisedZIndex: -50,
        isOutOfFlow: 15,
        hasDescendantOutOfFlow: UNUSABLE_SCORE,
        vertSeparationImpact: .8,
        horizSeparationImpact: .8,
        percentOfViewportHeightUnderIdealMin: -.5,
        percentOfViewportHeightOverIdealMax: -2.5,
        percentOfViewportWidthUnderIdealMin: -.7,
        percentOfViewportWidthOverIdealMax: -.5,
        nearBodyWidthFactor: -1,
        tinyHeightFactor: -3,
        tinyWidthFactor: -5,
        isExtremelyTall: UNUSABLE_SCORE,
        badGrowthTop: -.5,
        badGrowthBottom: -.5,
        large2dGrowth: -1,
        isModeratelySmallerThanParentInOneDimension: -20,
        isModeratelyLargerThanChildInOneDimension: 20,
        isCellInRow: 15,
        isCellInCol: 15,
        hasUniformlySizedSiblingCells: 15,
        hasSimilarSiblingCells: 15,
        isSectionStartContainer: 20,
        isHeadingContentPair: 20,
        // Also steals from child
        isParentOfOnlyChild: 3,
        // Also steals from child
        numElementsDividingContent: -8,
        isAncestorOfCell: -10,
        isWideAncestorOfCell: -10,
        isLargeWidthExpansion: -10,
        isWideMediaContainer: UNUSABLE_SCORE
      }, // When these judgements are not zero, part of the score transfers from a child to parent or vice vers
      // - If > 0, the parent steals this portion of the child's score
      // - In theory, if < 0, the child steals this portion of the parent's score
      //   We don't use this yet and need to make sure that a parent's score doesn't go up from the thievery
      // This is performed in separate stage after WEIGHTS used, and before voting
      THIEF_WEIGHTS = {
        isParentOfOnlyChild: .75,
        isHeadingContentPair: .75,
        isModeratelyLargerThanChildInOneDimension: .3
      }, MAX_VISUAL_BOX_CHECK_SIZE = 400, // We try to highlight even over whitespace if cursor is within a box of this size or less
      // Inject selectors via sitecues.config.picker or customization module using provideCustomSelectors()
      // Object is as follows:
      //{
      //  prefer: "[selector]",
      //  ignore: "[selector]",
      //  disable: "[selector]"
      //},
      customSelectors = site.get("picker") || {}, isVotingOn = true;
      function isValidStart(node) {
        if (!node) {
          return false;
        }
        switch (node.localName) {
         case "html":
          return false;

         case "body":
          return false;

         case "select":
          // Firefox mispositions the dropdown menu of comboboxes with size 1 in the lens, so we don't allow them to be picked
          return node.size >= 2 || true;
        }
        return !isInSitecuesUI(node);
      }
      /*
   * ----------------------- PUBLIC -----------------------
   *
   * MAIN FUNCTION AND ENTRY POINT
   * Find the best highlightable element, if any, given a target element.
   * Returns JQuery object if anything picked, otherwise null (never returns JQuery object of length 0)
   *
   * @param hover The element the mouse is hovering over
   */
      function find(startElement, doSuppressVoting) {
        var candidates, picked;
        function processResult(result) {
          lastPicked = result && result[0];
          return result;
        }
        // 1. Don't pick anything in the sitecues UI
        if (!isValidStart(startElement)) {
          return null;
        }
        // 1.5. If over a map, use associated image element for processing
        if ("area" === startElement.localName) {
          startElement = getImageForMapArea(startElement);
        }
        // 2. Reset trait cache
        traitcache.resetCache();
        // 3. Get candidate nodes that could be picked
        // Remove any ancestor that has the #sitecues-badge as a descendant
        candidates = getCandidates(startElement);
        // 4. Don't pick anything when over whitespace
        //    Avoids slow, jumpy highlight, and selecting ridiculously large containers
        if (!candidates || !hasVisibleContent(candidates)) {
          return null;
        }
        // 5. Get deterministic result
        //    a) from customizations or
        //    b) previously stored picker results
        picked = getDeterministicResult(candidates);
        if (null !== picked) {
          return processResult(picked[0] ? picked : null);
        }
        // 6. Get result from heuristics taking into account votes from leaves of content
        picked = getHeuristicResult(candidates, isVotingOn && !doSuppressVoting);
        // 7. Save results for next time
        lastPicked = picked;
        return processResult(picked ? $(picked) : null);
      }
      function reset() {
        lastPicked = null;
      }
      function getCandidates(startElement) {
        var allAncestors = $(startElement).parentsUntil("body"), validAncestors = getVisibleAncestors(allAncestors);
        if (0 === validAncestors.length) {
          return [ startElement ];
        }
        if (lastPicked) {
          var isAncestorOfLastPicked = false;
          // Remove ancestors of the last picked item from possible selection
          // This improves picker consistency and improves performance (fewer elements to check)
          validAncestors = $(validAncestors).filter(function() {
            if (isAncestorOfLastPicked || $.contains(this, lastPicked)) {
              isAncestorOfLastPicked = true;
              return false;
            } else {
              return true;
            }
          });
        }
        return [ startElement ].concat($.makeArray(validAncestors));
      }
      function getVisibleAncestors(ancestors) {
        var opacity = null, index = ancestors.length;
        while (index--) {
          opacity = traitcache.getStyleProp(ancestors[index], "opacity");
          if ("0" === opacity) {
            ancestors = ancestors.slice(index + 1, ancestors.length - 1);
            break;
          }
        }
        return ancestors;
      }
      function getImageForMapArea(element) {
        var mapName = $(element).closest("map").attr("name"), imageSelector = 'img[usemap="#' + mapName + '"]';
        return mapName ? $(imageSelector)[0] : null;
      }
      // --------- Deterministic results ---------
      // A deterministic result is a hard rule for picking a specific element,
      // or for picking nothing when the element is an ancestor.
      // Ways a deterministic result can occur:
      // 1) A customization via provideCustomSelectors() e.g. { disable:"[selector]", prefer: "[selector]" }
      // 2) HTML attribute @data-sc-pick on the element itself ('prefer' or 'disable') -- see PICK_RULE_FOO constants
      function getDeterministicResult(candidates) {
        // 1. Check customizations
        var picked = getCustomizationResult(candidates);
        if (picked) {
          return picked;
        }
        // 2. Check @data-sc-pick (markup-specified rule)
        return getPickRuleResult(candidates);
      }
      function getPickRuleResult(candidates) {
        var picked = null;
        function checkPickRuleForElement(item) {
          var pickRule = $(item).attr("data-sc-pick");
          if (pickRule === PICK_RULE_PREFER) {
            picked = $(item);
          }
        }
        // Check @data-sc-pick for values in PICK_RULE_DISABLE or PICK_RULE_PREFER
        candidates.some(checkPickRuleForElement);
        return picked;
      }
      // What elements should picking be disabled on?
      function getPickingDisabledSelector() {
        var selector = customSelectors.disable ? customSelectors.disable.slice() : "";
        // TODO: Once HLB'd form controls no longer crashes MS Edge we can remove it, at least for those versions
        // For now: make sure we don't pick those controls by adding them to the custom disabled selector
        selector = (selector ? selector + "," : "") + GLOBAL_DISABLE_PICKER_SELECTOR;
        if (platform.isFirefox) {
          selector += ',select[size="1"],select:not([size])';
        }
        return selector;
      }
      // Return a jQuery object with a result determined from customizations,
      // or null if no customization applies.
      function getCustomizationResult(candidates) {
        var picked, $candidates = $(candidates), pickingDisabledSelector = getPickingDisabledSelector();
        // 1. Customizations in picker.disable = "[selector]";
        if (pickingDisabledSelector && $candidates.is(pickingDisabledSelector)) {
          return $();
        }
        // 2. Customizations in picker.prefer = "[selector]";
        if (customSelectors.prefer) {
          picked = $candidates.filter(customSelectors.prefer).first();
          if (picked.length) {
            return picked;
          }
        }
        return null;
      }
      // --------- Heuristic results ---------
      function performVote(scoreObjs, origBestIndex, candidates) {
        var bestIndex = origBestIndex, extraWork = 0;
        function getNumericScore(scoreObj) {
          return scoreObj.score;
        }
        while (true) {
          var minSecondBestScore = scoreObjs[bestIndex].score - SECOND_BEST_IS_VIABLE_THRESHOLD;
          var secondBestIndex = getCandidateWithHighestScore(scoreObjs, minSecondBestScore, bestIndex);
          if (secondBestIndex < 0) {
            var scores = scoreObjs.map(getNumericScore);
            if (true && isVoteDebuggingOn) {
              console.log("--> break no other competitors: " + nativeGlobal.JSON.stringify(scores));
            }
            break;
          }
          if (true && isVoteDebuggingOn) {
            console.log("1st = %d (score=%d) %O", bestIndex, scoreObjs[bestIndex].score, candidates[bestIndex]);
            console.log("2nd = %d (score=%d) %O", secondBestIndex, scoreObjs[secondBestIndex].score, candidates[secondBestIndex]);
          }
          // 3. Choose between first and second best candidate
          ++extraWork;
          var topIndex = Math.max(bestIndex, secondBestIndex), // Top-most (container) choice
          topElement = candidates[topIndex], bottomIndex = Math.min(bestIndex, secondBestIndex), // Bottom-most (not container) choice
          leaves = getLeavesForVote(candidates[topIndex], candidates[bottomIndex]), leafIndex = 0, votesForTop = topIndex === bestIndex ? 1 : -1;
          if (true && isVoteDebuggingOn) {
            console.log("Starting vote: " + votesForTop);
          }
          for (;leafIndex < leaves.length; leafIndex++) {
            var candidatesForVote = getCandidates(leaves[leafIndex]), scoresForVote = getScores(candidatesForVote), leafVoteIndex = getCandidateWithHighestScore(scoresForVote), isVoteForTop = candidatesForVote[leafVoteIndex] === topElement;
            if (true && isVoteDebuggingOn) {
              console.log("Vote for top ? %s ---> %o voted for %O", isVoteForTop, leaves[leafIndex].firstChild || leaves[leafIndex], candidatesForVote[leafVoteIndex]);
            }
            votesForTop += isVoteForTop ? 1 : -1;
          }
          // The voters have chosen ...
          if (votesForTop < 0) {
            // The lower candidates to be highlighted as individuals
            bestIndex = bottomIndex;
            secondBestIndex = topIndex;
          } else {
            // The upper candidate as a single highlighted container
            bestIndex = topIndex;
            secondBestIndex = bottomIndex;
          }
          if (true) {
            modifyResultsFromVote(votesForTop, scoreObjs, bestIndex, secondBestIndex);
          }
          scoreObjs[bestIndex].score = Math.max(scoreObjs[topIndex].score, scoreObjs[bottomIndex].score);
          // The new champ
          scoreObjs[secondBestIndex].score = MIN_SCORE_TO_PICK;
        }
        if (true && isVoteDebuggingOn) {
          if (origBestIndex !== bestIndex) {
            inlineStyle.set(candidates[origBestIndex], {
              outline: "2px solid red"
            });
            inlineStyle.set(candidates[bestIndex], {
              outline: "2px solid green"
            });
          } else {
            console.log("Extra work " + extraWork);
            inlineStyle.set(candidates[bestIndex], {
              outline: 4 * extraWork + "px solid orange"
            });
          }
          nativeGlobal.setTimeout(function() {
            inlineStyle.set(candidates[origBestIndex], {
              outline: ""
            });
            inlineStyle.set(candidates[bestIndex], {
              outline: ""
            });
          }, 1e3);
        }
        return bestIndex;
      }
      function getHeuristicResult(candidates, doAllowVoting) {
        // 1. Get the best candidate (pre-voting)
        var bestIndex, votedBestIndex, scoreObjs = getScores(candidates), pickingDisabledSelector = getPickingDisabledSelector();
        function processResult(pickedIndex) {
          // Log the results if necessary for debugging
          if (true && isDebuggingOn) {
            !function(pickDebug) {
              // Use sitecues.togglePickerDebugging() to turn on the logging
              pickDebug.logHeuristicResult(scoreObjs, bestIndex, candidates);
            }(pick_debug);
          }
          return pickedIndex < 0 ? null : candidates[pickedIndex];
        }
        function containsItemsDisabledForPicker(index) {
          return $(candidates[index]).has(pickingDisabledSelector).length > 0;
        }
        // 2. Get the best candidate that's not disabled in the picker
        while (true) {
          bestIndex = getCandidateWithHighestScore(scoreObjs);
          if (bestIndex < 0) {
            return processResult(-1);
          }
          if (!containsItemsDisabledForPicker(bestIndex)) {
            // Does not contain picker-disabled item -- therefore this result is legal
            // We know the candidate itself is not picker-disabled, because those are filtered out in an earlier stage,
            // but here we did the more expensive check of looking at all descendants
            break;
          }
          // Remove all of the candidates that include the disabled item, and then try again
          candidates = candidates.slice(bestIndex + 1);
          scoreObjs = scoreObjs.slice(bestIndex + 1);
        }
        // 3. Get the best candidate after voting by other nearby textnodes
        if (doAllowVoting) {
          votedBestIndex = performVote(scoreObjs, bestIndex, candidates);
          // If the voted best index is a container, we need to doublecheck that it's allowable (no picker-disabled items)
          if (votedBestIndex >= bestIndex || !containsItemsDisabledForPicker(votedBestIndex)) {
            bestIndex = votedBestIndex;
          }
        }
        return processResult(bestIndex);
      }
      // Allow leaf voting to modify results, thus improving overall consistency
      function modifyResultsFromVote(votesForTop, scoreObjs, bestIndex, secondBestIndex) {
        if (isVoteDebuggingOn) {
          console.log("votesForTop = " + votesForTop);
        }
        // Debug info
        var deltaBest = scoreObjs[bestIndex].score - scoreObjs[secondBestIndex].score, deltaSecondBest = MIN_SCORE_TO_PICK - scoreObjs[secondBestIndex].score;
        if (deltaBest) {
          scoreObjs[bestIndex].factors.push({
            about: "vote-winner",
            value: deltaBest,
            weight: 1
          });
        }
        if (deltaSecondBest) {
          scoreObjs[secondBestIndex].factors.push({
            about: "vote-loser",
            value: deltaSecondBest,
            weight: 1
          });
        }
      }
      function getLeavesForVote(startElement, avoidSubtree) {
        // Fastest way to get images and up to MAX_LEAVES_TO_VOTE
        var allLeaves = [], candidates = [], imageLeaves = startElement.getElementsByTagName("img");
        function isAcceptableTextLeaf(node) {
          // Logic to determine whether to accept, reject or skip node
          if (common.isWhitespaceOrPunct(node)) {
            return;
          }
          var element = node.parentNode;
          if (element === avoidSubtree || $.contains(avoidSubtree, element)) {
            return;
          }
          return true;
        }
        // Retrieve some leaf nodes
        var nodeIterator = document.createNodeIterator(startElement, NodeFilter.SHOW_TEXT, null, false);
        function nextNode() {
          var node;
          while (true) {
            node = nodeIterator.nextNode();
            if (!node) {
              return null;
            } else {
              if (isAcceptableTextLeaf(node)) {
                return node;
              }
            }
          }
        }
        nextNode();
        var numLeaves = 0;
        while (numLeaves < 3 * MAX_LEAVES_TO_VOTE) {
          var nextTextLeaf = nextNode();
          if (!nextTextLeaf) {
            break;
          }
          allLeaves[numLeaves++] = nextTextLeaf.parentNode;
        }
        // Get an even sampling of the leaf nodes
        var numberToSkipForEvenSampling = Math.max(1, Math.floor(numLeaves / MAX_LEAVES_TO_VOTE)), index = numberToSkipForEvenSampling;
        for (;index < numLeaves; index += numberToSkipForEvenSampling) {
          // Get an even sampling of the leaves, and don't prefer the ones at the top
          // as they are often not representative of the content
          var candidate = allLeaves[index], $candidate = $(candidate);
          // We don't use hidden candidates or those in headings
          // Headings are often anomalous
          if (0 === $candidate.closest("h1,h2,h3,h4,h5,h6").length && !traitcache.isHidden(candidate, true)) {
            candidates.push(candidate);
          }
        }
        // Add up to one image in as a tie-breaking vote
        if (imageLeaves.length) {
          candidates.push(imageLeaves[0]);
        }
        return candidates;
      }
      /**
   * Return JQuery collection representing element(s) to highlight
   * Can return empty collection if there are no appropriate elements.
   * Uses a scoring system for each candidate.
   */
      function getScores(candidates) {
        // 1. Limit the number of candidate nodes we analyze (for performance)
        var restrictedCandidates = candidates.slice(0, MAX_ANCESTORS_TO_ANALYZE);
        // 2. Get traits -- basic info such as tag, role, style, coordinates
        var traitStack = traits.getTraitStack(restrictedCandidates);
        // 3. Get judgements -- higher level concepts from hand-tweaked logic
        var judgementStack = judge.getJudgementStack(traitStack, restrictedCandidates);
        // 4. Get scores
        var scoreObjs = [], index = 0;
        for (;index < judgementStack.length; index++) {
          var judgements = judgementStack[index], scoreObj = computeScore(judgements, candidates[index], index);
          scoreObj.judgements = judgements;
          scoreObj.traits = traitStack[index];
          if (index > MIN_ANCESTORS_TO_ANALYZE && scoreObj.score < MIN_SCORE_TO_PICK && scoreObjs[index - 1].score < MIN_SCORE_TO_PICK) {
            break;
          }
          scoreObjs.push(scoreObj);
        }
        // 5. Parents of only children are strongly influenced by that child
        refineParentScores(scoreObjs);
        return scoreObjs;
      }
      function isUsable(element, judgements) {
        // If no judgements exist, the candidate was already marked as unusable by the judgements system
        if (!judgements.isUsable) {
          return false;
        }
        // Check custom selectors
        if (customSelectors.ignore && $(element).is(customSelectors.ignore)) {
          return false;
        }
        // Check data attribute
        if (element.getAttribute("data-sc-pick") === PICK_RULE_IGNORE) {
          return false;
        }
        return true;
      }
      if (true) {}
      // Get the score for the candidate node at the given index
      function computeScore(judgements, element, index) {
        // 1. Check if usable: if item is not usable mark it as such
        // TODO give each isUsable() a different name
        if (!isUsable(element, judgements)) {
          return {
            score: UNUSABLE_SCORE,
            factors: [],
            // Debug info
            about: "Ancestor #" + index + ". Unusable/ignored",
            // Debug info
            isUsable: false
          };
        }
        // 2. Compute score: add up judgements * weights
        var factorKey, value, scoreDelta, weight, scoreObj = {
          score: 0,
          factors: [],
          // Debug info
          about: "Ancestor #" + index,
          // Debug info
          isUsable: true
        };
        for (factorKey in judgementWeights) {
          if (judgementWeights.hasOwnProperty(factorKey)) {
            value = judgements[factorKey];
            weight = judgementWeights[factorKey] || 0;
            scoreDelta = value * weight;
            // value is a numeric or boolean value: for booleans, JS treats true=1, false=0
            scoreObj.score += scoreDelta;
            if (true) {
              scoreObj.factors.push({
                about: factorKey,
                value: value,
                weight: weight,
                impact: scoreDelta
              });
            }
          }
        }
        return scoreObj;
      }
      // Return index of item with best score or -1 if nothing is viable
      // excludeIndex is an index to ignore (so we can easily get second best)
      // minScore is the minimum score before considering
      function getCandidateWithHighestScore(scoreObjs, minScore, excludeIndex) {
        var index, bestScore = minScore || UNUSABLE_SCORE, bestScoreIndex = -1;
        for (index = 0; index < scoreObjs.length; index++) {
          if (index !== excludeIndex && scoreObjs[index].score > bestScore) {
            bestScore = scoreObjs[index].score;
            bestScoreIndex = index;
          }
        }
        return bestScore > MIN_SCORE_TO_PICK ? bestScoreIndex : -1;
      }
      //  ----------- Score refinement section -----------
      // For every parent, add child's score to the parent * (refinement weights)
      // A parent is likely to be even more right/wrong than its child
      // Therefore the child's goodness reflects on the parent. We add it's score to the parent score.
      // The benefits of doing this are that if there is a container of child node that has no siblings,
      // or just adds a heading, we tend to prefer the container over the child.
      // If the child is bad, we tend to pick neither.
      function refineParentScores(scoreObjs) {
        var index, reasonToSteal, delta, weight, childScore, parentJudgement, childIndex = -1;
        for (index = 0; index < scoreObjs.length; index++) {
          if (childIndex >= 0 && scoreObjs[index].isUsable && scoreObjs[index].score > MIN_SCORE_TO_PICK) {
            for (reasonToSteal in THIEF_WEIGHTS) {
              if (THIEF_WEIGHTS.hasOwnProperty(reasonToSteal)) {
                childScore = scoreObjs[childIndex].score;
                // Child's score
                weight = THIEF_WEIGHTS[reasonToSteal];
                parentJudgement = scoreObjs[index].judgements[reasonToSteal];
                delta = childScore * weight * parentJudgement;
                // How much to steal from child
                if (delta) {
                  scoreObjs[index].score += delta;
                  if (true) {
                    scoreObjs[index].factors.push({
                      about: reasonToSteal + "-from-child",
                      // Debug info
                      value: childScore,
                      weight: weight
                    });
                  }
                  if (delta > 0) {
                    // Only take from child, don't give
                    scoreObjs[childIndex].score -= delta;
                    scoreObjs[childIndex].factors.push({
                      about: reasonToSteal + "-from-parent",
                      value: childScore,
                      weight: -weight
                    });
                  }
                }
              }
            }
          }
          if (scoreObjs[index].isUsable) {
            childIndex = index;
          }
        }
      }
      function hasVisibleContent(candidates) {
        // First check for direct visible text nodes
        if (common.hasVisibleContent(candidates[0])) {
          return true;
        }
        // Otherwise, see if we are inside of a box
        var candidate, rect, style, index = 0, zoom = pref.get("zoom") || 1;
        for (;index < candidates.length; index++) {
          candidate = candidates[index];
          if (lastPicked && $.contains(candidate, lastPicked)) {
            break;
          }
          rect = traitcache.getRect(candidate);
          style = traitcache.getStyle(candidate);
          if (rect.width / zoom > MAX_VISUAL_BOX_CHECK_SIZE || rect.height / zoom > MAX_VISUAL_BOX_CHECK_SIZE) {
            break;
          }
          if (common.isVisualRegion(candidate, style, traitcache.getStyle(candidate.parentNode))) {
            return true;
          }
        }
        return false;
      }
      // This gives us a score for how good what we want to auto pick is.
      // Auto picking is where we highlight something useful onscreen after the user presses space with no highlight.
      // The candidate passed in is guaranteed to be at least partly onscreen
      function getAutoPickScore(picked, fixedRect, absoluteRect, bodyWidth, bodyHeight) {
        var MIN_TOP_COORDINATE_PREFERRED = 100;
        var MIN_SIGNIFICANT_TEXT_LENGTH = 25;
        var topRole = picked.parents("[role]").last().attr("role");
        var winHeight = window.innerHeight;
        // 1. Get basic scoring info
        var scoreInfo = {
          isAtTopOfScreen: fixedRect.top < MIN_TOP_COORDINATE_PREFERRED,
          isAtTopOfDoc: absoluteRect.top < MIN_TOP_COORDINATE_PREFERRED,
          isOnTopHalfOfScreen: fixedRect >= MIN_TOP_COORDINATE_PREFERRED && fixedRect.top < .6 * winHeight,
          isPartlyBelowBottom: fixedRect.bottom > winHeight,
          isMostlyBelowBottom: fixedRect.top + fixedRect.height / 2 > winHeight,
          hasSignificantText: picked.text().length > MIN_SIGNIFICANT_TEXT_LENGTH,
          headingScore: function() {
            // Prefer something with a heading (h1 excellent, h2 very good, h3 okay)
            var headings = picked.find("h1,h2,h3,h4,h5,h6").addBack();
            return 3 * (headings.filter("h1").length > 0) || 2 * (headings.filter("h2").length > 0) || headings.length > 0;
          }(),
          isInMainContent: "main" === topRole,
          hasBadAriaRole: !!topRole && "main" !== topRole,
          isInTallAndNarrowContainer: 0,
          isInTallAndWideContainer: 0
        };
        var isWide, isTall;
        // 2. Use a size heuristic
        var portionOfBodyWidth, portionOfBodyHeight, ancestorRect, ancestor = picked[0], isInWideContainer = 0, isInTallContainer = 0;
        while ("body" !== ancestor.localName) {
          ancestorRect = traitcache.getScreenRect(ancestor);
          portionOfBodyWidth = ancestorRect.width / bodyWidth;
          portionOfBodyHeight = ancestorRect.height / bodyHeight;
          if (portionOfBodyWidth < .3 && ancestorRect.height > 2 * ancestorRect.width) {
            // We're in a tall container -- probably a sidebar
            isInWideContainer = 0;
            scoreInfo.isInTallAndNarrowContainer = 1;
            scoreInfo.skip = ancestor;
            // Skip past the rest of this
            break;
          }
          if (portionOfBodyWidth > .5 && portionOfBodyWidth < .95) {
            isWide = 1;
          }
          if (portionOfBodyHeight > .75 && portionOfBodyHeight < .95) {
            isTall = 1;
          }
          ancestor = ancestor.parentNode;
        }
        scoreInfo.isInTallAndWideContainer = isInWideContainer && isInTallContainer;
        scoreInfo.score = !scoreInfo.isAtTopOfScreen + !scoreInfo.isAtTopOfDoc + scoreInfo.isOnTopHalfOfScreen + scoreInfo.isPartlyBelowBottom * -2 + scoreInfo.isMostlyBelowBottom * -2 + scoreInfo.headingScore + 2 * scoreInfo.hasSignificantText + 2 * scoreInfo.isInMainContent + scoreInfo.hasBadAriaRole * -3 + scoreInfo.isInTallAndNarrowContainer * -4 + 2 * scoreInfo.isInTallAndWideContainer;
        if (true && isAutoPickDebuggingOn) {
          console.log("%d: %o", scoreInfo.score, picked[0]);
          console.log("   %O %s", scoreInfo, picked.text().substr(0, 30).trim());
        }
        return scoreInfo;
      }
      // -------------- Customizations ----------------------
      // See https://equinox.atlassian.net/wiki/display/EN/Picker+hints+and+customizations
      // This is a hook for customization scripts, which can add their own judgements by overriding this method.
      function provideCustomSelectors(selectors) {
        customSelectors = selectors;
      }
      // This is a hook for customization scripts, which can add their own judgements by overriding this method.
      // Weights can be changed for pre-existing or added for custom judgements
      // Pass in as { judgementName: weightValue, judgementName2: weightValue2, etc. }
      function provideCustomWeights(weights) {
        $.extend(judgementWeights, weights);
      }
      // Return true if the element is part of the sitecues user interface
      // Everything inside the <body> other than the page-inserted badge
      function isInSitecuesUI(node) {
        var element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentNode;
        // Is not in the <body> (must also check clone body)
        return !$(element).closest("body").length || $(element).closest("#sitecues-badge,#scp-bp-container").length;
      }
      if (true) {
        // --- For debugging ----------------------
        sitecues.pickFrom = function(element) {
          return find(element);
        };
        sitecues.togglePickerDebugging = function() {
          console.log("Picker debugging: " + (isDebuggingOn = !isDebuggingOn));
        };
        sitecues.togglePickerVoteDebugging = function() {
          console.log("Picker vote debugging: " + (isVoteDebuggingOn = !isVoteDebuggingOn));
        };
        sitecues.togglePickerVoting = function() {
          console.log("Picker voting: " + (isVotingOn = !isVotingOn));
        };
        sitecues.toggleAutoPickDebugging = function() {
          console.log("Auto pick debugging: " + (isAutoPickDebuggingOn = !isAutoPickDebuggingOn));
        };
      }
      return {
        find: find,
        reset: reset,
        getAutoPickScore: getAutoPickScore,
        provideCustomSelectors: provideCustomSelectors,
        provideCustomWeights: provideCustomWeights
      };
    }($, page_util_common, run_conf_preferences, run_conf_site, page_highlight_traitcache, page_highlight_traits, page_highlight_judge, mini_core_native_global, run_inline_style_inline_style, run_platform);
    page_util_geo = function() {
      /**
   * Is the point inside the rectangle or within proximity pixels
   * @access public
   * @param x
   * @param y
   * @param rect
   * @param proximity (optional) Number of pixels of extra proximity allowed
   * @returns {boolean}
   */
      function isPointInRect(x, y, rect, proximity) {
        proximity = proximity || 0;
        var right = rect.left + rect.width, bottom = rect.top + rect.height;
        return x >= rect.left - proximity && x < right + proximity && y >= rect.top - proximity && y <= bottom + proximity;
      }
      /**
   * Is the point inside any of the supplied rectangles or within proximity pixels
   * @access public
   * @param x
   * @param y
   * @param rects
   * @param proximity (optional) Number of pixels of extra proximity allowed
   * @returns {boolean}
   */
      function isPointInAnyRect(x, y, rects, proximity) {
        for (var count = 0; count < rects.length; count++) {
          if (rects[count] && isPointInRect(x, y, rects[count], proximity)) {
            return true;
          }
        }
        return false;
      }
      /**
   * Expand or contract rectangle
   * @access public
   * @param rect  Original rectangle
   * @param delta  Positive value to expand rectangle, or negative to contract
   * @returns Object new rectangle
   */
      function expandOrContractRect(rect, delta) {
        var newRect = {
          left: rect.left - delta,
          top: rect.top - delta,
          width: rect.width + 2 * delta,
          height: rect.height + 2 * delta
        };
        newRect.right = newRect.left + newRect.width;
        newRect.bottom = newRect.top + newRect.height;
        return newRect;
      }
      /**
   * Expand or contract an array of rects
   * @access public
   * @param [] rects
   * @param delta
   */
      function expandOrContractRects(rects, delta) {
        var numRects = rects.length, index = 0;
        for (;index < numRects; index++) {
          rects[index] = expandOrContractRect(rects[index], delta);
        }
      }
      return {
        isPointInRect: isPointInRect,
        isPointInAnyRect: isPointInAnyRect,
        expandOrContractRect: expandOrContractRect,
        expandOrContractRects: expandOrContractRects
      };
    }();
    page_highlight_constants = function() {
      var constants = {};
      constants.HIGHLIGHT_OUTLINE_CLASS = "sc-highlight";
      constants.HIGHLIGHT_OUTLINE_ATTR = "data-sc-overlay";
      constants.HIGHLIGHT_STYLESHEET_NAME = "sitecues-js-highlight";
      constants.HIGHLIGHT_TOGGLE_EVENT = "mh/did-toggle-visibility";
      constants.POINTER_ATTR = "data-sc-pointer-events";
      return constants;
    }();
    page_highlight_highlight = function($, pref, picker, traitcache, mhpos, common, colorUtil, geo, elementClassifier, platform, constants, events, domEvents, zoomMod, bodyGeo, nativeGlobal, inlineStyle) {
      var isInitialized, state, // We don't initialize this module until sitecues is on
      isTrackingMouse, // After scroll tracking is turned on, we won't respond to it until at least one normal mousemove
      isTrackingWheelEvents, isOnlyShift, // Is shift down by itself?
      isAppropriateFocus, isSticky, isSitecuesUIOpen, isLensEnabled, isColorDebuggingOn, isHighlightRectDebuggingOn, $highlightStyleSheet, // Style sheet for overlay via :after
      pickFromMouseTimer, INIT_STATE = {
        isCreated: false,
        // Has highlight been created
        isVisible: false,
        // Is highlight visible?
        picked: null,
        // JQuery for picked element(s)
        target: null,
        // Mouse was last over this element
        styles: [],
        savedCss: null,
        // map of saved CSS for highlighted element
        savedBgColors: null,
        // map of descendant elements to saved background colors
        elementRect: null,
        // Bounding client rect (fixed/screen rect) of picked element
        fixedContentRect: null,
        // Contains the smallest possible rectangle encompassing the content to be highlighted
        hiddenElements: [],
        // Elements whose subtrees are hidden or not part of highlight rectangle (e.g. display: none, hidden off-the-page, out-of-flow)
        overlayContainer: null,
        // The scrollable container that will contain the highlight overlay as a child
        // Note however, that the coordinates used are zoomed pixels (at 1.1x a zoomed pixel width is 1.1 real pixels)
        overlayRect: null,
        // Contains the total overlay rect, in absolute body coordinates,  zoomed pixels
        cutoutRects: {},
        // Object map for possible topLeft, topRight, botLeft, botRight of rectangles cut out of highlight to create L shape
        pathBorder: [],
        // In real pixels so that it can live outside of <body>
        pathFillPadding: [],
        // In real pixels outside <body>, extends CSS background beyond element
        pathFillBackground: [],
        // In element rect coordinates, used with CSS background
        highlightPaddingWidth: 0,
        highlightBorderWidth: 0,
        highlightBorderColor: "",
        bgColor: "",
        // highlight color or '' if only outline is being used (as when highlighting media element)
        doUseOverlayforBgColor: false,
        // was an overlay used to create the background color? If not, CSS background will be used.
        hasDarkBackgroundColor: false,
        hasLightText: false
      }, // class of highlight
      HIGHLIGHT_OUTLINE_CLASS = constants.HIGHLIGHT_OUTLINE_CLASS, HIGHLIGHT_OUTLINE_ATTR = constants.HIGHLIGHT_OUTLINE_ATTR, HIGHLIGHT_STYLESHEET_NAME = constants.HIGHLIGHT_STYLESHEET_NAME, //Highlight event
      HIGHLIGHT_TOGGLE_EVENT = constants.HIGHLIGHT_TOGGLE_EVENT, // How many ms does mouse need to stop for before we highlight?
      MOUSE_STOP_MS = 30, // How many ms does scrolling need to stop for before we highlight?
      SCROLL_STOP_MS = 140, // Color values for YIQ computations
      MID_COLOR_INTENSITY = .62, // Don't consider the text light unless the yiq is larger than this
      VERY_DARK_COLOR_INTENSITY = .06, VERY_LIGHT_COLOR_INTENSITY = .94, // Extra border width in pixels if background is dark and light bg color is being used
      EXTRA_DARK_BG_BORDER_WIDTH = 1, // Extra room around highlight
      EXTRA_PIXELS_TO_PRESERVE_LETTERS = 1, // Amount of extra space computed for fixed highlight rectangles
      EXTRA_PADDING_PIXELS = 4, // Amount of space around highlighted object before to separate border
      // Border color when on dark background
      DARK_BG_BORDER_COLOR = "#bec36e", // All CSS background properties except color
      // Image must be listed last for multiple backgrounds code to work
      BG_PROPS = [ "backgroundPosition", "backgroundOrigin", "backgroundRepeat", "backgroundClip", "backgroundAttachment", "backgroundSize", "backgroundImage" ], isSitecuesOn = true, // Are we currently tracking the mouse?
      canTrackScroll = true, // Is scroll tracking allowable? Turned off during panning from keyboard navigation
      willRespondToScroll = true, isWindowFocused = document.hasFocus(), isSpeechEnabled = false, cursorPos = {};
      function getMaxZIndex(styles) {
        var maxZIndex = 0;
        for (var count = 0; count < styles.length; count++) {
          var zIndexInt = parseInt(styles[count].zIndex);
          if (zIndexInt > maxZIndex) {
            maxZIndex = zIndexInt;
          }
        }
        return maxZIndex;
      }
      function isDifferentZIndex(item1, item2, commonAncestor) {
        function getZIndex(item) {
          var styles = getAncestorStyles(item, commonAncestor);
          return getMaxZIndex(styles);
        }
        return getZIndex(item1) !== getZIndex(item2);
      }
      /**
   * Checks if the color value given of a light tone or not.
   */
      function isLightIntensity(colorValue) {
        return colorUtil.getLuminanceFromColorName(colorValue) > MID_COLOR_INTENSITY;
      }
      function getElementsContainingOwnVisibleText($subtree) {
        var TEXT_NODE = 3;
        return $subtree.filter(function() {
          var index, testNode, css, childNodes = this.childNodes, numChildNodes = childNodes.length;
          if (this.childElementCount === numChildNodes) {
            return false;
          }
          css = traitcache.getStyle(this);
          if (parseInt(css.textIndent) < -99) {
            return false;
          }
          for (index = 0; index < numChildNodes; index++) {
            testNode = childNodes[index];
            if (testNode.nodeType === TEXT_NODE && "" !== testNode.textContent.trim()) {
              return true;
            }
          }
          return false;
        });
      }
      function getTextInfo(selector) {
        var $subtree = $(selector).find("*").addBack(), textContainers = getElementsContainingOwnVisibleText($subtree), elementsToCheck = textContainers.length ? textContainers : $subtree, MAX_ELEMENTS_TO_CHECK = 100, containsLightText = false, containsDarkText = false;
        elementsToCheck.each(function(index) {
          if (index >= MAX_ELEMENTS_TO_CHECK) {
            return false;
          }
          var textColor = traitcache.getStyleProp(this, "color");
          if (isLightIntensity(textColor)) {
            containsLightText = true;
          } else {
            containsDarkText = true;
          }
        });
        return {
          hasLightText: containsLightText,
          hasDarkText: containsDarkText,
          hasVisibleText: textContainers.length > 0
        };
      }
      function hasDarkBackgroundOnAnyOf(styles, textInfo) {
        var hasOnlyLightText = textInfo.hasLightText && !textInfo.hasDarkText, count = 0;
        for (;count < styles.length; count++) {
          var style = styles[count], bgRgba = colorUtil.getRgba(style.backgroundColor), isMostlyOpaque = bgRgba.a > .8;
          if (style.backgroundImage && "none" !== style.backgroundImage) {
            if (hasOnlyLightText) {
              return true;
            }
            if (!textInfo.hasVisibleText) {}
          }
          if (isMostlyOpaque) {
            return !isLightIntensity(bgRgba);
          }
        }
      }
      function updateColorApproach(picked, style) {
        // Get data on backgrounds and text colors used
        var textInfo = getTextInfo(picked);
        state.hasLightText = textInfo.hasLightText;
        state.hasDarkText = textInfo.hasDarkText;
        state.hasDarkBackgroundColor = hasDarkBackgroundOnAnyOf(style, textInfo);
        // Get the approach used for highlighting
        if (picked.length > 1 || shouldAvoidBackgroundImage(picked) || state.hasLightText || !textInfo.hasVisibleText) {
          //  approach #1 -- use overlay for background color
          //                 use overlay for rounded outline
          //  pros: one single rectangle instead of potentially many
          //        works with form controls
          //        visually seamless
          //  cons: washes dark text out (does not have this problem with light text)
          //  when-to-use: for article or cases where multiple items are selected
          //               when images or background sprites are used, which we don't want to overwrite with out background
          //               a lack of text indicates a good opportunity to use technique as it is an indicator of image content
          state.bgColor = getTransparentBackgroundColor();
          state.doUseOverlayForBgColor = true;
        } else {
          //  approach #2 -- use css background of highlighted element for background color
          //                use overlay for rounded outline
          //  pros: looks best on text, does not wash out colors
          //  cons: breaks the appearance of native form controls, such as <input type="button">
          //  when-to-use: on most elements
          state.bgColor = getAppropriateBackgroundColor();
          state.doUseOverlayForBgColor = false;
        }
      }
      // How visible is the highlight?
      // Currently goes from 1.44 (at 1x) to 3.24 (at 3x)
      // The smaller the number, the less visible the highlight is
      function getHighlightVisibilityFactor() {
        var MIN_VISIBILITY_FACTOR_WITH_TTS = 2.1, vizFactor = .9 * (zoomMod.getCompletedZoom() + .6);
        if (isSpeechEnabled && vizFactor < MIN_VISIBILITY_FACTOR_WITH_TTS) {
          vizFactor = MIN_VISIBILITY_FACTOR_WITH_TTS;
        }
        return vizFactor;
      }
      function getHighlightBorderColor() {
        if (state.hasDarkBackgroundColor) {
          return DARK_BG_BORDER_COLOR;
        }
        var viz = state.highlightIntensity, colorMultiplier = -80, color = Math.round(Math.max(0, 200 + viz * colorMultiplier));
        return "rgb(" + color + "," + color + "," + (color + 30) + ")";
      }
      function getHighlightBorderWidth() {
        var viz = state.highlightIntensity, borderWidth = viz + .33 + (state.hasDarkBackgroundColor ? EXTRA_DARK_BG_BORDER_WIDTH : 0);
        return Math.max(1, borderWidth) * state.zoom;
      }
      function getTransparentBackgroundColor() {
        // Best to use transparent color when the background is interesting or dark, and we don't want to
        // change it drastically
        // This lightens at higher levels of zoom
        var maxViz = state.hasDarkBackgroundColor || state.hasLightText ? 1 : 9, viz = Math.min(state.highlightIntensity, maxViz), alpha = .11 * viz;
        return "rgba(240, 240, 180, " + alpha + ")";
      }
      function getOpaqueBackgroundColor() {
        // Best to use opaque color, because inner overlay doesn't match up perfectly causing overlaps and gaps
        // It lightens at higher levels of zoom
        var viz = state.highlightIntensity, decrement = 1.4 * viz, red = Math.round(255 - decrement), green = red, blue = Math.round(254 - 5 * decrement), color = "rgb(" + red + "," + green + "," + blue + ")";
        return color;
      }
      // Return an array of styles in the ancestor chain, including fromElement, not including toElement
      function getAncestorStyles(fromElement, toElement) {
        var styles = [];
        while (fromElement) {
          styles.push(traitcache.getStyle(fromElement));
          if (fromElement === toElement) {
            break;
          }
          fromElement = fromElement.parentElement;
        }
        return styles;
      }
      function getCutoutRectsArray() {
        return [ state.cutoutRects.topLeft, state.cutoutRects.topRight, state.cutoutRects.botLeft, state.cutoutRects.botRight ];
      }
      function isCursorInHighlightShape(fixedRects, cutoutRects) {
        if (!cursorPos.doCheckCursorInHighlight) {
          return true;
        }
        var extraPixels = getExtraPixels() * state.zoom;
        if (!geo.isPointInAnyRect(cursorPos.x, cursorPos.y, fixedRects, extraPixels)) {
          return false;
        }
        // The cursor is in the fixed rectangle for the highlight.
        // Now, we will consider the cursor to be in the highlight as long as it's not in any
        // parts cut out from the highlight when it is drawn around floats.
        return !geo.isPointInAnyRect(cursorPos.x, cursorPos.y, cutoutRects);
      }
      // Update mouse highlight view and show unless doKeepHidden is truthy
      // return true if something is shown
      function updateView(doKeepHidden) {
        // can't find any element to work with
        if (!state.picked) {
          return;
        }
        // Update state to ensure it is current
        state.styles = getAncestorStyles(state.picked[0], document.documentElement);
        state.highlightIntensity = getHighlightVisibilityFactor();
        updateColorApproach(state.picked, state.styles);
        if (!computeOverlay(true)) {
          // Did not find visible rectangle to highlight
          return;
        }
        // Show the actual overlay
        if (!doKeepHidden) {
          show();
        }
        return true;
      }
      function didToggleVisibility(isVisible) {
        state.isVisible = isVisible;
        events.emit(HIGHLIGHT_TOGGLE_EVENT, isVisible);
      }
      function show() {
        // Create and position highlight overlay
        appendOverlayPathViaSVG();
        // Remove conflicting backgrounds on descendants
        removeConflictingDescendantBackgrounds();
        // Position overlay just on top of the highlighted element (and underneath fixed toolbars)
        // Change background image for highlighted elements if necessary
        updateElementBgImage();
        // Add event listeners to keep overlay view up-to-date
        addMouseWheelListener();
        addEventListener("mouseout", onLeaveWindow, {
          passive: true
        });
        // Update state
        didToggleVisibility(true);
        // Get Lens code loaded and ready so that it shows up quickly the first time
        if (!isLensEnabled) {
          isLensEnabled = true;
        }
      }
      // Choose an appropriate background color for the highlight
      // In most cases we want the opaque background because the background color on the element
      // can overlap the padding over the outline which uses the same color, and not cause problems
      // We need them to overlap because we haven't found a way to 'sew' them together in with pixel-perfect coordinates
      function getAppropriateBackgroundColor() {
        if (state.hasDarkBackgroundColor || state.hasLightText) {
          // Use transparent background so that the interesting background or light foreground are still visible
          return getTransparentBackgroundColor();
        }
        return getOpaqueBackgroundColor();
      }
      // Helps with SC-1471, visually seamless highlight rectangle
      function roundCoordinate(n) {
        return Math.round(n);
      }
      function roundBorderWidth(n) {
        return roundCoordinate(n);
      }
      function roundRectCoordinates(rect) {
        var newRect = {
          top: roundCoordinate(rect.top),
          bottom: roundCoordinate(rect.bottom),
          left: roundCoordinate(rect.left),
          right: roundCoordinate(rect.right)
        };
        newRect.width = newRect.right - newRect.left;
        newRect.height = newRect.bottom - newRect.top;
        return newRect;
      }
      function roundPolygonCoordinates(points) {
        var point, index = 0, numPoints = points.length;
        for (;index < numPoints; index++) {
          point = points[index];
          point.x = roundCoordinate(point.x);
          point.y = roundCoordinate(point.y);
        }
      }
      function setMultipleBackgrounds(element, newBg, origBg, doPlaceOrigOnTop) {
        var value, hasOrigBgImage = "none" !== origBg.backgroundImage, styles = {};
        BG_PROPS.forEach(function(property) {
          if (!hasOrigBgImage) {
            value = newBg[property];
          } else {
            if (doPlaceOrigOnTop) {
              value = origBg[property] + "," + newBg[property];
            } else {
              value = newBg[property] + "," + newBg[property];
            }
          }
          styles[property] = value;
        });
        inlineStyle.override(element, styles);
      }
      function copyBackgroundCss(origElem) {
        var copy = {}, style = inlineStyle(origElem);
        BG_PROPS.forEach(function(property) {
          copy[property] = style[property].slice();
        });
        return copy;
      }
      // width and height are optional
      function getSVGDataURI(svgMarkup, width, height) {
        var attrs = width ? ' width="' + width + '" height="' + height + '" ' : "", wrappedSvg = '<svg xmlns="http://www.w3.org/2000/svg"' + attrs + ">" + svgMarkup + "</svg>";
        // Use encodeURIComponent instead of encodeURI because we also want # -> %23,
        // otherwise Firefox is unhappy when we set the fill color
        return 'url("data:image/svg+xml,' + encodeURIComponent(wrappedSvg) + '")';
      }
      function updateElementBgImage() {
        var offsetLeft, offsetTop, element = state.picked[0];
        // Approach #1 -- no change to background of element
        if (state.doUseOverlayForBgColor) {
          return false;
        }
        // Approach #2 --change CSS background of highlighted element
        var newBgSize, path = getAdjustedPath(state.pathFillBackground, state.fixedContentRect.left, state.fixedContentRect.top, 0, state.zoom), bgColor = true && isColorDebuggingOn ? "rgba(0,255,255,.4)" : state.bgColor, bgPaintableWidth = state.fixedContentRect.width, bgPaintableHeight = state.fixedContentRect.height, // Get the rectangle for the element itself
        svgMarkup = getSVGForPath(path, 0, 0, bgColor, 1);
        // Use element rectangle to find origin (left, top) of background
        // The background is getting clipped before being offset to the left
        offsetLeft = state.fixedContentRect.left - state.elementRect.left;
        if (offsetLeft < 0) {
          bgPaintableWidth += offsetLeft;
          offsetLeft = 0;
        }
        offsetTop = state.fixedContentRect.top - state.elementRect.top;
        if (offsetTop < 0) {
          bgPaintableHeight += offsetTop;
          offsetTop = 0;
        }
        bgPaintableWidth = Math.min(bgPaintableWidth + state.zoom, state.elementRect.width);
        bgPaintableHeight = Math.min(bgPaintableHeight + state.zoom, state.elementRect.height);
        newBgSize = roundCoordinate(bgPaintableWidth / state.zoom) + "px " + roundCoordinate(bgPaintableHeight / state.zoom) + "px";
        offsetLeft = roundCoordinate(offsetLeft);
        offsetTop = roundCoordinate(offsetTop);
        // This only returns a non-zero value when there is an offset to the current element, try highlighting "Welcome to Bank of North America" on the eBank test site.
        var origBgStyle = traitcache.getStyle(element), newBgStyle = {
          backgroundImage: getSVGDataURI(svgMarkup),
          backgroundPosition: offsetLeft / state.zoom + "px " + offsetTop / state.zoom + "px",
          backgroundOrigin: "border-box",
          backgroundRepeat: "no-repeat",
          backgroundClip: "border-box",
          backgroundAttachment: "scroll",
          backgroundSize: newBgSize
        }, doPlaceOrigOnTop = common.isSprite(origBgStyle);
        // Place sprites on top of our background, and textures underneath it
        // Save the current inline style for later restoration when the highlight is hidden
        state.savedCss = copyBackgroundCss(element);
        // Set the new background
        setMultipleBackgrounds(element, newBgStyle, origBgStyle, doPlaceOrigOnTop);
      }
      function isCloseToHighlightColor(colorIntensity) {
        if (state.hasDarkBackgroundColor) {
          // On dark background, using dark highlight
          return colorIntensity < VERY_DARK_COLOR_INTENSITY;
        } else {
          // On light background, using light highlight
          return colorIntensity > VERY_LIGHT_COLOR_INTENSITY;
        }
      }
      // Check all descendants for redundant background colors that will
      // carve chunks out of the highlight color.
      // For example, a theme on perkins.org that sets white backgrounds on many elements.
      // When we highlight an ancestor of one of those elements, we need to temporarily set
      // the background to transparent so that the highlight color can show through
      function removeConflictingDescendantBackgrounds() {
        if (state.doUseOverlayForBgColor) {
          return;
        }
        if (null !== state.savedBgColors) {
          return;
        }
        state.savedBgColors = [];
        state.picked.find("*").each(function() {
          var bgRgba, colorIntensity, style = traitcache.getStyle(this), bgColor = style.backgroundColor;
          if ("none" === style.backgroundImage) {
            bgRgba = colorUtil.getRgba(bgColor);
            colorIntensity = colorUtil.getPerceivedLuminance(bgColor);
            if (1 === bgRgba.a && isCloseToHighlightColor(colorIntensity) && !common.hasOwnBackgroundColor(this, style, state.styles[0])) {
              // If it's a unique color, we want to preserve it
              state.savedBgColors.push({
                elem: this,
                color: inlineStyle(this).backgroundColor
              });
              // Needed to do this as !important because of Perkins.org theme which also used !important
              inlineStyle.override(this, [ "background-color", "transparent", "important" ]);
            }
          }
        });
      }
      function getCutoutRectForPoint(x, y, expandFloatRectPixels, typeIfFloatRectShorter, typeIfFloatRectTaller) {
        var possibleFloat = common.elementFromPoint(x, y), // Get from top-left or top-right of highlight
        $picked = state.picked;
        if (possibleFloat && possibleFloat !== $picked[0]) {
          var $pickedAncestors = $picked.parents(), $possibleFloatAncestors = $(possibleFloat).parents();
          if ($pickedAncestors.is(possibleFloat)) {
            // TODO commenting out second part cells in boxes at
            // http://venturebeat.com/2014/10/01/after-raising-50m-reddit-forces-remote-workers-to-relocate-to-sf-or-get-fired/
            // If potential float is ancestor of picked don't use it.
            // However, the picked element could be an ancestor of the float, and we still need to use it.
            // Example: http://thebillfold.com/2014/09/need-an-action-figure-of-a-dead-loved-one-meet-jeff-staab/
            return;
          }
          var commonAncestor = $possibleFloatAncestors.is($picked) ? $picked : $(possibleFloat).closest($pickedAncestors);
          if (isDifferentZIndex(possibleFloat, $picked[0], commonAncestor)) {
            return;
          }
          while (commonAncestor[0] !== possibleFloat && !$(possibleFloat).is("body,html")) {
            if ("none" !== traitcache.getStyleProp(possibleFloat, "float")) {
              var floatRect = mhpos.getRect(possibleFloat), mhRect = state.fixedContentRect, extra = getExtraPixels();
              if (!floatRect) {
                return;
              }
              floatRect = roundRectCoordinates(floatRect);
              var results = {};
              if (floatRect.left > mhRect.left - extra && floatRect.right <= mhRect.right + extra && floatRect.top >= mhRect.top - extra && floatRect.bottom <= mhRect.bottom + extra) {
                // Completely inside highlight rect -- don't bother
                if (mhRect.bottom === floatRect.bottom) {
                  // Float is taller than the rect
                  // and we likely need to bottom-right or bottom-left cut out.
                  // If the float is to the right, we will be cutting out the bottom-left, and
                  // if the float is to the left, we will be cutting out the bottom-right!!!
                  // We can compute this by comparing the bottom if the highlight rect
                  // with and without floats included. If the highlight rect would be taller
                  // when floats are included, then we will make a bottom cutout next to the bottom of the float,
                  // on the other side of the highlight.
                  var cutoutRect, mhRectWithoutFloats = mhpos.getRect($picked, true) || mhRect, top = mhRectWithoutFloats.bottom + expandFloatRectPixels;
                  if (top > mhRect.bottom - extra) {
                    return;
                  }
                  cutoutRect = {
                    top: top,
                    left: -9999,
                    bottom: 9999,
                    right: 9999
                  };
                  if ("botRight" === typeIfFloatRectTaller) {
                    cutoutRect.left = floatRect.right + expandFloatRectPixels;
                  } else {
                    cutoutRect.right = floatRect.left - expandFloatRectPixels;
                  }
                  cutoutRect.height = cutoutRect.bottom - cutoutRect.top;
                  cutoutRect.width = cutoutRect.right - cutoutRect.left;
                  results[typeIfFloatRectTaller] = cutoutRect;
                }
              } else {
                // float is shorter than highlight rect
                results[typeIfFloatRectShorter] = geo.expandOrContractRect(floatRect, expandFloatRectPixels);
              }
              return results;
            }
            possibleFloat = possibleFloat.parentNode;
          }
        }
      }
      // Get rects of cutouts caused fy floats intersecting with the original highlight rect.
      function getCutoutRects() {
        var EXTRA = 7, // Make sure we test a point inside where the float would be, not on a margin
        EXPAND_FLOAT_RECT = 7, mhRect = state.fixedContentRect, left = mhRect.left, right = mhRect.left + mhRect.width, top = mhRect.top, // If there's a left float, rect1 will be top-left, unless the float is taller than
        // everything else in the highlight, and then it will be bot-right
        rect1 = getCutoutRectForPoint(left + EXTRA, top + EXTRA, EXPAND_FLOAT_RECT, "topLeft", "botRight"), // If there's a right float, rect2 will be top-right, unless the float is taller than
        // everything else in the highlight, and then it will be bot-left
        rect2 = getCutoutRectForPoint(right - EXTRA, top + EXTRA, EXPAND_FLOAT_RECT, "topRight", "botLeft");
        return $.extend({}, rect1, rect2);
      }
      function extendAll(array, newProps) {
        for (var index = 0; index < array.length; index++) {
          array[index] = $.extend(array[index], newProps);
        }
        return array;
      }
      function getPolygonPoints(orig) {
        // Build points for highlight polygon
        var // Shortcuts
        topLeftCutout = state.cutoutRects.topLeft, topRightCutout = state.cutoutRects.topRight, botLeftCutout = state.cutoutRects.botLeft, botRightCutout = state.cutoutRects.botRight, // List of points for each corner
        // We start out with one point, but if a cutout intersects, we will end up with 3 points for that corner
        topLeftPoints = [ {
          x: orig.left,
          y: orig.top
        } ], topRightPoints = [ {
          x: orig.right,
          y: orig.top
        } ], botRightPoints = [ {
          x: orig.right,
          y: orig.bottom
        } ], botLeftPoints = [ {
          x: orig.left,
          y: orig.bottom
        } ], mhRect = state.fixedContentRect;
        if (topLeftCutout) {
          if (!geo.isPointInRect(topLeftCutout.right, topLeftCutout.bottom, mhRect)) {
            if (topLeftCutout.right > orig.left && topLeftCutout.bottom > orig.bottom) {
              // Sanity check
              topLeftPoints[0].x = topLeftCutout.right;
              botLeftPoints[0].x = topLeftCutout.right;
            }
          } else {
            // Draw around top-left float
            topLeftPoints = [ {
              x: orig.left,
              y: topLeftCutout.bottom
            }, {
              x: topLeftCutout.right,
              y: topLeftCutout.bottom
            }, {
              x: topLeftCutout.right,
              y: orig.top
            } ];
          }
        }
        if (topRightCutout) {
          if (!geo.isPointInRect(topRightCutout.left, topRightCutout.bottom, mhRect)) {
            if (topRightCutout.left < orig.right && topRightCutout.bottom > orig.bottom) {
              // Sanity check
              topRightPoints[0].x = topRightCutout.left;
              botRightPoints[0].x = topRightCutout.left;
            }
          } else {
            // Draw around top-right float
            topRightPoints = [ {
              x: topRightCutout.left,
              y: orig.top
            }, {
              x: topRightCutout.left,
              y: topRightCutout.bottom
            }, {
              x: orig.right,
              y: topRightCutout.bottom
            } ];
          }
        }
        if (botRightCutout) {
          botRightPoints = [ {
            x: orig.right,
            y: botRightCutout.top
          }, {
            x: botRightCutout.left,
            y: botRightCutout.top
          }, {
            x: botRightCutout.left,
            y: orig.bottom
          } ];
        }
        if (botLeftCutout) {
          botLeftPoints = [ {
            x: botLeftCutout.right,
            y: orig.bottom
          }, {
            x: botLeftCutout.right,
            y: botLeftCutout.top
          }, {
            x: orig.left,
            y: botLeftCutout.top
          } ];
        }
        // growX and growY are set to 1 or -1, depending on which direction coordinates should move when polygon grows
        extendAll(topLeftPoints, {
          growX: -1,
          growY: -1
        });
        extendAll(topRightPoints, {
          growX: 1,
          growY: -1
        });
        extendAll(botRightPoints, {
          growX: 1,
          growY: 1
        });
        extendAll(botLeftPoints, {
          growX: -1,
          growY: 1
        });
        return topLeftPoints.concat(topRightPoints, botRightPoints, botLeftPoints);
      }
      function getExpandedPath(points, delta) {
        var newPath = [];
        for (var index = 0; index < points.length; index++) {
          newPath.push({
            x: roundCoordinate(points[index].x + points[index].growX * delta),
            y: roundCoordinate(points[index].y + points[index].growY * delta),
            growX: points[index].growX,
            growY: points[index].growY
          });
        }
        return newPath;
      }
      // Scale and move a path
      function getAdjustedPath(origPath, offsetX, offsetY, extra, divisor) {
        var newPath = [];
        $.each(origPath, function() {
          newPath.push($.extend({}, this, {
            x: (this.x - offsetX) / divisor + extra,
            y: (this.y - offsetY) / divisor + extra
          }));
        });
        return newPath;
      }
      function getSVGStyle(strokeWidth, strokeColor, fillColor) {
        return ' style="pointer-events:none;stroke-width: ' + strokeWidth + ";" + (strokeWidth ? "stroke: " + strokeColor + ";" : "") + "fill: " + (fillColor ? fillColor : "none") + '"';
      }
      function getSVGForPath(points, strokeWidth, strokeColor, fillColor, radius) {
        var svgBuilder = '<path d="';
        var count = 0;
        do {
          // Start of vertical line (except for first time)
          var vertCornerDir = 0 === count ? 1 : points[count].y > points[count - 1].y ? -1 : 1;
          var horzCornerDir = points[(count + 1) % points.length].x > points[count].x ? 1 : -1;
          svgBuilder += (count ? "L " : "M ") + points[count].x + " " + (points[count].y + radius * vertCornerDir) + " ";
          svgBuilder += "Q " + // Curved corner
          points[count].x + " " + points[count].y + " " + (points[count].x + radius * horzCornerDir) + " " + points[count].y + " ";
          ++count;
          // Start of horizontal line
          vertCornerDir = points[(count + 1) % points.length].y > points[count].y ? 1 : -1;
          horzCornerDir = points[count].x > points[count - 1].x ? -1 : 1;
          svgBuilder += "L " + (points[count].x + radius * horzCornerDir) + " " + points[count].y + " ";
          svgBuilder += "Q " + // Curved corner
          points[count].x + " " + points[count].y + " " + // Control point
          points[count].x + " " + (points[count].y + radius * vertCornerDir) + " ";
          ++count;
        } while (count < points.length);
        svgBuilder += ' Z"' + getSVGStyle(strokeWidth, strokeColor, fillColor) + "/>";
        return svgBuilder;
      }
      function getSVGFillRectMarkup(left, top, width, height, fillColor) {
        var zoom = state.zoom;
        return '<rect x="' + left / zoom + '" y="' + top / zoom + '"  width="' + width / zoom + '" height="' + height / zoom + '"' + getSVGStyle(0, 0, fillColor) + "/>";
      }
      function isPossibleBullet() {
        var style = state.styles[0];
        return "none" !== style.listStyleType || "none" !== style.listStyleImage;
      }
      function getExtraPaddingColor() {
        if (true && isColorDebuggingOn) {
          return "rgba(255, 96, 0, .4)";
        }
        return getTransparentBackgroundColor();
      }
      // For areas such as list bullet area, when it is inside margin instead of element bounds, and thus couldn't be covered with bg image
      function getSVGForExtraPadding(extra) {
        var topOffset, useColor, highlightBgScreenRect = state.fixedContentRect, // Scaled by zoom
        svg = "", paddingColor = getExtraPaddingColor(), elementRect = roundRectCoordinates(state.picked[0].getBoundingClientRect()), REMOVE_GAPS_FUDGE_FACTOR = 0, extraLeft = elementRect.left - highlightBgScreenRect.left, extraRight = highlightBgScreenRect.right - elementRect.right, bgOffsetTop = Math.max(0, state.fixedContentRect.top - state.elementRect.top), // Don't be fooled by bottom-right cutouts
        extraTop = Math.max(0, elementRect.top - highlightBgScreenRect.top), extraBottom = Math.max(0, highlightBgScreenRect.bottom - elementRect.bottom), paddingWidth = highlightBgScreenRect.width, paddingHeight = highlightBgScreenRect.height - extraBottom;
        if (extraLeft > 0) {
          topOffset = state.cutoutRects.topLeft ? state.cutoutRects.topLeft.height : extraTop;
          // Top-left area where the highlight is not shown
          useColor = isPossibleBullet() ? getTransparentBackgroundColor() : paddingColor;
          // Don't hide bullets
          if (paddingHeight > topOffset) {
            svg += getSVGFillRectMarkup(extra, topOffset + extra, extraLeft + REMOVE_GAPS_FUDGE_FACTOR, paddingHeight - topOffset, useColor);
          }
        }
        if (extraRight > 0) {
          topOffset = state.cutoutRects.topRight ? state.cutoutRects.topRight.height : extraTop;
          // Top-right area where the highlight is not shown
          if (paddingHeight > topOffset) {
            svg += getSVGFillRectMarkup(elementRect.width + extra + extraLeft - REMOVE_GAPS_FUDGE_FACTOR, topOffset + extra, extraRight + REMOVE_GAPS_FUDGE_FACTOR, paddingHeight - topOffset, paddingColor);
          }
        }
        if (extraTop > 0) {
          var leftCutoutWidth = state.cutoutRects.topLeft ? state.cutoutRects.topLeft.width : 0;
          var widthForTop = paddingWidth;
          if (state.cutoutRects.topRight) {
            widthForTop = state.cutoutRects.topRight.left - elementRect.left;
          }
          widthForTop -= leftCutoutWidth;
          svg += getSVGFillRectMarkup(leftCutoutWidth + extra, extra, widthForTop, extraTop + REMOVE_GAPS_FUDGE_FACTOR, paddingColor);
        }
        if (extraBottom > 0 && !state.cutoutRects.botLeft && !state.cutoutRects.botRight) {
          svg += getSVGFillRectMarkup(extra, elementRect.height + extraTop + extra - bgOffsetTop - REMOVE_GAPS_FUDGE_FACTOR, paddingWidth, extraBottom + REMOVE_GAPS_FUDGE_FACTOR, paddingColor);
        }
        return svg;
      }
      // TODO Make this robust -- what if the page itself is putting in a transform?
      function getZoom(overlayContainerElem) {
        var isFixed = "fixed" === traitcache.getStyleProp(overlayContainerElem, "position");
        if (isFixed) {
          var elemTransform = inlineStyle(overlayContainerElem).transform, scaleSplit = elemTransform.split("scale(");
          return parseFloat(scaleSplit[1]) || 1;
        }
        // Not a fixed element, so use the current zoom level on the body
        return zoomMod.getCompletedZoom();
      }
      function getOverlayRect() {
        var offsetRect, mainFixedRect = state.fixedContentRect, overlayRect = {
          left: 0,
          top: 0,
          width: mainFixedRect.width / state.zoom,
          height: mainFixedRect.height / state.zoom
        };
        if (state.overlayContainer === document.body) {
          var $measureDiv = $("<sc>").appendTo(document.body).css({
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            position: "absolute",
            display: "block"
          }), // For some reason using the <body> works better in FF version <= 32
          offsetElement = $measureDiv[0];
          offsetRect = offsetElement.getBoundingClientRect();
          $measureDiv.remove();
        } else {
          offsetRect = state.overlayContainer.getBoundingClientRect();
          var containerStyle = traitcache.getStyle(state.overlayContainer), borderTop = parseFloat(containerStyle.borderTopWidth || 0), borderLeft = parseFloat(containerStyle.borderLeftWidth || 0);
          overlayRect.left = state.overlayContainer.scrollLeft - borderLeft;
          overlayRect.top = state.overlayContainer.scrollTop - borderTop;
        }
        overlayRect.left += (mainFixedRect.left - offsetRect.left) / state.zoom;
        overlayRect.top += (mainFixedRect.top - offsetRect.top) / state.zoom;
        overlayRect.right = overlayRect.left + overlayRect.width;
        overlayRect.bottom = overlayRect.top + overlayRect.height;
        return roundRectCoordinates(overlayRect);
      }
      function getBestOverlayContainer() {
        var ancestorStyle, numAncestors = state.styles.length, ancestor = state.picked[0], index = 0;
        function hasVerticalOverflow() {
          var scrollHeight = ancestor.scrollHeight - EXTRA_PADDING_PIXELS;
          if (scrollHeight > ancestor.offsetHeight) {
            return true;
          }
          if (ancestor.parentElement !== document.body && "static" !== ancestorStyle.position && "visible" !== traitcache.getStyleProp(ancestor.parentElement, "overflowY") && scrollHeight > ancestor.parentElement.offsetHeight) {
            return true;
          }
        }
        while (++index < numAncestors - 1) {
          ancestor = ancestor.parentElement;
          ancestorStyle = state.styles[index];
          if ("fixed" === ancestorStyle.position) {
            return ancestor;
          }
          if ("absolute" === ancestorStyle.position && hasVerticalOverflow()) {
            return ancestor;
          }
          // Don't tie to horizontal scroll -- these tend to not scrolled via
          // scrollbars, etc. but rather by visible buttons in the interface, and they are often a red herring,
          // causing us to put the highlight in a container where the top or bottom will get clipped.
          // Therefore, we require containers to be vertically scrollable before we tie the highlight overlay to them,
          // after all users know how to vertically scroll with a scrollwheel etc. but they don't know how to horizontally scroll
          //        if (ancestorStyle.overflowX !== 'visible') {  // Use if horizontally scrollable
          //          var scrollWidth = ancestor.scrollWidth - EXTRA_PADDING_PIXELS;
          //          // Either this container scrolls directly or is positioned within a smaller parent
          //          if (scrollWidth > ancestor.offsetWidth || scrollWidth > ancestor.parentElement.offsetWidth) {
          //            if (SC_DEV) { console.log('Highlight overlay container - h-scroll: %o', ancestor); }
          //            return ancestor;
          //          }
          //        }
          if ("visible" !== ancestorStyle.overflowY) {
            // use if vertically scrollable
            // Either this container scrolls directly or is positioned within a smaller parent
            if (hasVerticalOverflow()) {
              if (true) {
                console.log("Highlight overlay container - v-scroll: %o", ancestor);
              }
              return ancestor;
            }
          }
        }
        return document.body;
      }
      function getAbsoluteRect() {
        var rect = $.extend({}, state.fixedContentRect), viewPos = traitcache.getCachedViewPosition();
        // Next subtract the current scroll position
        rect.left += viewPos.x;
        rect.right += viewPos.x;
        rect.top += viewPos.y;
        rect.bottom += viewPos.x;
        return rect;
      }
      // Update highlight overlay
      // @return falsey if no valid overlay can be created
      function computeOverlay() {
        var element, elementRect, stretchForSprites = true;
        if (!state.picked) {
          return;
        }
        element = state.picked[0];
        elementRect = element.getBoundingClientRect();
        // Rough bounds
        state.overlayContainer = getBestOverlayContainer();
        state.zoom = getZoom(state.overlayContainer);
        // Get exact bounds
        var mhPositionInfo = mhpos.getHighlightPositionInfo(element, 0, stretchForSprites), fixedRects = mhPositionInfo.allRects;
        state.hiddenElements = mhPositionInfo.hiddenElements;
        geo.expandOrContractRects(fixedRects, EXTRA_PIXELS_TO_PRESERVE_LETTERS);
        if (!fixedRects.length || !isCursorInHighlightShape(fixedRects, getCutoutRectsArray())) {
          // No valid highlighted content rectangles or cursor not inside of them
          return;
        }
        mhpos.combineIntersectingRects(fixedRects, 99999);
        // Merge all boxes
        var mainFixedRect = fixedRects[0];
        // For now just use 1
        state.fixedContentRect = roundRectCoordinates(mainFixedRect);
        state.elementRect = roundRectCoordinates(elementRect);
        state.highlightBorderWidth = roundBorderWidth(getHighlightBorderWidth() / state.zoom);
        state.highlightBorderColor = getHighlightBorderColor();
        state.highlightPaddingWidth = roundBorderWidth(EXTRA_PADDING_PIXELS);
        var extra = getExtraPixels();
        state.cutoutRects = getCutoutRects();
        var basePolygonPath = getPolygonPoints(state.fixedContentRect);
        // Get the path for the overlay so that the top-left corner is located at 0,0
        var adjustedPath = getAdjustedPath(basePolygonPath, state.fixedContentRect.left, state.fixedContentRect.top, extra, state.zoom);
        state.pathFillBackground = basePolygonPath;
        // Helps fill gaps
        state.pathFillPadding = getExpandedPath(adjustedPath, state.highlightPaddingWidth / 2);
        state.pathBorder = getExpandedPath(state.pathFillPadding, state.highlightPaddingWidth / 2 + state.highlightBorderWidth / 2);
        roundPolygonCoordinates(state.pathFillBackground);
        roundPolygonCoordinates(state.pathBorder);
        roundPolygonCoordinates(state.pathFillBackground);
        state.isCreated = true;
        state.overlayRect = getOverlayRect();
        state.absoluteRect = getAbsoluteRect();
        return true;
      }
      function insertOverlay(svg) {
        var extra = getExtraPixels(), width = roundCoordinate(state.fixedContentRect.width / state.zoom + 2 * extra + 1), // Extra pixel ensures right side not cut off
        height = roundCoordinate(state.fixedContentRect.height / state.zoom + 2 * extra + 1), // Extra pixel ensures bottom not cut off
        left = state.overlayRect.left - extra, top = state.overlayRect.top - extra, zIndex = getMaxZIndex(state.styles);
        if (state.overlayContainer === document.body) {
          // Body uses fast approach
          // A last child of the <body> is unlikely to mess with scripts
          appendOverlayElement(svg, left, top, width, height, zIndex);
        } else {
          // Updating the stylesheet is visibly slower on complex pages such as nytimes.com
          // So, while cleaner, it's only used if we're inserting in the middle of the document
          // where we're likely to mess something up
          updateStyleSheet(svg, left, top, width, height, zIndex);
          // Now we set the attribute (don't do it before updating the stylesheet,
          // otherwise we end up with 2 style reflows, one based on the old stylesheet contents
          // which is still around)
          state.overlayContainer.setAttribute(HIGHLIGHT_OUTLINE_ATTR, "");
        }
      }
      // Inserting actual <svg> element is faster but more obtrusive than updating
      // stylesheet to use :after. For now we only do this when the overlay parent will be <body>.
      function appendOverlayElement(svg, left, top, width, height, zIndex) {
        var svgFragment = common.createSVGFragment(svg, HIGHLIGHT_OUTLINE_CLASS);
        state.overlayContainer.appendChild(svgFragment);
        $("." + HIGHLIGHT_OUTLINE_CLASS).attr({
          width: width + "px",
          height: height + "px",
          "data-sc-reversible": false
        }).css({
          position: "absolute",
          left: left + "px",
          top: top + "px",
          zIndex: zIndex,
          pointerEvents: "none"
        });
      }
      function updateStyleSheet(svg, left, top, width, height, zIndex) {
        var svgUri = getSVGDataURI(svg, width, height), LINE_ENDING = " !important;\n", doSetPositionRelative = "static" === traitcache.getStyle(state.overlayContainer).position, styleSheetText = "[" + HIGHLIGHT_OUTLINE_ATTR + "]:after {\ncontent:" + svgUri + LINE_ENDING + "display:block" + LINE_ENDING + "visibility:visible" + LINE_ENDING + "position:absolute" + LINE_ENDING + "pointer-events:none" + LINE_ENDING + "left:" + left + "px" + LINE_ENDING + "top:" + top + "px" + LINE_ENDING + "width:" + width + "px" + LINE_ENDING + "height:" + height + "px" + LINE_ENDING + "overflow:hidden" + LINE_ENDING + "z-index:" + zIndex + LINE_ENDING + "}\n";
        if (doSetPositionRelative) {
          // Make sure child pseudo element is positioned relative to the parent
          // (We can't use position relative on the :after element because it will take up space in the layout)
          // We only need to do this when the parent doesn't already have a non-static position.
          styleSheetText += "[" + HIGHLIGHT_OUTLINE_ATTR + "] {\nposition:relative" + LINE_ENDING + "top:0" + LINE_ENDING + "left:0" + LINE_ENDING + "}";
        }
        if (!$highlightStyleSheet) {
          $highlightStyleSheet = $("<style>").appendTo("head").attr("id", HIGHLIGHT_STYLESHEET_NAME);
        }
        $highlightStyleSheet.text(styleSheetText);
      }
      function appendOverlayPathViaSVG() {
        // SVG overlays are supported
        // outlineFillColor:
        //   If the outline used used for the bg color and a bg color is being used at all
        var overlayBgColor = state.doUseOverlayForBgColor ? state.bgColor : null, // paddingColor:
        //   If overlay is used for fill color, we will put the fill in that, and don't need any padding color
        //   Otherwise, the we need the padding to bridge the gap between the background (clipped by the element) and the outline
        truePaddingColor = state.doUseOverlayForBgColor ? "" : isPossibleBullet() ? getTransparentBackgroundColor() : state.bgColor, paddingColor = true && isColorDebuggingOn ? "rgba(0, 255, 0, .4)" : truePaddingColor, paddingSVG = paddingColor ? getSVGForPath(state.pathFillPadding, state.highlightPaddingWidth, paddingColor, null, 1) : "", outlineSVG = getSVGForPath(state.pathBorder, state.highlightBorderWidth, state.highlightBorderColor, overlayBgColor, 3), // Extra padding: when there is a need for extra padding and the outline is farther away from the highlight
        // rectangle. For example, if there are list bullet items inside the padding area, this extra space needs to be filled
        extra = getExtraPixels(), extraPaddingSVG = paddingColor ? getSVGForExtraPadding(extra * state.zoom) : "", svg = outlineSVG + paddingSVG + extraPaddingSVG;
        insertOverlay(svg);
      }
      function shouldAvoidBackgroundImage(picked) {
        // Don't highlight buttons, etc. because it ruins their native appearance
        // Fix highlighting on <tr> in WebKit by using overlay for highlight color
        // See https://bugs.webkit.org/show_bug.cgi?id=9268
        function isNativeFormControl() {
          // Return true for form controls that use a native appearance
          return picked.is('input[type="button"],input[type="reset"],input[type="submit"],button,input[type="checkbox"],input[type="radio"],input[type="color"],select[size="1"],select:not([size])');
        }
        return isNativeFormControl() || picked.is("tr") && true;
      }
      // Number of pixels any edge will go beyond the fixedContentRect -- the highlight's border and padding
      function getExtraPixels() {
        return roundCoordinate(state.highlightPaddingWidth + state.highlightBorderWidth);
      }
      function correctHighlightScreenRects() {
        if (!state.isCreated) {
          return;
        }
        var newRect = roundRectCoordinates(state.picked[0].getBoundingClientRect()), oldRect = state.elementRect, xDiff = newRect.left - oldRect.left, yDiff = newRect.top - oldRect.top;
        if (!xDiff && !yDiff) {
          return;
        }
        function correctRect(rect) {
          if (!rect) {
            return;
          }
          rect.left += xDiff;
          rect.right += xDiff;
          rect.top += yDiff;
          rect.bottom += yDiff;
        }
        // -- Fixed rects --
        // These rects are in screen coordinates and must always be updated
        state.elementRect = newRect;
        correctRect(state.fixedContentRect);
        correctRect(state.cutoutRects.topLeft);
        correctRect(state.cutoutRects.topRight);
        correctRect(state.cutoutRects.botLeft);
        correctRect(state.cutoutRects.botRight);
        if (true && isHighlightRectDebuggingOn) {
          updateDebugRect();
        }
      }
      function addMouseWheelListener() {
        // If the highlight is visible and there is a scrollable container, add mousewheel listener for
        // smooth highlight position updates as scrolling occurs.
        // The mousewheel event is better than the scroll event because we can add it in one place (on document) and it bubbles.
        // It also updates for each scroll change, rather than waiting until the scrolling stops.
        // IMPORTANT: add this only in situations when there is an active highlight
        // because listening to mousewheel can cause bad performance.
        if (!isTrackingWheelEvents) {
          domEvents.on(document, "wheel", correctHighlightScreenRects);
          isTrackingWheelEvents = true;
        }
        traitcache.updateCachedViewPosition();
      }
      function removeMouseWheelListener() {
        if (isTrackingWheelEvents) {
          domEvents.off(document, "wheel", correctHighlightScreenRects);
          isTrackingWheelEvents = false;
        }
      }
      function isScrollEvent(event) {
        return cursorPos && event.screenX === cursorPos.screenX && event.screenY === cursorPos.screenY;
      }
      // Used for performance shortcut -- if still inside same highlight
      function isExistingHighlightRelevant() {
        if (!state.isCreated) {
          return false;
        }
        // Return true we're inside in the existing highlight
        return isCursorInHighlightShape([ state.fixedContentRect ], getCutoutRectsArray());
      }
      function onMouseMove(event) {
        if (true) {
          if (isSticky && !event.shiftKey) {
            return;
          }
        }
        pickFromMouseAfterDelay(event);
      }
      function updateDebugRect() {
        $("#sc-debug-mh-rect").remove();
        if (!state.isCreated) {
          return;
        }
        $('<sc id="sc-debug-mh-rect">').appendTo(document.documentElement).css({
          top: state.fixedContentRect.top + "px",
          left: state.fixedContentRect.left + "px",
          width: state.fixedContentRect.width + "px",
          height: state.fixedContentRect.height + "px",
          position: "fixed",
          pointerEvents: "none",
          outline: "2px solid rgba(150,0,0,.5)"
        });
      }
      // We run the picker if the mouse position hasn't changed for a while, meaning
      // that the mouse has paused over content
      function pickFromMouseAfterDelay(event) {
        clearTimeout(pickFromMouseTimer);
        var wasScrollEvent = isScrollEvent(event);
        // Are we responding to scroll events?
        if (!willRespondToScroll) {
          if (wasScrollEvent) {
            return;
          }
          willRespondToScroll = true;
        }
        if (!isAppropriateFocus) {
          return;
        }
        if (state.isCreated && cursorPos && cursorPos.doCheckCursorInHighlight) {
          // We have an old highlight and mouse moved.
          // What to do about the old highlight? Keep or hide? Depends on whether mouse is still in it
          if (!cursorPos || isScrollEvent(event)) {
            cursorPos = getCursorPos(event);
          } else {
            // No need to recalculate scroll position -- it stayed the same
            cursorPos = getCursorPos(event, cursorPos.pageXOffset, cursorPos.pageYOffset);
          }
          if (isExistingHighlightRelevant()) {
            if (true && isHighlightRectDebuggingOn) {
              updateDebugRect();
            }
            return;
          }
          // Highlight was inappropriate -- cursor wasn't in it
          hide();
        }
        pickFromMouseTimer = nativeGlobal.setTimeout(function() {
          // In case doesn't move after fast velocity, check in a moment and update highlight if no movement
          pickFromMouseTimer = 0;
          pickFromMouse(event);
          if (true && isHighlightRectDebuggingOn) {
            updateDebugRect();
          }
        }, wasScrollEvent ? SCROLL_STOP_MS : MOUSE_STOP_MS);
      }
      function pickFromMouse(event) {
        var picked, target = event.target;
        cursorPos = getCursorPos(event);
        // save picked element
        picked = picker.find(target);
        if (!picked) {
          if (state.picked) {
            hide();
          }
          state.target = target;
          return;
        }
        hide();
        state.picked = $(picked);
        state.target = target;
        if (event.shiftKey && isOnlyShift) {
          !function(commands) {
            commands.speakHighlight();
          }(page_keys_commands);
        }
        updateView();
      }
      // refreshEventListeners turns on or off event listeners that enable the highlighter
      // return true if highlight visibility should be restored
      function refreshEventListeners(doForceOff) {
        // The mouse highlight is always enabled when TTS is on or zoom > MIN_ZOOM
        var doTrackMouse = isSitecuesOn && !doForceOff;
        if (doTrackMouse === isTrackingMouse) {
          return isTrackingMouse;
        }
        isTrackingMouse = doTrackMouse;
        var addOrRemoveFn = isTrackingMouse ? domEvents.on : domEvents.off;
        addOrRemoveFn(document, "mousemove", onMouseMove);
        if (false) {
          // Mitigate lack of mousemove events when scroll finishes
          addOrRemoveFn(document, "mouseover", onMouseMove);
        }
        addOrRemoveFn(document, "focusin", testFocus);
        addOrRemoveFn(document, "focusout", testFocus);
        addOrRemoveFn(window, "focus", onFocusWindow);
        addOrRemoveFn(window, "blur", onBlur);
        addOrRemoveFn(window, "resize", hide);
        addOrRemoveFn(window, "mousedown", setFocus);
        if (!isTrackingMouse) {
          removeMouseWheelListener();
        }
        return isTrackingMouse;
      }
      // This addresses the stickiness of the focus on the dropdown select element on fairfieldcountybank.com
      function setFocus(evt) {
        if (evt.target !== document.activeElement && "function" === typeof evt.target.focus) {
          evt.target.focus();
        }
        testFocus();
      }
      function getCursorPos(event, scrollX, scrollY) {
        return {
          x: event.clientX,
          y: event.clientY,
          screenX: event.screenX,
          screenY: event.screenY,
          scrollX: "number" === typeof scrollX ? scrollX : window.pageXOffset,
          scrollY: "number" === typeof scrollY ? scrollY : window.pageYOffset,
          doCheckCursorInHighlight: true
        };
      }
      // Reenable highlight if appropriate
      // Clear the existing highlight if we don't reenable or if highlight can't be shown
      // (e.g. because focus is not in the right place, or the mouse cursor isn't inside the highlight)
      // Mouse event is passed if available.
      function resumeAppropriately(mouseEvent) {
        if (refreshEventListeners()) {
          // Don't do cursor-inside-picked-content check, because it may not be after zoom change
          if (mouseEvent) {
            cursorPos = getCursorPos(mouseEvent);
          }
          if (updateView()) {
            return;
          }
        }
        hide();
      }
      function onSpeechChanged() {
        if (!refreshEventListeners()) {
          hide(true);
        }
      }
      function isWindowActive() {
        return false ? isWindowFocused : document.hasFocus();
      }
      function testFocus() {
        var wasAppropriateFocus = isAppropriateFocus;
        // don't show highlight if current active isn't body
        var target = document.activeElement;
        isAppropriateFocus = isSitecuesUIOpen || (!target || !elementClassifier.isSpacebarConsumer(target)) && isWindowActive();
        if (!isSticky) {
          if (wasAppropriateFocus && !isAppropriateFocus) {
            hide();
          } else {
            if (!wasAppropriateFocus && isAppropriateFocus) {
              resumeAppropriately();
            }
          }
        }
      }
      function willExpand() {
        isSitecuesUIOpen = true;
        testFocus();
      }
      function didShrink() {
        isSitecuesUIOpen = false;
        testFocus();
      }
      function didToggleBpMenu(isOpen) {
        isSitecuesUIOpen = isOpen;
        testFocus();
      }
      function onFocusWindow() {
        isWindowFocused = true;
        testFocus();
      }
      function onBlur(event) {
        if (event.target !== window) {
          return;
        }
        isWindowFocused = false;
        isAppropriateFocus = false;
        // When the user blurs (unfocuses) the window, we should
        // hide and forget the highlight (unless sticky highlight is on)
        if (!isSticky) {
          hide();
        }
      }
      // When the user mouses out of the window, we should
      // hide and forget the highlight (unless sticky highlight is on)
      function onLeaveWindow(evt) {
        function isRealLeaveEvent(evt) {
          // Browsers firing spurious mouseout events when mouse moves over highlight edge
          // This check seems to work to see if the user really exited the window
          // Note, for mouseout events, relatedTarget is the event targt the pointing device exited to
          return !evt.relatedTarget || evt.relatedTarget === document.documentElement;
        }
        if (isRealLeaveEvent(evt) && !isSticky) {
          hide();
        }
      }
      // pause() -- temporarily hide mouse highlight
      // and remove event listeners so that we don't update the highlight on mouse move
      // (until they're enabled again, via resume())
      function pause() {
        hide(true);
        refreshEventListeners(true);
      }
      function tryExistingHighlight() {
        var REQUIRED_RATIO_HIGHLIGHT_ONSCREEN = .5, prevHighlightRect = state.absoluteRect;
        if (!prevHighlightRect) {
          return;
        }
        var scrollX = window.pageXOffset, scrollY = window.pageYOffset, screenWidth = window.innerWidth, screenHeight = window.innerHeight, left = Math.max(prevHighlightRect.left, scrollX), right = Math.min(prevHighlightRect.right, scrollX + screenWidth), top = Math.max(prevHighlightRect.top, scrollY), bottom = Math.min(prevHighlightRect.bottom, scrollY + screenHeight), onScreenWidth = right - left, onScreenHeight = bottom - top, onScreenHighlightArea = onScreenWidth * onScreenHeight, totalHighlightArea = prevHighlightRect.width * prevHighlightRect.height, visibleRatio = onScreenHighlightArea / totalHighlightArea;
        if (visibleRatio < REQUIRED_RATIO_HIGHLIGHT_ONSCREEN) {
          return;
        }
        return updateView();
      }
      function autoPick() {
        // First try for existing hidden highlight
        // If it would still be onscreen, use it
        if (tryExistingHighlight()) {
          return;
        }
        // Retrieve some leaf nodes
        var nodeIterator = document.createNodeIterator(document.body, NodeFilter.SHOW_TEXT, null, false);
        var knownGoodState = state;
        var knownGoodScore = -9;
        var skipElement;
        var bodyWidth = bodyGeo.getBodyWidth();
        var bodyHeight = document.body.scrollHeight;
        traitcache.resetCache();
        var viewSize = traitcache.getCachedViewSize();
        // Get first visible text and start from there
        function isAcceptableTextLeaf(node) {
          // Logic to determine whether to accept, reject or skip node
          if (common.isWhitespaceOrPunct(node)) {
            return;
          }
          var rect = traitcache.getScreenRect(node.parentNode);
          if (0 === rect.width || 0 === rect.height || rect.top > viewSize.height || rect.left > viewSize.width || rect.right < 0 || rect.bottom < 0) {
            return;
          }
          return true;
        }
        while (true) {
          var containingElement, nextLeaf = nodeIterator.nextNode();
          if (!nextLeaf) {
            break;
          }
          if (!isAcceptableTextLeaf(nextLeaf)) {
            continue;
          }
          if (skipElement && $.contains(skipElement, nextLeaf)) {
            continue;
          }
          containingElement = nextLeaf.parentNode;
          if (containingElement && highlight(containingElement, true, true, true)) {
            skipElement = state.picked[0];
            // Don't try anything else in this container
            var scoreInfo = picker.getAutoPickScore(state.picked, state.fixedContentRect, state.absoluteRect, bodyWidth, bodyHeight), score = scoreInfo.score;
            if (score > knownGoodScore) {
              knownGoodState = $.extend({}, state);
              knownGoodScore = score;
            }
            if (scoreInfo.skip) {
              skipElement = scoreInfo.skip;
            } else {
              if (state.fixedContentRect.bottom > window.innerHeight) {
                break;
              }
            }
          }
        }
        highlight(knownGoodState.target, true);
      }
      // Hide mouse highlight temporarily, keep picked data so we can reshow
      // the same highlight without another mouse move.
      // It's useful to call on it's own when the cursor goes outside of the highlight
      // but stays inside the same element.
      function hide(doRememberHighlight) {
        // Now that highlight is hidden, we no longer need these
        removeEventListener("mouseout", onLeaveWindow);
        if (state.picked && state.savedCss) {
          // Restore the previous CSS on the picked elements (remove highlight bg etc.)
          inlineStyle.restore(state.picked[0], BG_PROPS);
          state.savedCss = null;
          state.savedBgColors.forEach(function(savedBg) {
            inlineStyle.restore(savedBg.elem, "background-color");
          });
          state.savedBgColors = [];
          if ("" === state.picked.attr("style")) {
            inlineStyle.clear(state.picked[0]);
          }
          removeMouseWheelListener();
        }
        if (state.overlayContainer) {
          state.overlayContainer.removeAttribute(HIGHLIGHT_OUTLINE_ATTR);
        }
        $("." + HIGHLIGHT_OUTLINE_CLASS).remove();
        if (pickFromMouseTimer) {
          clearTimeout(pickFromMouseTimer);
          pickFromMouseTimer = 0;
        }
        didToggleVisibility(false);
        if (!doRememberHighlight) {
          // Forget highlight state, unless we need to keep it around temporarily
          forget();
        }
      }
      function forget() {
        state = $.extend({}, INIT_STATE);
      }
      function setScrollTracking(isOn) {
        canTrackScroll = isOn;
        willRespondToScroll = false;
      }
      function setOnlyShift(isShift) {
        isOnlyShift = isShift;
      }
      // Return all of the highlight information provided in the |state| variable
      function getHighlight() {
        return state;
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        forget();
        // Temporarily hide and disable mouse highlight once highlight box appears. SC-1786
        // Also to this until zooming finished so that outline doesn't get out of place during zoom
        events.on("zoom/begin mh/pause", pause);
        // enable mouse highlight back once highlight box deflates or zoom finishes
        events.on("hlb/closed zoom", resumeAppropriately);
        // Turn mouse-tracking on or off
        events.on("keys/sitecues-key-down", setScrollTracking);
        // Turn mouse-tracking on or off
        events.on("key/only-shift", setOnlyShift);
        // Mouse highlighting not available while BP is open
        events.on("bp/will-expand", willExpand);
        events.on("bp/did-shrink", didShrink);
        events.on("bp/did-toggle-menu", didToggleBpMenu);
        events.on("speech/did-change", function(isOn) {
          isSpeechEnabled = isOn;
        });
        events.on("sitecues/did-toggle", function(isOn) {
          isSitecuesOn = isOn;
          refreshEventListeners();
        });
        // Darken highlight appearance when speech is enabled
        pref.bindListener("ttsOn", onSpeechChanged);
        testFocus();
        // Set initial focus state
        if ("loading" !== document.readyState) {
          // Focus is set again when document finishes loading
          document.addEventListener("DOMContentLoaded", testFocus);
        }
        refreshEventListeners();
      }
      if (true) {
        /**
     * Toggle Sticky state of highlight
     * When stick mode is on, shift must be pressed to move highlight
     */
        sitecues.toggleStickyMH = function() {
          isSticky = !isSticky;
          return isSticky;
        };
        /**
     * Toggle color debugging which makes it easier to see where white gaps in highlight are coming from
     */
        sitecues.toggleMHColorDebugging = function() {
          isColorDebuggingOn = !isColorDebuggingOn;
          return isColorDebuggingOn;
        };
        /**
     * Toggle debugging of the current highlight rect, which needs to keep up-to-date with scrolling
     */
        sitecues.toggleMHRectDebugging = function() {
          isHighlightRectDebuggingOn = !isHighlightRectDebuggingOn;
          return isHighlightRectDebuggingOn;
        };
        sitecues.getHighlight = getHighlight;
      }
      /**
   * Show highlight on the specified seed element or hide if if nothing specified
   * @param seed        -- desired element to highlight, or a CSS selector for one
   * @param doUsePicker -- if truthy will find the best item to highlight ... seed or an ancestor of seed
   *                       if falsey will just highlight seed exactly
   * @param doKeepHidden -- if truthy will compute highlight but not display it
   */
      function highlight(seed, doUsePicker, doSuppressVoting, doKeepHidden) {
        hide();
        // calling with no arguments will remove the highlight
        if (seed) {
          var elem = $(seed)[0];
          if (elem) {
            traitcache.updateCachedViewPosition();
            // Reset cache view to ensure scrolling accounted for
            state.picked = doUsePicker ? picker.find(elem, doSuppressVoting) : $(elem);
            state.target = elem;
            if (state.picked) {
              cursorPos.doCheckCursorInHighlight = false;
              cursorPos.scrollX = window.pageXOffset;
              cursorPos.scrollY = window.pageYOffset;
              if (updateView(doKeepHidden)) {
                return state.picked;
              }
            }
          }
        }
      }
      return {
        getHighlight: getHighlight,
        highlight: highlight,
        autoPick: autoPick,
        setScrollTracking: setScrollTracking,
        hide: hide,
        init: init
      };
    }($, run_conf_preferences, page_highlight_pick, page_highlight_traitcache, page_highlight_highlight_position, page_util_common, page_util_color, page_util_geo, page_util_element_classifier, run_platform, page_highlight_constants, run_events, run_dom_events, page_zoom_zoom, page_zoom_util_body_geometry, mini_core_native_global, run_inline_style_inline_style);
    page_positioner_constants = function() {
      var constants = {};
      constants.TRANSPLANT_STATE = {
        UNCLONED: 0,
        CLONED: 1,
        MIXED: 2,
        ROOT: 3,
        NESTED_ROOT: 4,
        NESTED: 5
      };
      constants.INLINE_STYLE_PATTERN = ":\\s?([^;]*);\\s?";
      constants.ATTRIBUTE_REGEX = /\[([^\=~\|\^\$\*\]]+)[^\]]*\]/;
      constants.ID_REGEX = /#([^\s\+>~\.\[:]+)/g;
      constants.CLASS_REGEX = /\.([^\s\+>~\.\[:]+)/g;
      constants.LOCK_ATTR = "data-sc-lock-";
      constants.ROOT_ATTR = "data-sc-root";
      constants.ANCHOR_ATTR = "data-sc-anchor";
      constants.VISIBLE = "visible";
      constants.HIDDEN = "hidden";
      constants.ROOT_SELECTOR = "[" + constants.ROOT_ATTR + "]";
      constants.VISIBLE_ANCHOR_SELECTOR = "[" + constants.ANCHOR_ATTR + '="' + constants.VISIBLE + '"]';
      constants.HIDDEN_ANCHOR_SELECTOR = "[" + constants.ANCHOR_ATTR + '="' + constants.HIDDEN + '"]';
      return constants;
    }();
    page_positioner_util_element_map = function() {
      var map = new WeakMap();
      function setField(element, fields, values) {
        var dataCache = getData(element);
        if (!Array.isArray(fields)) {
          fields = [ fields ];
          values = [ values ];
        }
        var len = fields.length;
        for (var i = 0; i < len; i++) {
          dataCache[fields[i]] = values[i];
        }
        map.set(element, dataCache);
      }
      function saveComputedStyle(element, style) {
        setField(element, [ "computedStyle" ], [ style ]);
      }
      function clearComputedStyle(elements) {
        if (Array.isArray(elements)) {
          var len = elements.length;
          for (var i = 0; i < len; i++) {
            var element = elements[i];
            if (element) {
              flushField(element, "computedStyle");
            }
          }
        } else {
          flushField(elements, "computedStyle");
        }
      }
      function getComputedStyle(element) {
        var style = getField(element, "computedStyle");
        if (style) {
          return style;
        }
        style = window.getComputedStyle(element);
        saveComputedStyle(element, style);
        return style;
      }
      function refreshComputedStyle(element) {
        clearComputedStyle(element);
        return getComputedStyle(element);
      }
      function flushField(element, fields) {
        var values = [], dataCache = getData(element);
        if (!Array.isArray(fields)) {
          fields = [ fields ];
        }
        var i = fields.length;
        while (i--) {
          var field = fields[i];
          values.push(dataCache[field]);
          delete dataCache[field];
        }
        map.set(element, dataCache);
        return 1 === values.length ? values[0] : values;
      }
      function getField(element, field) {
        return getData(element)[field];
      }
      function addToField(element, field, value) {
        var data = getField(element, field) || [];
        data.push(value);
        setField(element, [ field ], [ data ]);
      }
      function getData(element) {
        return map.get(element) || {};
      }
      return {
        setField: setField,
        addToField: addToField,
        flushField: flushField,
        getField: getField,
        clearComputedStyle: clearComputedStyle,
        refreshComputedStyle: refreshComputedStyle,
        getComputedStyle: getComputedStyle
      };
    }();
    hlb_event_handlers = function($) {
      /////////////////////////
      // PRIVATE VARIABLES
      ////////////////////////
      //  Wheel event callback, must be scoped at the module level because
      //  we create this event callback every time the HLB opens because
      //  the callback requires a reference to the HLB element...s
      var wheelEventCallback, isCapturing;
      /**
   * [releaseWheelEvents disables the capturing of wheel events.  This is called once the HLB is closed.]
   */
      function releaseWheelEvents() {
        window.removeEventListener("wheel", wheelEventCallback);
        isCapturing = false;
      }
      /**
   * [captureWheelEvents captures wheel events while the HLB is open. ]
   * @param  {[jQuery Element]} $hlb [The HLB element]
   */
      function captureWheelEvents($hlb) {
        if (isCapturing) {
          return;
        }
        isCapturing = true;
        /**
     * [wheelHandler listens to all scroll events in the window and prevents scroll outside of HLB]
     * @param  {[DOM scroll event]} e [Object representing scrolling data]
     * TODO: Determine if this is the best way to handle this situation.  The reason we create a new
     * function every time we want to listen to wheel events is because the callback needs reference
     * to the HLB element. That is the problem that this approach solves, probably isn't ideal...
    */
        wheelEventCallback = function(event) {
          // Get the deltaY value when the user scrolls (how fast the user is scrolling)
          var deltaY = parseInt(event.deltaY || -event.wheelDeltaY);
          // parseInt() sanitizes by converting strange -0 value to 0
          // Sometimes there is no deltaY number, or a deltaY of "0"
          // (when the user is scrolling horizontally along X)
          if (!deltaY) {
            // We prevent the scroll event for horizontal scrolls
            return preventScroll(event);
          }
          /*
      
              Dimension Calculations:
      
                         /////////
                       ↑ /       / ↕ Scroll Top
                Scroll | XXXXXXXXX
                Height | X       X ↑
                       | X  HLB  X | Client Height
                       | X       X ↓
                       | XXXXXXXXX
                       ↓ /       / ↕ Scroll Bottom
                         /////////
      
            */
          // Get the dimensions
          var elem = $hlb[0], // The HLB Element
          scrollHeight = elem.scrollHeight, // The total height of the scrollable area
          scrollTop = elem.scrollTop, // Pixel height of invisible area above element (what has been scrolled)
          clientHeight = elem.clientHeight, // The height of the element in the window
          scrollBottom = scrollHeight - scrollTop - clientHeight, // The pixels height invisible area below element (what is left to scroll)
          scrollingDown = deltaY > 0, // If the user is scrolling downwards
          scrollingUp = deltaY < 0, // If the user is scrolling upwards
          scrolledToBottom = scrollBottom <= 1, // There are now more invisible pixels below the element
          scrolledToTop = elem.scrollTop <= 1;
          // There are now more invisible pixels above the element
          // Prevent any scrolling if the user is:
          //   a) Not scrolling on the HLB element directly.
          //   b) Not scrolling on a decendant of the HLB element.
          if ($hlb[0] !== event.target && !$.contains(elem, event.target)) {
            preventScroll(event);
          }
          // If the user is scrolling down, (but has not reached the bottom), and
          // is trying to scroll down more pixels that there are left to scroll...
          if (scrollingDown && deltaY >= scrollBottom) {
            // ...set the scroll to the bottom...
            elem.scrollTop = elem.scrollHeight;
            // ...and stop scrolling.
            preventScroll(event);
          }
          // If the user tries to scroll down past the bottom...
          if (scrolledToBottom && scrollingDown) {
            preventScroll(event);
          }
          // If the user is scrolling up, (but has not reached the top), and is
          // trying to scroll up more pixels that there are left to scroll...
          if (scrollingUp && scrollTop - -deltaY <= 0) {
            // ...set the scroll to the top...
            elem.scrollTop = 0;
            // ...and stop scrolling.
            preventScroll(event);
          }
          // If the user tries to scroll down past the bottom...
          if (scrolledToTop && scrollingUp) {
            preventScroll(event);
          }
          // Prevent the original scroll event
          function preventScroll() {
            event.preventDefault();
            event.returnValue = false;
            return false;
          }
        };
        // Trap the mousewheel events (wheel for all browsers except Safari, which uses mousewheel)
        window.addEventListener("wheel", wheelEventCallback);
      }
      return {
        releaseWheelEvents: releaseWheelEvents,
        captureWheelEvents: captureWheelEvents
      };
    }($);
    hlb_constants = function() {
      var constants = {};
      // IDs
      constants.HLB_WRAPPER_ID = "sitecues-hlb-wrapper";
      // ID for element which wraps HLB and Dimmer elements
      constants.HLB_ID = "sitecues-hlb";
      // ID for $hlb
      constants.HLB_READY = "hlb/ready";
      //Event fired when HLB is created
      // Other
      constants.MAX_ZINDEX = 2147483647;
      return constants;
    }();
    hlb_styling = function($, common, pref, constants, inlineStyle, arrayUtil) {
      ///////////////////////////
      // PUBLIC PROPERTIES
      //////////////////////////
      // All HLB instances will use these default padding and border values.
      var defaultPadding = 4;
      var defaultBorder = 3;
      // Transition property used for hlb animation (-webkit, -moz)
      // This is used to transition the transform property for HLB
      // inflation/deflation animation
      var transitionProperty = "transform ";
      ///////////////////////////
      // PRIVATE VARIABLES
      ///////////////////////////
      var // How many ancestors do we move up the chain until we find a background image
      // to use for the $hlb background image.
      BACKGROUND_IMAGE_ANCESTOR_TRAVERSAL_COUNT = 3, // Default background color for HLB, if HLB is NOT an image.
      HLB_DEFAULT_BACKGROUND_COLOR = "#fff", // Default text color for HLB
      HLB_DEFAULT_TEXT_COLOR = "#000", // Default background color for HLB, if HLB is an image.
      HLB_IMAGE_DEFAULT_BACKGROUND_COLOR = "#000", // Remove these styles from the HLB, but NOT its children.
      HLBCSSBlacklist = [ "padding", "margin", "left", "top", "right", "bottom", "box-shadow", "transform", "-webkit-transform", "-moz-transform", "-ms-transform", "-webkit-transform-origin", "-moz-transform-origin", "-ms-transform-origin", "transition", "-webkit-transition", "width", "height", "-webkit-text-fill-color", "min-height", "min-width", "max-height", "max-width", "-ms-scroll-limit-y-max" ], // What child elements of the HLB do we want to remove after a clone.
      HLBElementBlacklist = [ "script", "iframe" ], // Remove ID from HLB because the speech module sets the ID for TTS to work
      HLBAttributeBlacklist = [ "id", "class" ], // Default css styles for HLB
      defaultHLBStyles = {
        position: "absolute",
        // Doesn't interfere with document flow
        zIndex: constants.MAX_ZINDEX,
        // Max z-index for HLB overlay
        border: defaultBorder + "px solid #000",
        padding: defaultPadding,
        margin: 0,
        // Margin isn't necessary and only adds complexity
        borderRadius: "4px",
        // Aesthetic purposes
        boxSizing: "content-box",
        // Default value.  If we do not force this property, then our positioning algorithm must be dynamic...
        visibility: "visible",
        maxWidth: "none",
        maxHeight: "none",
        opacity: 1
      };
      //////////////////////////
      // PRIVATE FUNCTIONS
      //////////////////////////
      /**
   * [filterElements removes HLBElementBlacklist elements from the HLB element, but not its children]
   * @param  {[DOM element]} $hlb [HLB element]
   */
      function filterBlacklistedElements($hlb) {
        $hlb.find(HLBElementBlacklist.join(",")).remove();
      }
      /**
   * [filterHiddenElements removes elements from the HLB that the picker deems unwanted.]
   * @param  {[jQuery Element]} $hlb    [HLB element]
   * @param  {[jQuery Element]} $picked [Element picked by picker]
   * @param  {[Array]} hiddenElements [Array of elements to remove]
   */
      function filterHiddenElements($hlb, $picked, hiddenElements) {
        var pickedElementIsListItem = $picked.is("li"), pickedDescendants = $picked.find("*").get(), hlbDescendants = (pickedElementIsListItem ? $hlb.children().find("*") : $hlb.find("*")).get();
        if (true) {
          if (pickedDescendants.length !== hlbDescendants.length) {
            console.warn("There is not a 1:1 mapping for filterHiddenElements!");
          }
        }
        pickedDescendants.forEach(function(element, index) {
          if (hiddenElements.get(element)) {
            $(hlbDescendants[index]).remove();
          }
        });
      }
      /**
   * [filterElements removes css styles in HLBCSSBlacklist from the HLB element, but not its children]
   * @param  {[DOM element]} $hlb [HLB element]
   */
      function filterStyles($hlb) {
        for (var i = 0; i < HLBCSSBlacklist.length; i += 1) {
          inlineStyle.removeProperty($hlb[0], HLBCSSBlacklist[i]);
        }
      }
      /**
   * [filterAttributes removes html attributes in HLBAttributeBlacklist]
   * @param  {[DOM element]} $hlb [HLB element]
  */
      function filterAttributes($hlb) {
        for (var i = 0; i < HLBAttributeBlacklist.length; i += 1) {
          $hlb.removeAttr(HLBAttributeBlacklist[i]);
        }
      }
      /**
   * [getDescendantStyles computes HLB child element styles]
   * @param  {[jQuery element]} $descendant                    [The current HLB element child we are styling]
   * @param  {[Boolean]} hlbWidthGreaterThanSafeAreaWidth [True if the HLB width >= safe area width]
   * @param  {[Object]} foundationDescendantStyle        [CSS styles returned from window.getComputedStyle]
   * @return {[Object]}                                   [Styles to be consumed by jQuery.css]
   */
      function getDescendantStyles($descendant, foundationDescendantStyle) {
        // Defaut css styles for all HLB descendants
        var styles = {
          webkitTextFillColor: "",
          textDecoration: "none",
          bottom: 0,
          // Added because bug found on TexasAT, first LI (About TATN) of ".horizontal rootGroup"
          height: "auto",
          // Added to fix cases where text overlapped vertically, like on eeoc
          "min-width": ""
        }, fontSize = parseFloat(foundationDescendantStyle.fontSize), lineHeight = parseFloat(foundationDescendantStyle.lineHeight), textDecoration = foundationDescendantStyle.textDecoration;
        // NOTE: Copying cssText directly is not sufficient for copying textDecorations.
        //       ts.dev.sitecues.com/hlb/styling/text-decoration.html
        if (textDecoration.indexOf("underline") !== -1) {
          styles.textDecoration = "underline";
        } else {
          if (textDecoration.indexOf("overline") !== -1) {
            styles.textDecoration = "overline";
          } else {
            if (textDecoration.indexOf("line-through") !== -1) {
              styles.textDecoration = "line-through";
            }
          }
        }
        // Implemented to fix http://www.windoweyesforoffice.com/sitecues/index.php when HLBing
        // Window-Eyes in header.  Applause: #1224073
        if (fontSize > lineHeight) {
          if (true) {
            console.log("%cSPECIAL CASE: Increasing line height.", "background:orange;");
          }
          styles.lineHeight = fontSize + "px";
        }
        // This fixes a problem with the HLB on TexasAT home page when opening the entire "News & Events"
        // ALSO...it fixes another problem that used a different fix.  I removed the old fix
        // and will re-enable it if hlb content overlaps
        //       // NOTE: Fix implemented because of opening HLB on http://abclibrary.org/teenzone on the #customheader
        //                Fixes children overlapping children within the HLB.  Comment out the line below to
        //                experience this problem.
        if ("absolute" === foundationDescendantStyle.position) {
          styles.position = "static";
          styles.display = "inline-block";
        }
        // Implemented to fix very long link that wasn't wrapping in the HLB on www.faast.org/news
        if ($descendant.is("a")) {
          styles.wordWrap = "break-word";
        }
        return styles;
      }
      function getBulletWidth($element, elementComputedStyle) {
        //If the HLB is a list AND it has bullets...return their width
        if ("none" !== elementComputedStyle.listStyleType || "none" !== elementComputedStyle.listStyleImage) {
          return common.getBulletWidth($element[0], elementComputedStyle);
        }
        return 0;
      }
      /**
   * [isTransparent determines if a particular style is transparent]
   * @param  {[CSS style property]}  style [Used for background color]
   * @return {Boolean}       [True if transparent, false otherwise]
   */
      function isTransparent(style) {
        return style.indexOf("rgba") !== -1 && (style.indexOf(".") !== -1 || "0" === style.charAt(style.length - 2)) || "transparent" === style;
      }
      /**
   * [getNonEmptyBackgroundImage determines what background image will be used
   * for the HLB element.  It moves up the ancestor chain of the original element
   * and returns the first background image it encounters.]
   * @param  {[DOM element]} $picked [The picked element chosen by the picker]
   * @return {[String]}                       [CSS background-image property]
   */
      function getNonEmptyBackgroundImage($picked, ancestorCount) {
        var backgroundStyles = {}, $parents = $picked.parents();
        $parents.each(function(index) {
          if (index >= ancestorCount) {
            return false;
          }
          var $ancestor = $(this);
          if ("none" !== $ancestor.css("backgroundImage")) {
            backgroundStyles.backgroundImage = $ancestor.css("backgroundImage");
            backgroundStyles.backgroundRepeat = $ancestor.css("backgroundRepeat");
            backgroundStyles.backgroundAttachment = "local";
            backgroundStyles.$ancestor = $ancestor;
            return false;
          }
        });
        return backgroundStyles;
      }
      /**
   * [getNonTransparentBackground determines what background color will be used
   * for the HLB element. It moves up the ancestor chain of the original element
   * and returns the first background color it encounters that isn't transparent]
   * @param  {[DOM element]} $picked [The original element chosen by the picker]
   * @return {[String]}                       [CSS background-color property]
   */
      function getNonTransparentBackground($picked) {
        var newBackgroundColor, parents = $picked.parents();
        parents.each(function() {
          if (!isTransparent($(this).css("backgroundColor"))) {
            newBackgroundColor = $(this).css("backgroundColor");
            return false;
          }
        });
        return newBackgroundColor;
      }
      /**
   * [getHLBBackgroundColor
       If the $hlbElement has a transparent background color, we should find one
       by looking up the entire ancestor chain and use the first non-transparent
       color we find.  Otherwise, if the $hlbElement is not an image, we default
       to a white background color.  If it is an image, however, the background
       color is black.]
   * @param  {[jQuery element]} $originalElement     [The original element chosen by picker]
   * @param  {[Object]} elementComputedStyle         [The original elements computed styles]
   * @return {[String]}                              [The HLB background color]
   */
      function getHLBBackgroundColor($picked, elementComputedStyle) {
        var newBackgroundColor;
        if (isTransparent(elementComputedStyle.backgroundColor)) {
          if ($picked.is("img")) {
            return HLB_IMAGE_DEFAULT_BACKGROUND_COLOR;
          } else {
            newBackgroundColor = getNonTransparentBackground($picked);
            if (newBackgroundColor) {
              return newBackgroundColor;
            } else {
              return HLB_DEFAULT_BACKGROUND_COLOR;
            }
          }
        }
        return elementComputedStyle.backgroundColor;
      }
      /**
   * [getHLBBackgroundImage determines the background image to be used by the $hlbElement]
   * @param  {[jQuery element]} $picked   [The picked element chosen by the picker.]
   * @param  {[Object]} elementComputedStyle     [The original elements computed style]
   * @return {[String]}                          [The background image that will be used by the $hlbElement]
   */
      function getHLBBackgroundImage($picked, elementComputedStyle) {
        var newBackgroundImage;
        // If the original element doesnt have a background image and the original element has a transparent background...
        if ("none" === elementComputedStyle.backgroundImage && isTransparent(elementComputedStyle.backgroundColor)) {
          newBackgroundImage = getNonEmptyBackgroundImage($picked, BACKGROUND_IMAGE_ANCESTOR_TRAVERSAL_COUNT);
          if (newBackgroundImage) {
            return newBackgroundImage;
          }
        }
        return {
          backgroundImage: elementComputedStyle.backgroundImage,
          backgroundRepeat: elementComputedStyle.backgroundRepeat,
          backgroundAttachment: "local"
        };
      }
      /**
   * [getHLBLeftPadding is required to visually encapsulate bullet points within the HLB if the
   * $hlb is itself a <ul> or <ol> that uses bullet points.
   * @param  {[jQuery element]} $foundation   [The original element chosen by the picker.]
   * @param  {[Object]} computedStyle  [The original elements computed style]
   * @return {[Integer]}                      [The HLB left-padding]
   */
      function getHLBLeftPadding($foundation, computedStyle) {
        return defaultPadding + getBulletWidth($foundation, computedStyle);
      }
      /**
   * [getHLBDisplay determines $hlbElement will use for its CSS display]
   * @param  {[Object]} computedStyle [The original elements computed styles]
   * @return {[String]}                      [The display the $hlbElement will use]
   * NOTE:
      // If the original elements display type is a table, force a display type of
      // block because it allows us to set the height.  I believe display table
      // is mutually exclusive to minimum height/minimum width.
      //
      // http://stackoverflow.com/questions/8739838/displaytable-breaking-set-width-height
      //
      // I found the issue on the eBank site that we maintain.  Make the HLB open a table
      // and open the developer console and attempt to alter the height/width attributes.
      //
      // TODO: actually prove these beliefs
   */
      function getHLBDisplay(computedStyle) {
        if ("table" === computedStyle.display) {
          return "block";
        }
        return computedStyle.display;
      }
      /**
   * [shouldRemovePadding determines if children of our HLB have padding that should be
   * removed because the highlight clips padding.]
   * @param  {[jQuery Element]} $child [Child element of the HLB]
   * @param  {[Object]} initialHLBRect [highlight rectangle]
   * @return {[Boolean]}               [True: Remove Padding. False: Do Nothing]
   */
      function shouldRemovePadding($child, initialHLBRect) {
        var childBoundingClientRect = $child[0].getBoundingClientRect(), childLeftPadding = parseFloat($child.css("paddingLeft")), childRightPadding = parseFloat($child.css("paddingRight")), childTopPadding = parseFloat($child.css("paddingTop")), childBottomPadding = parseFloat($child.css("paddingBottom"));
        if ($child.is("br, option") || 0 === childBoundingClientRect.width) {
          return;
        }
        if (childBoundingClientRect.left < initialHLBRect.left && childLeftPadding > 0 || childBoundingClientRect.right > initialHLBRect.right && childRightPadding > 0 || childBoundingClientRect.top < initialHLBRect.top && childTopPadding > 0 || childBoundingClientRect.bottom > initialHLBRect.bottom && childBottomPadding > 0) {
          if (true) {
            console.log("%cSPECIAL CASE: Removing child padding.", "background:orange;");
          }
          return true;
        }
      }
      /**
   * [getChildPadding computes and returns the padding for a child element of the HLB.  Taking into account the
   * initialHLBRect, clipping padding is something to be done to preserve that HLB size.]
   * @param  {[jQuery Element]} $child [Child element of the HLB]
   * @param  {[Object]} initialHLBRect [highlight rectangle]
   * @return {[Object]}                [Padding styles for a child element]
   */
      function getChildPadding($child, initialHLBRect) {
        var childBoundingClientRect = $child[0].getBoundingClientRect(), childLeftPadding = parseFloat($child.css("paddingLeft")), childRightPadding = parseFloat($child.css("paddingRight")), childTopPadding = parseFloat($child.css("paddingTop")), childBottomPadding = parseFloat($child.css("paddingBottom")), paddingStyles = {}, zoom = pref.get("zoom") || 1;
        if (childBoundingClientRect.left < initialHLBRect.left && childLeftPadding > 0) {
          paddingStyles.paddingLeft = childLeftPadding - (initialHLBRect.left - childBoundingClientRect.left) / zoom;
        }
        if (childBoundingClientRect.right > initialHLBRect.right && childRightPadding > 0) {
          paddingStyles.paddingRight = childRightPadding - (childBoundingClientRect.right - initialHLBRect.right) / zoom;
        }
        if (childBoundingClientRect.top < initialHLBRect.top && childTopPadding > 0) {
          paddingStyles.paddingTop = childTopPadding - (initialHLBRect.top - childBoundingClientRect.top) / zoom;
        }
        if (childBoundingClientRect.bottom > initialHLBRect.bottom && childBottomPadding > 0) {
          paddingStyles.paddingBottom = childBottomPadding - (childBoundingClientRect.bottom - initialHLBRect.bottom) / zoom;
        }
        return paddingStyles;
      }
      /**
   * [initializeHLBElementStyles initializes the HLB elements styles by directly copying
   *  the styles from the original element.]
   * @param  {[jQuery element]} $foundation [The original element chosen by the picker]
   * @param  {[jQuery element]} $hlb      [The HLB element]
   */
      function initializeHLBElementStyles($foundation, $hlb) {
        inlineStyle($hlb[0]).cssText = getComputedStyleCssText($foundation[0]);
      }
      /**
   * [initializeHLBDescendantStyles initializes the styles of the children of the HLB element.
   *   Step 1: Copy computed styles of original element children to hlb element children.
   *   Step 2: Remove padding if element is cropped by the initialHLBRect (mouse highlight rect)
   *   Step 3: Compute child styles that must override a direct copy of computed styles.
   *   Step 4: Set child styles.
   *   Step 5: Filter child attributes.
   * ]
    * @param  {[jQuery element]} $foundation [The original element chosen by the picker]
    * @param  {[jQuery element]} $hlb      [The HLB element]
    */
      function initializeHLBDescendantStyles($foundation, $hlb, initialHLBRect, hiddenElements) {
        var foundationDescendantStyle, computedChildStyles, foundation = $foundation[0], hlb = $hlb[0], removeMargins = true, foundationNodes = [ foundation ], hlbNodes = [ hlb ];
        // Iterate through each node in the foundation, in document order, and exclude elements we've identified as hidden
        // This is important because it's very expensive to call getComputedStyleCssText for each node in the tree in Firefox
        while (foundationNodes.length) {
          var foundationNode = foundationNodes.pop(), hlbNode = hlbNodes.pop();
          if (hiddenElements.get(foundationNode)) {
            continue;
          }
          initializeCloneStyle(foundationNode, hlbNode);
          foundationNodes = foundationNodes.concat(arrayUtil.from(foundationNode.children));
          hlbNodes = hlbNodes.concat(arrayUtil.from(hlbNode.children));
        }
        function initializeCloneStyle(originalNode, cloneNode) {
          var $original = $(originalNode), $clone = $(cloneNode);
          // Cache the HLB child computed style
          foundationDescendantStyle = getComputedStyle(originalNode);
          // Copy the original elements child styles to the HLB elements child.
          inlineStyle(cloneNode).cssText = getComputedStyleCssText(originalNode);
          if (shouldRemovePadding($original, initialHLBRect)) {
            inlineStyle.set(cloneNode, getChildPadding($original, initialHLBRect));
          }
          // Compute styles that are more complicated than copying cssText.
          computedChildStyles = getDescendantStyles($original, foundationDescendantStyle);
          // Added to fix HLB sizing when selecting last 2 paragraphs on http://www.ticc.com/
          if (shouldRemoveHorizontalMargins($original, $foundation)) {
            if (true) {
              console.log("%cSPECIAL CASE: Removing left and right margins.", "background:orange;");
            }
            computedChildStyles.marginLeft = 0;
            computedChildStyles.marginRight = 0;
          } else {
            removeMargins = false;
          }
          // Set the childs css.
          inlineStyle.set(cloneNode, computedChildStyles);
          // Ran into issues with children inheriting styles because of class and id CSS selectors.
          // Filtering children of these attributes solves the problem.
          filterAttributes($clone);
        }
      }
      /**
   * [shouldRemoveHorizontalMargins determines if left-margin and right-margin can be removed from
   * a child in the HLB element.]
   * @param  {[jQuery Element]} $foundationDescendant [One of the children of the picked element.]
   * @param  {[jQuery Element]} $foundation      [The element that is the model for the HLB (typically same as $pickedElement.]
   * @return {[Boolean]}
   */
      function shouldRemoveHorizontalMargins($foundationDescendant, $foundation) {
        var $children = $foundationDescendant.parent().children(), $parents = $foundationDescendant.parentsUntil($foundation), parentCount = $parents.length, childCount = $children.length, hasOverlap = false, boundingRects = [], i = 0, j = 0;
        if (1 === childCount) {
          return true;
        }
        for (;i < parentCount; i += 1) {
          if ($parents[i].getBoundingClientRect().left < $foundationDescendant[0].getBoundingClientRect().left) {
            return false;
          }
        }
        for (i = 0; i < childCount; i += 1) {
          boundingRects.push($children[i].getBoundingClientRect());
        }
        for (i = 0; i < childCount; i += 1) {
          for (;j < childCount; j += 1) {
            if (i !== j) {
              if (!(boundingRects[i].top >= boundingRects[j].bottom || boundingRects[i].bottom <= boundingRects[j].top)) {
                hasOverlap = true;
              }
            }
          }
        }
        return !hasOverlap;
      }
      //////////////////////////
      // PUBLIC FUNCTIONS
      //////////////////////////
      /**
   * [setHLBChildTextColor determines and sets a text color for all HLB children so that they are in
   * contrast with the background colors behind them.]
   * @param {[jQuery element]} $hlb [The HLB element]
   * NOTE: This function was created to fix a bug found on TexasAT home page navigation (Home, Sitemap, Contact Us)
   */
      function setHLBChildTextColor($hlb) {
        var children;
        // If the $hlb uses a background image then assume text is readable.
        // TODO: improve this entire mechanism.
        if ("none" !== $hlb.css("backgroundImage")) {
          return;
        }
        children = $hlb.find("*");
        // For every HLB child...
        children.each(function() {
          var textColor = $(this).css("color"), backgroundColor = $(this).css("backgroundColor"), forceTextColor = false;
          // If the HLB child has a transparent background, or the background is the same color as the text,
          // then we have to determine if we need to set the HLB childs text color by traversing the ancestor
          // chain for.
          if (isTransparent(backgroundColor) || textColor === backgroundColor) {
            //  Check every ancestor up to and including the HLB element
            $(this).parentsUntil($hlb.parent()).each(function() {
              var parentBackgroundColor = $(this).css("backgroundColor");
              // If we run into a parent who has a non-transparent background color
              if (!isTransparent(parentBackgroundColor)) {
                // Set the childs text color if the current text color and the first non-transparent
                // background color are exactly the same.
                if (textColor === parentBackgroundColor) {
                  forceTextColor = true;
                  return false;
                } else {
                  return false;
                }
              }
            });
            if (forceTextColor) {
              inlineStyle(this).color = HLB_DEFAULT_TEXT_COLOR;
            }
          }
        });
      }
      /**
   * [getHLBStyles gets the HLB styles.]
   * @param {[DOM element]} $foundation [the original element]
   * @return {[Object]} [CSS style object to be used by jQuery.css()]
   */
      function getHLBStyles($picked, $foundation, highlight) {
        var originalElement = $foundation[0], originalElementRect = originalElement.getBoundingClientRect(), elementComputedStyle = window.getComputedStyle(originalElement), backgroundStyles = getHLBBackgroundImage($picked, elementComputedStyle), backgroundColor = getHLBBackgroundColor($picked, elementComputedStyle), calculatedHLBStyles = {
          paddingLeft: getHLBLeftPadding($foundation, elementComputedStyle),
          display: getHLBDisplay(elementComputedStyle),
          left: originalElementRect.left + window.scrollLeft,
          top: originalElementRect.top + window.scrollTop
        }, borderStyles = {
          borderColor: highlight.hasDarkBackgroundColor ? highlight.highlightBorderColor : "#000"
        }, animationOptimizationStyles = {
          willChange: "transform",
          backfaceVisibility: "hidden"
        };
        // If the background color is the same as the text color, use default text and background colors
        if (backgroundColor === $foundation.css("color")) {
          calculatedHLBStyles.color = HLB_DEFAULT_TEXT_COLOR;
          calculatedHLBStyles.backgroundColor = HLB_DEFAULT_BACKGROUND_COLOR;
        } else {
          calculatedHLBStyles.backgroundColor = backgroundColor;
        }
        // If the original element uses a background image, preserve original padding.
        // This was implemented to fix SC-1830
        // If the background image repeats, there is no need to preserve the padding.
        if ("none" !== $foundation.css("backgroundImage") && "repeat" !== $foundation.css("backgroundRepeat")) {
          calculatedHLBStyles.paddingLeft = $foundation.css("paddingLeft");
          calculatedHLBStyles.paddingTop = $foundation.css("paddingTop");
          calculatedHLBStyles.paddingBottom = $foundation.css("paddingBottom");
          calculatedHLBStyles.paddingRight = $foundation.css("paddingRight");
        } else {
          if (backgroundStyles.$ancestor) {
            var $ancestor = backgroundStyles.$ancestor;
            // If the background image repeats, there is no need to preserve the padding.
            if ("repeat" !== $ancestor.css("backgroundRepeat")) {
              calculatedHLBStyles.paddingLeft = $ancestor.css("paddingLeft");
              calculatedHLBStyles.paddingTop = $ancestor.css("paddingTop");
              calculatedHLBStyles.paddingBottom = $ancestor.css("paddingBottom");
              calculatedHLBStyles.paddingRight = $ancestor.css("paddingRight");
            }
          }
        }
        delete backgroundStyles.$ancestor;
        return $.extend({}, defaultHLBStyles, borderStyles, calculatedHLBStyles, backgroundStyles, animationOptimizationStyles);
      }
      /**
   * [filter filters elements, attributes, and styles from the HLB]
   * @param  {[DOM element]} $hlb [HLB]
   */
      function filter($hlb, $picked, hiddenElements) {
        filterStyles($hlb);
        filterHiddenElements($hlb, $picked, hiddenElements);
        filterBlacklistedElements($hlb);
        filterAttributes($hlb);
      }
      /**
   * [initializeStyles clones the original elements styles and the styles of all of its children.]
   * @param  {[DOM element]} $foundation [sanitized picked element]
   * @param  {[DOM element]} $hlb [The HLB]
   */
      function initializeStyles($foundation, $hlb, initialHLBRect, hiddenElements) {
        initializeHLBElementStyles($foundation, $hlb);
        initializeHLBDescendantStyles($foundation, $hlb, initialHLBRect, hiddenElements);
      }
      /**
   * [getComputedStyleCssText returns the cssText of an element]
   * @param  {[DOM element]} element [DOM element]
   * @return {[String]}              [Computed styles for an DOM element]
   * NOTE: Fixes bug described here: [https://bugzilla.mozilla.org/show_bug.cgi?id=137687]
   */
      function getComputedStyleCssText(element) {
        var style = window.getComputedStyle(element), cssText = "";
        if ("" !== style.cssText) {
          return style.cssText;
        }
        for (var i = 0; i < style.length; i++) {
          cssText += style[i] + ": " + style.getPropertyValue(style[i]) + "; ";
        }
        return cssText;
      }
      return {
        defaultBorder: defaultBorder,
        defaultPadding: defaultPadding,
        transitionProperty: transitionProperty,
        setHLBChildTextColor: setHLBChildTextColor,
        getHLBStyles: getHLBStyles,
        filter: filter,
        initializeStyles: initializeStyles,
        getComputedStyleCssText: getComputedStyleCssText
      };
    }($, page_util_common, run_conf_preferences, hlb_constants, run_inline_style_inline_style, run_util_array_utility);
    hlb_safe_area = function() {
      /////////////////////////
      // PRIVATE VARIABLES
      ////////////////////////
      /////////////////////////
      // PUBLIC PROPERTIES
      ////////////////////////
      // Default fraction of viewport hypotenuse that will define the safe area
      var HLB_SAFE_AREA = .05;
      /////////////////////////
      // PRIVATE FUNCTIONS
      ////////////////////////
      /**
   * [getUnsafePixels returns the amount of pixels from the
   * edge of the viewport that defines the safe zone]
   * @return {number} [pixels]
   */
      function getUnsafePixels() {
        var hypotenuse = Math.sqrt(Math.pow(window.innerHeight, 2) + Math.pow(window.innerWidth, 2));
        return hypotenuse * HLB_SAFE_AREA;
      }
      /////////////////////////
      // PUBLIC METHODS
      ////////////////////////
      // Returns a rectangle the represents the area in which the HLB is allowed to occupy
      function getSafeZoneBoundingBox() {
        var unsafePixels = getUnsafePixels();
        return {
          left: unsafePixels,
          top: unsafePixels,
          width: window.innerWidth - 2 * unsafePixels,
          height: window.innerHeight - 2 * unsafePixels,
          right: window.innerWidth - unsafePixels,
          bottom: window.innerHeight - unsafePixels
        };
      }
      return {
        getSafeZoneBoundingBox: getSafeZoneBoundingBox
      };
    }();
    hlb_positioning = function($, pref, hlbStyling, common, elemClassifier, hlbSafeArea, inlineStyle) {
      /////////////////////////
      // PRIVATE VARIABLES
      /////////////////////////
      var // Amount of characters that fits horizontally in HLB
      originCSS, // The HLB element's midpoint for animation
      translateCSS, CHAR_WIDTH_LIMIT = 50, // The HLB element's translation for final position
      isEditable = elemClassifier.isEditable, isVisualMedia = elemClassifier.isVisualMedia, isFormControl = elemClassifier.isFormControl;
      //////////////////////////////
      // PRIVATE FUNCTIONS
      //////////////////////////////
      /**
   * [getChildWidth returns the max-width for any child within the HLB.]
   * @param  {[DOM element]}    child       [Child element of the HLB]
   * @param  {[jQuery element]} $hlb [The HLB element]
   * @return {[Float]}                      [Max-width for child element]
   */
      function getChildWidth(child, $hlb) {
        var sum, hlbBoundingRect = $hlb[0].getBoundingClientRect(), childBoundingRect = child.getBoundingClientRect(), inheritedZoom = getInheritedZoom($hlb), leftDiff = childBoundingRect.left > hlbBoundingRect.left ? childBoundingRect.left - hlbBoundingRect.left : 0, leftSum = 0, rightSum = 0;
        $(child).parentsUntil($hlb.parent()).addBack().each(function() {
          var computedStyle = getComputedStyle(this);
          // marginRight has been commented out to fix issue on faast.org when HLBing
          // "About" in the top navigation.  I thought marginRight pushes its content to the left,
          // but in that case apparently not.  The rule of what marginRight does may be dependent
          // on other factors which I do not know, but removing it does not appear to break anything
          // that this function originally fixed.
          // rightSum += parseFloat(computedStyle.marginRight);
          rightSum += parseFloat(computedStyle.paddingRight) + parseFloat(computedStyle.borderRightWidth);
          leftSum += parseFloat(computedStyle.marginLeft) + parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.borderLeftWidth);
        });
        sum = leftSum + rightSum;
        if (leftDiff && leftDiff > leftSum) {
          leftDiff -= leftSum;
        } else {
          leftDiff = 0;
        }
        return hlbBoundingRect.width / inheritedZoom - sum - leftDiff;
      }
      /**
   * [limitChildWidth computes and sets the max-width for all HLB child elements if needed.]
   * @param  {[jQuery Element]} $hlb [The HLB element]
   */
      function limitChildWidth($hlb) {
        var fixit, allHLBChildren, hlbClientWidth, childRect, hlbRect, scrollDiff, hlbElementRangeWidth, hlbElementContentRangeWidth, // document.createRange() is used instead of scrollWidth because of content on http://www.nvblindchildren.org/
        // If content is pushed outside of the HLB to the left, we must use document.createRange().
        hlbElementRangeRect = document.createRange(), borderLeftAndRight = 2 * (parseFloat($hlb.css("borderWidth")) || 0);
        hlbElementRangeRect.selectNode($hlb[0]);
        hlbElementRangeWidth = hlbElementRangeRect.getBoundingClientRect().width - borderLeftAndRight;
        hlbElementRangeRect.selectNodeContents($hlb[0]);
        hlbElementContentRangeWidth = hlbElementRangeRect.getBoundingClientRect().width - borderLeftAndRight;
        if ($hlb[0].clientWidth < Math.max(hlbElementRangeWidth, hlbElementContentRangeWidth)) {
          if (true) {
            console.log("%cSPECIAL CASE: HLB child width limiting algorithm.", "background:orange;");
          }
          allHLBChildren = $hlb.find("*");
          fixit = true;
          allHLBChildren.each(function() {
            inlineStyle(this).maxWidth = getChildWidth(this, $hlb) + "px";
          });
        }
        hlbClientWidth = $hlb[0].clientWidth;
        // The following attempts to mitigate the vertical scroll bar by
        // setting the height of the element to the scroll height of the element.
        mitigateVerticalScroll($hlb);
        // Vertical scroll should only appear when HLB is as tall as the
        // safe area height and its scrollHeight is greater than its clientHeight
        addVerticalScroll($hlb);
        if (fixit && $hlb[0].clientWidth < hlbClientWidth) {
          if (true) {
            console.log("%cSPECIAL CASE: HLB child width limiting algorithm because vertical scrollbar.", "background:orange;");
          }
          scrollDiff = hlbClientWidth - $hlb[0].clientWidth;
          hlbRect = $hlb[0].getBoundingClientRect();
          allHLBChildren.each(function() {
            // Performing this check because http://www.nvblindchildren.org/give.html top navigation..
            childRect = this.getBoundingClientRect();
            if (childRect.left < hlbRect.left || childRect.right + scrollDiff > hlbRect.right) {
              inlineStyle(this).maxWidth = parseFloat(getComputedStyle(this).maxWidth) - scrollDiff + "px";
            }
          });
        }
        fixOverflowWidth($hlb);
      }
      /**
   * [isEligibleForConstrainedWidth determines if the HLB is eligible for limiting its width to 50 characters]
   * @param  {[jQuery element]} $hlb [HLB element]
   * @return {[Boolean]}     [if true, limit the width]
   */
      function isEligibleForConstrainedWidth($hlb) {
        var allowWrapping = true;
        // Return true if there are no other elements in the HLB that will affect the positioning
        // of this element
        // hlbElement
        //   \
        //    Grandparent
        //        \
        //        Parent (no siblings)
        //          \
        //           I am a loner! :(
        function hasSiblings(element) {
          return element.parentNode.childElementCount > 1;
        }
        function isLonerElement(element) {
          var isLoner = true;
          $(element).closest($hlb).each(function(index, elemToCheckForSiblings) {
            isLoner = $hlb[0] === elemToCheckForSiblings || !hasSiblings(elemToCheckForSiblings);
            return isLoner;
          });
          return isLoner;
        }
        // Return true if there is CSS that will cause an elements position to be based on another element's position
        function hasPositioningCss(css) {
          return "static" !== css.position || "none" !== css.float || "table-cell" !== css.display;
        }
        // Returns false when an element is not wrappable or, if part of an HLB,
        // wrapping the HLB would be bad (would break the intended layout, for example).
        function testAllowWrapping(index, element) {
          var css = getComputedStyle(element);
          allowWrapping = ("normal" === css.whiteSpace || "preWrap" === css.whiteSpace) && (!hasPositioningCss(css) || isLonerElement(element)) && !isVisualMedia(element) && !isFormControl(element) && !isEditable(element);
          // This fixed something on gwmicro, but broke other things.
          // if (css.display === 'table-cell') {
          //   allowWrapping = false;
          // }
          return allowWrapping;
        }
        // Fixes case on www.reddit.com/r/science when opening HLB on "The New Reddit Journal of Science"
        // We use max-width: 50ch to limit the width.  In this particular case, the font-size of the element
        // is 0, which causes the units of width limiting to have no effect because they are multiples of 0.
        if (0 === +$hlb.css("fontSize").charAt(0)) {
          return;
        }
        // Easiest way to fix issue when HLBing
        // "Summary Table Voluntary Product Accessibility Template" on http://www.gwmicro.com/Window-Eyes/VPAT/
        if ($hlb.is("table")) {
          return;
        }
        $hlb.find("*").addBack().each(testAllowWrapping);
        return allowWrapping;
      }
      /**
   * [getExtraLeftPadding returns addition left-padding of the HLB]
   * @param  {[jQuery element]} $hlb [HLB element]
   * @return {[integer]}                    [The additional left-padding]
   */
      function getExtraLeftPadding($hlb) {
        return parseInt($hlb.css("paddingLeft")) - hlbStyling.defaultPadding;
      }
      /**
   * [midPointDiff computes the distance between the midpoints of 2 rects]
   * @return {[object]}         [x and y difference between the 2 midpoints]
   */
      function midPointDiff(rect1, rect2) {
        var br1x = rect1.left + rect1.width / 2, br1y = rect1.top + rect1.height / 2, br2x = rect2.left + rect2.width / 2, br2y = rect2.top + rect2.height / 2;
        return {
          x: br1x - br2x,
          y: br1y - br2y
        };
      }
      /**
   * [limitWidth limits the width of the HLB to X characters, if eligible]
   * @param  {[jQuery element]} $originalElement    [original element]
   * @param  {[jQuery element]} $hlb         [HLB element]
   * @param  {[Integer]}        characterWidthLimit [number of characters the HLB is restricted to horizontally]
   */
      function limitWidth($originalElement, $hlb, characterWidthLimit) {
        // If the HLB is eligible for limiting the width to
        // characterWidthLimit characters
        if (isEligibleForConstrainedWidth($hlb)) {
          if (true) {
            console.log("%cSPECIAL CASE: 50 Character width limit.", "background:orange;");
          }
          // 'ch' units are equal to the width of the "0" character
          inlineStyle($hlb[0]).maxWidth = characterWidthLimit + "ch";
        }
      }
      /**
   * [mitigateVerticalScroll increases the height of the HLB to fit its content.]
   * @param  {[jQuery element]} $hlb [HLB]
   */
      function mitigateVerticalScroll($hlb) {
        var hlb = $hlb[0];
        // If the HLB has a vertical scrollbar and has a height less than the safe zone height
        if (common.hasVertScroll(hlb) && scaleRectFromCenter($hlb).height < hlbSafeArea.getSafeZoneBoundingBox().height) {
          // Set to the scroll height minus 4 (half of the padding)
          // It is necessary to subtract the padding because scrollHeight includes padding.
          inlineStyle(hlb).height = hlb.scrollHeight - parseInt(getComputedStyle(hlb).paddingBottom) + "px";
          // Now that we have set the height of the cloned element to the height of the scroll height...
          // we need to test that the element's height does not exceed the height of the safe area.
          constrainHeightToSafeArea($hlb);
        }
      }
      /**
   * [constrainPosition computes the distance between a rectangle and the
   * minimum distance it must travel to occupy another rectangle]
   * @param  {[DOM element]} element   [any element of a DOM]
   * @param  {[object]}      container [the bounding rect]
   * @return {[object]}                [x and y difference]
   */
      function constrainPosition(element) {
        var offset = {
          x: 0,
          y: 0
        }, container = hlbSafeArea.getSafeZoneBoundingBox();
        if (element.left < container.left) {
          offset.x -= container.left - element.left;
        }
        if (element.top < container.top) {
          offset.y -= container.top - element.top;
        }
        if (element.left + element.width > container.right) {
          offset.x += element.left + element.width - container.right;
        }
        if (element.top + element.height > container.bottom) {
          offset.y += element.top + element.height - container.bottom;
        }
        return offset;
      }
      /**
   * [constrainHeightToSafeArea constrains the height of the HLB to the safe area.
   * If HLB is an image, then it keeps the aspect ratio.]
   * @param  {[jQuery element]} $hlb [HLB element]
   */
      function constrainHeightToSafeArea($hlb) {
        var hlb = $hlb[0], hlbStyle = inlineStyle(hlb), originalHeight = scaleRectFromCenter($hlb).height, safeZoneHeight = hlbSafeArea.getSafeZoneBoundingBox().height;
        // Would the scaled element's height be greater than the safe area height?
        if (originalHeight > safeZoneHeight) {
          // height is now the "safe zone" height, minus the padding/border
          hlbStyle.height = safeZoneHeight / getFinalScale($hlb) / getInheritedZoom($hlb) - (hlbStyling.defaultBorder + hlbStyling.defaultBorder + parseInt($hlb.css("paddingTop")) + parseInt($hlb.css("paddingBottom"))) + "px";
          // Keep aspect ratio if HLB is an image
          if (isVisualMedia(hlb)) {
            // We need to recalculate the bounding client rect of the HLB element, because we just changed it.
            hlbStyle.width = hlb.getBoundingClientRect().width / getInheritedZoom($hlb) * (safeZoneHeight / originalHeight) + "px";
          }
        }
      }
      /**
   * [constrainWidthToSafeArea constrains the width of the HLB to the safe area.
   * If HLB is an image, then it keeps the aspect ratio.]
   * @param  {[jQuery element]} $hlb [HLB element]
   */
      function constrainWidthToSafeArea($hlb) {
        var hlb = $hlb[0], hlbStyle = inlineStyle(hlb), originalWidth = scaleRectFromCenter($hlb).width, safeZoneWidth = hlbSafeArea.getSafeZoneBoundingBox().width;
        // Would the scaled element's width be greater than the safe area width?
        if (originalWidth > safeZoneWidth) {
          // width is now the "safe zone" width, minus the padding/border
          hlbStyle.width = safeZoneWidth / getFinalScale($hlb) / getInheritedZoom($hlb) - 2 * (hlbStyling.defaultBorder + hlbStyling.defaultPadding + getExtraLeftPadding($hlb) / 2) + "px";
          // Keep aspect ratio if HLB is an image
          if (isVisualMedia(hlb)) {
            // We need to recalculate the bounding client rect of the HLB element, because we just changed it.
            hlbStyle.height = hlb.getBoundingClientRect().height / getInheritedZoom($hlb) * (safeZoneWidth / originalWidth) + "px";
          }
        }
      }
      /**
   * [initializeSize sets the height and width of the HLB to the original element's bounding
   * box height and width.  Useful for images.]
   * @param  {[jQuery element]} $hlb      [The HLB]
   * @param  {[Object]} $initialHLBRect [The highlight rect or the $originalElement  bounding client rect.]
   */
      function initializeSize($hlb, initialHLBRect) {
        var zoom = getPageZoom(), width = initialHLBRect.width / zoom + "px", height = initialHLBRect.height / zoom + "px";
        inlineStyle.set($hlb[0], {
          width: width,
          //Preserve dimensional ratio
          height: height
        });
        // This fixes the HLB being too wide or tall (lots of whitespace) for www.faast.org/news
        // when HLBing "News" header.  Because we copy computedStyles, we sometimes get an HLB
        // that has a child that is much wider or taller than the highlight, causing the HLB
        // to increase in width and height for the purpose of avoiding scrollbars.
        // TODO: cache descendants because we use it alot
        inlineStyle.set($hlb.find("*").get(), {
          maxWidth: width
        });
      }
      /**
   * [scaleRectFromCenter helper function for calculating a bounding box if an element were to be scaled from 50%50%]
   * @param  {[jQuery element]} $hlb [HLB]
   * @return {[object]}                     [A simulated bounding client rect]
   */
      function scaleRectFromCenter($hlb) {
        var clonedNodeBoundingBox = $hlb[0].getBoundingClientRect(), zoomFactor = getFinalScale($hlb);
        // The bounding box of the cloned element if we were to scale it
        return {
          left: clonedNodeBoundingBox.left - (clonedNodeBoundingBox.width * zoomFactor - clonedNodeBoundingBox.width) / 2,
          top: clonedNodeBoundingBox.top - (clonedNodeBoundingBox.height * zoomFactor - clonedNodeBoundingBox.height) / 2,
          width: clonedNodeBoundingBox.width * zoomFactor,
          height: clonedNodeBoundingBox.height * zoomFactor
        };
      }
      /**
   * [addVerticalScroll Adds a vertical scrollbar, if necessary, and corrects any
   *  dimension/positioning problems resulting from adding the scrollbar]
   * @param {[jQuery element]} $hlb [HLB element]
   */
      function addVerticalScroll($hlb) {
        var hlb = $hlb[0];
        if (common.hasVertScroll(hlb)) {
          inlineStyle(hlb).overflowY = "scroll";
          // Adding a vertical scroll may sometimes make content overflow the width
          fixOverflowWidth($hlb);
        }
      }
      /**
   * [fixOverflowWidth sets the width of the HLB to avoid horizontal scrollbars]
   * @param  {[jQuery element]} clonedNode [HLB]
   */
      function fixOverflowWidth($hlb) {
        var hlbElement = $hlb[0];
        // If there is a horizontal scroll bar
        if (hlbElement.clientWidth < hlbElement.scrollWidth) {
          if (true) {
            console.log("%cSPECIAL CASE: Fix overflow width.", "background:orange;");
          }
          inlineStyle.set(hlbElement, {
            width: hlbElement.scrollWidth + hlbStyling.defaultPadding + "px",
            maxWidth: "none"
          });
          // Again, we can't be positive that the increase in width does not overflow the safe area.
          constrainWidthToSafeArea($hlb);
        }
      }
      /**
   * [fixNegativeMargins gives the $hlb extra paddingTop and paddingLeft for elements
   * that are positioned negatively. document.createRange() was attempted to avoid looping over
   * all children, but children with background images are not accounted for...like on
   * ctsenaterepublicans.com]
   * @param  {[jQuery Element]} $hlb [HLB element]
   */
      function fixNegativeMargins($hlb, initialHLBRect) {
        var paddingLeft, paddingTop, childLeft, childTop, hasBackgroundImage, childBoundingRect, hlbBoundingRect = $hlb[0].getBoundingClientRect(), hlbLeft = hlbBoundingRect.left, hlbTop = hlbBoundingRect.top, extraLeft = 0, extraTop = 0, originalHLBLeftPadding = parseFloat($hlb.css("paddingLeft")), originalHLBTopPadding = parseFloat($hlb.css("paddingTop"));
        $hlb.find("*").each(function() {
          var thisStyle = inlineStyle(this);
          // These elements to not make sense to check because their
          // bounding rects are not consistent with their visual position
          if (!$(this).is("br, option") && ($(this).css("marginLeft").indexOf("-") !== -1 || $(this).css("marginTop").indexOf("-") !== -1)) {
            childBoundingRect = this.getBoundingClientRect();
            childLeft = childBoundingRect.left;
            childTop = childBoundingRect.top;
            hasBackgroundImage = "none" !== thisStyle.backgroundImage;
            paddingLeft = hasBackgroundImage ? 0 : parseFloat(thisStyle.paddingLeft);
            paddingTop = hasBackgroundImage ? 0 : parseFloat(thisStyle.paddingTop);
            if (childLeft + paddingLeft < hlbLeft && hlbLeft - childLeft - paddingLeft > extraLeft) {
              if (true) {
                console.log("%cSPECIAL CASE: Negative Margin-Left Fix.", "background:orange;");
              }
              extraLeft = hlbLeft - childLeft - paddingLeft;
            }
            if (childTop + paddingTop < hlbTop && hlbTop - childTop - paddingTop > extraTop) {
              if (true) {
                console.log("%cSPECIAL CASE: Negative Margin-Top Fix.", "background:orange;");
              }
              extraTop = hlbTop - childTop - paddingTop;
            }
          }
          // Negative margin effects boundingClientRect.
          // Removing padding on www.faast.org/news left column Device Loan Program uses negative left
          // margin, making the contents of the HLB move to the left, making the HLB have extra empty space
          // to the right of the HLB.  Ugh...
          // Subtract width from HLB if they use negative left margin
          if (extraLeft) {
            if (true) {
              console.log("%cSPECIAL CASE: Reset HLB width to use padding for width...", "background:orange;");
            }
            inlineStyle($hlb[0]).width = initialHLBRect.width / getPageZoom() - extraLeft + "px";
            fixOverflowWidth($hlb);
          }
        });
        inlineStyle.set($hlb[0], {
          paddingTop: extraTop ? originalHLBTopPadding + extraTop + hlbStyling.defaultPadding + hlbStyling.defaultBorder : originalHLBTopPadding,
          paddingLeft: extraLeft ? originalHLBLeftPadding + extraLeft + hlbStyling.defaultPadding + hlbStyling.defaultBorder : originalHLBLeftPadding
        });
      }
      //////////////////////////
      // PUBLIC FUNCTIONS
      //////////////////////////
      function getOriginCSS() {
        return originCSS;
      }
      function getTranslateCSS() {
        return translateCSS;
      }
      function setOriginCSS(val) {
        originCSS = val;
      }
      function setTranslateCSS(val) {
        translateCSS = val;
      }
      function getHlbZoom() {
        return 1.5;
      }
      // HLB transform scale necessary to provide the HLBExtraZoom size increase.
      // If zoom is on the body, then scaling needs to account for that since the HLB is outside of the body.
      function getFinalScale($hlb) {
        return getHlbZoom() * getStartingScale($hlb);
      }
      function getPageZoom() {
        return pref.get("zoom") || 1;
      }
      // HLB transform scale necessary to show HLB at same size as original highlighted content.
      function getStartingScale($hlb) {
        return $hlb.closest(document.body).length ? 1 : getPageZoom();
      }
      // Transform scale that affects HLB (was inherited from page zoom)
      // If the HLB is outside the body, this will be 1 (since the page zoom is on <body>)
      function getInheritedZoom($hlb) {
        return $hlb.closest(document.body).length ? getPageZoom() : 1;
      }
      function sizeHLB($hlb, $originalElement, initialHLBRect) {
        // Initialize height/width of the HLB
        if (true) {
          console.log("INITIAL: %o", initialHLBRect);
        }
        initializeSize($hlb, initialHLBRect);
        // Constrain the height and width of the HLB to the height and width of the safe area.
        constrainHeightToSafeArea($hlb);
        constrainWidthToSafeArea($hlb);
        // Limit the width of the HLB to a maximum of CHAR_WIDTH_LIMIT characters.
        limitWidth($originalElement, $hlb, CHAR_WIDTH_LIMIT);
        limitChildWidth($hlb);
        fixOverflowWidth($hlb);
        fixNegativeMargins($hlb, initialHLBRect);
      }
      /**
   * [positionHLB positions the HLB.]
   */
      function positionHLB($hlb, initialHLBRect, inheritedZoom) {
        // The minimum distance we must move the HLB for it to fall within the safe zone
        var constrainedOffset, hlb = $hlb[0], HLBBoundingBoxAfterZoom = scaleRectFromCenter($hlb), HLBBoundingBox = hlb.getBoundingClientRect(), // These are used in the positioning calculation.
        // They are the differences in height and width before and after the HLB is scaled.
        expandedWidthOffset = (HLBBoundingBoxAfterZoom.width - HLBBoundingBox.width) / 2, expandedHeightOffset = (HLBBoundingBoxAfterZoom.height - HLBBoundingBox.height) / 2, // The difference between the mid points of the hlb element and the original
        offset = midPointDiff(hlb.getBoundingClientRect(), initialHLBRect);
        // Update the dimensions for the HLB which is used for constraint calculations.
        // The offset of the original element and cloned element midpoints are used for positioning.
        HLBBoundingBoxAfterZoom.left = HLBBoundingBox.left - offset.x - expandedWidthOffset;
        HLBBoundingBoxAfterZoom.top = HLBBoundingBox.top - offset.y - expandedHeightOffset;
        HLBBoundingBoxAfterZoom.right = HLBBoundingBoxAfterZoom.left + HLBBoundingBoxAfterZoom.width;
        HLBBoundingBoxAfterZoom.bottom = HLBBoundingBoxAfterZoom.top + HLBBoundingBoxAfterZoom.height;
        // Constrain the scaled HLB to the bounds of the "safe area".
        // This returns how much to shift the box so that it falls within the bounds.
        // Note: We have already assured that the scaled cloned element WILL fit into the "safe area",
        // but not that it is currently within the bounds.
        constrainedOffset = constrainPosition(HLBBoundingBoxAfterZoom);
        // Add the difference between the HLB position and the minimum amount of distance
        // it must travel to be completely within the bounds of the safe area to the difference
        // between the mid points of the hlb element and the original
        offset.x += constrainedOffset.x;
        offset.y += constrainedOffset.y;
        // translateCSS and originCSS are used during deflation
        translateCSS = "translate(" + -offset.x / inheritedZoom + "px, " + -offset.y / inheritedZoom + "px)";
        // This is important for animating from the center point of the HLB
        originCSS = -offset.x / inheritedZoom + HLBBoundingBox.width / 2 / inheritedZoom + "px " + (-offset.y / inheritedZoom + HLBBoundingBox.height / 2 / inheritedZoom) + "px";
        // Position the HLB without it being scaled (so we can animate the scale).
        var startAnimationZoom = getPageZoom() / inheritedZoom, hlbStyles = {
          transform: "scale(" + startAnimationZoom + ") " + translateCSS,
          transformOrigin: originCSS
        };
        inlineStyle.set(hlb, hlbStyles);
      }
      return {
        getOriginCSS: getOriginCSS,
        getTranslateCSS: getTranslateCSS,
        setOriginCSS: setOriginCSS,
        setTranslateCSS: setTranslateCSS,
        getFinalScale: getFinalScale,
        getStartingScale: getStartingScale,
        getInheritedZoom: getInheritedZoom,
        sizeHLB: sizeHLB,
        positionHLB: positionHLB
      };
    }($, run_conf_preferences, hlb_styling, page_util_common, page_util_element_classifier, hlb_safe_area, run_inline_style_inline_style);
    hlb_dimmer = function($, constants, inlineStyle) {
      //////////////////////////////
      // PRIVATE VARIABLES
      /////////////////////////////
      var DIMMER_ID = "sitecues-background-dimmer", DIMMER_MIN_OPACITY = 0, DIMMER_MAX_OPACITY = .65, requestFrameFn = window.requestAnimationFrame;
      //////////////////////////////
      // PUBLIC FUNCTIONS
      /////////////////////////////
      /**
   * dimBackgroundContent creates the background dimmer element, positions it, and transitions opacity
   * @param  {number}        inflationSpeed      The duration of the opacity transition
   * @param  {Object} (optional) $parentOfDimmer  A selector describing the node that should parent the dimmer
   */
      function dimBackgroundContent(inflationSpeed, $foreground) {
        function createDimmerElement() {
          var documentElement = document.documentElement, width = Math.max(documentElement.scrollWidth, window.innerWidth), height = Math.max(documentElement.scrollHeight, window.innerHeight), // Draw a rectangle that does not capture any mouse events
          useCss = {
            display: "block",
            position: "absolute",
            zIndex: constants.MAX_ZINDEX,
            top: 0,
            left: 0,
            width: width + "px",
            height: height + "px",
            backgroundColor: "#000",
            pointerEvents: "none",
            willChange: "opacity"
          }, newDimmer = $("<sc>");
          inlineStyle.set(newDimmer[0], useCss);
          newDimmer = newDimmer.attr("id", DIMMER_ID)[0];
          animateOpacity(newDimmer, DIMMER_MIN_OPACITY, DIMMER_MAX_OPACITY, inflationSpeed);
          return newDimmer;
        }
        var dimmerElement = getDimmerElement() || createDimmerElement();
        // If created before, will ensure it's moved before the current hlb wrapper
        $(dimmerElement).insertBefore($foreground);
      }
      function animateOpacity(dimmerElement, startOpacity, endOpacity, speed, onCompleteFn) {
        var startTime = Date.now();
        function nextFrame() {
          var timeElapsed = Date.now() - startTime, percentComplete = timeElapsed > speed ? 1 : timeElapsed / speed, currentOpacity = startOpacity + (endOpacity - startOpacity) * percentComplete;
          inlineStyle(dimmerElement).opacity = currentOpacity;
          if (percentComplete < 1) {
            requestFrameFn(nextFrame);
          } else {
            if (onCompleteFn) {
              onCompleteFn();
            }
          }
        }
        nextFrame();
      }
      /**
   * [undimBackgroundContent transitions the opacity of the dimmer to DIMMER_MIN_OPACITY]
   * @param  {[integer]} deflationSpeed [The duration of the opacity transition]
   */
      function undimBackgroundContent(deflationSpeed) {
        var dimmer = getDimmerElement();
        if (dimmer) {
          // Still there
          animateOpacity(dimmer, DIMMER_MAX_OPACITY, DIMMER_MIN_OPACITY, deflationSpeed, onDimmerClosed);
        }
      }
      /**
   * [onDimmerClosed removes the dimmer element from the DOM]
   */
      function onDimmerClosed() {
        $(getDimmerElement()).remove();
      }
      function getDimmerElement() {
        return document.getElementById(DIMMER_ID);
      }
      return {
        dimBackgroundContent: dimBackgroundContent,
        undimBackgroundContent: undimBackgroundContent
      };
    }($, hlb_constants, run_inline_style_inline_style);
    hlb_animation = function(dimmer, common, hlbPositioning, platform, $, constants, nativeGlobal, inlineStyle) {
      var INFLATION_SPEED = 400, // Default inflation duration
      INFLATION_SPEED_FAST = 0, // Inflation duration when retargeting -- need > 0 so that animation end fires correctly
      DEFLATION_SPEED = 150, // Default deflation duration
      getStartingScale = hlbPositioning.getStartingScale;
      /**
   * [transitionInHLB animates the inflation of the HLB and background dimmer]
   * @param  {[Object]} data [The information passed by the HLB module to perform the animation]
   */
      function transitionInHLB(doShowQuickly, data) {
        // Dim the background!
        dimmer.dimBackgroundContent(INFLATION_SPEED, $("#" + constants.HLB_WRAPPER_ID));
        var $hlb = data.$hlb, speed = doShowQuickly ? INFLATION_SPEED_FAST : INFLATION_SPEED, startingScale = getStartingScale($hlb);
        inlineStyle($hlb[0]).transformOrigin = data.originCSS;
        animateCss($hlb[0], startingScale, hlbPositioning.getFinalScale($hlb), speed, data.translateCSS, data.onHLBReady);
      }
      /**
   * [transitionOutHLB animates and removes the HLB and background dimmer]
   * @param  {[Object]} data [The information passed by the HLB module to perform the animation]
   */
      function transitionOutHLB(data) {
        var $hlb = data.$hlb;
        // Un-dim the background!
        dimmer.undimBackgroundContent(DEFLATION_SPEED);
        // Do we bother animating the deflation?
        // Sometimes, if the user presses the spacebar extremely fast, the HLB is toggled
        // to close during the HLB inflation animation (transitionInHLB). Because this is
        // possible, it is also possible that the value of transform:scale is 1 by the time
        // we want to deflate, and thus the transition end event cannot be used as a callback
        // mechanism (because there is nothing to animate if scale is already 1).  Therefore,
        // we check to see if the HLB scale is greater than one, and if so, we animate the
        // deflation, otherwise, we just skip the deflation step
        if (!isHLBZoomed($hlb)) {
          data.onHLBClosed();
          return;
        }
        animateCss($hlb[0], getCurrentScale($hlb), getStartingScale($hlb), DEFLATION_SPEED, data.translateCSS, data.onHLBClosed);
      }
      function animateCss(hlbElement, startScale, endScale, speed, translateCSS, onCompleteFn) {
        var fromCss = {}, toCss = {
          transform: "scale(" + endScale + ") " + translateCSS
        };
        inlineStyle(hlbElement).transitionProperty = "none";
        // Clear any existing transition
        if (!speed) {
          // No animation -- do it immediately and return
          inlineStyle.set(hlbElement, toCss);
          onCompleteFn();
          return;
        }
        // Animate fromCss -> toCss
        fromCss.transform = "scale(" + startScale + ") " + translateCSS;
        inlineStyle.set(hlbElement, fromCss);
        function onTransitionEnd() {
          hlbElement.removeEventListener(platform.transitionEndEvent, onTransitionEnd);
          onCompleteFn();
        }
        // Allow the from CSS to register so that setting the toCss actually animates there
        // rather than just setting the toCss and ignoring the fromCss
        nativeGlobal.setTimeout(function() {
          toCss.transition = "transform " + speed + "ms ease-in-out";
          inlineStyle.set(hlbElement, toCss);
          hlbElement.addEventListener(platform.transitionEndEvent, onTransitionEnd);
        }, 0);
      }
      function getCurrentScale($hlb) {
        return common.getComputedScale($hlb[0]);
      }
      /**
   * [isHLBZoomed determines if the $hlb is scaled greater than one.
   * This is useful for the transitionOutHLB function.]
   * @return {Boolean} [if true, $hlb is scaled > zoom]
   * @example "matrix(1.5, 0, 0, 1.5, 1888.0610961914063, 2053.21875)"
   * @example "matrix(1, 0, 0, 1, 1888.0610961914063, 2053.21875)"
   */
      function isHLBZoomed($hlb) {
        // If there isn't any transform, then it isn't scaled.
        var scale = getCurrentScale($hlb);
        return scale > hlbPositioning.getStartingScale($hlb);
      }
      return {
        transitionInHLB: transitionInHLB,
        transitionOutHLB: transitionOutHLB
      };
    }(hlb_dimmer, page_util_common, hlb_positioning, run_platform, $, hlb_constants, mini_core_native_global, run_inline_style_inline_style);
    hlb_hlb = function($, eventHandlers, hlbPositioning, hlbStyling, pref, platform, elemClassifier, hlbAnimation, geo, metric, constants, events, inlineStyle) {
      /////////////////////////
      // PRIVATE VARIABLES
      ////////////////////////
      // Magic. Fixes problems where mouse highlight was SO accurate, that a simple rounding of a pixel
      // would unnecessarily wrap text. Seemed to be more prevalent on IE, fixes stuff for EEOC.
      // Value of 2 instead of 1 fixes wrapping text on this page for all headers:
      // http://www.windoweyesforoffice.com/sitecues/index.php
      var $picked, // The object chosen by the picker.
      $foundation, // The sanitized input, used as the basis for creating an $hlb.
      $hlb, // The cloned object, based on the $foundation.
      $hlbWrapper, // Container for both the HLB and background dimmer.
      initialHLBRect, // The highlight rect, if it exists, otherwise use the $foundation bounding client rect.
      inheritedZoom, EXTRA_HIGHLIGHT_PADDING = 2, // TODO: Figure out why this is needed and compute it.
      MOUSE_SAFETY_ZONE = 50, // Number of pixels the mouse is allowed to go outside the HLB, before it closes.
      FORMS_SELECTOR = "input, textarea, select", // Amount of zoom inherited from page's scale transform.
      removeTemporaryFoundation = false, // Did we create our own foundation? (becomes true for lonely elements)
      preventDeflationFromMouseout = false, // State tracking: should the HLB ignore mouse movement?
      isListeningToMouseEvents = false, // State tracking: are event listeners currently attached?
      isHLBClosing = false, // State tracking: is the HLB currently deflating?
      isSticky = false, // DEBUG: prevents the HLB from deflating on mouseout.
      foundations = {
        // Keys are tag names of "lonely" elements, which rely upon another element being present to work.
        // Values are functions that return a foundation (like the relied upon element).
        li: getValidListElement,
        fieldset: getValidFieldsetElement,
        input: getValidFormElement
      }, state = {};
      if (true) {
        // Boolean that determines if we log HLB information (only works in SC_DEV mode)
        var loggingEnabled = false;
      }
      //////////////////////////////
      // PRIVATE FUNCTIONS
      /////////////////////////////
      /**
   * [mapForm maps input values from one set of elements to another]
   * @param  {[jQuery element]} from [The HLB or The Foundation]
   * @param  {[jQuery element]} to   [The HLB or The Foundation]
   */
      function mapForm($from, $to, isHLBClosing) {
        // Get descendants of The HLB / The Foundation that may have a value.
        var i, $currentFromInput, $currentToInput, cloneIndex, fromInputType, $fromInputs = $from.find(FORMS_SELECTOR).addBack(FORMS_SELECTOR), $toInputs = $to.find(FORMS_SELECTOR).addBack(FORMS_SELECTOR), len = $fromInputs.length;
        for (i = 0; i < len; i += 1) {
          $currentFromInput = $fromInputs.eq(i);
          $currentToInput = $toInputs.eq(i);
          fromInputType = $currentFromInput.prop("type");
          cloneIndex = $currentToInput[0].getAttribute("data-sc-cloned");
          //If we're closing the HLB, and the current form element is part of a cloned foundation
          if (isHLBClosing && cloneIndex) {
            //Remove the index property from the HLB element
            $currentFromInput[0].removeAttribute("data-sc-cloned");
            //Query the DOM for the original form element, so we can copy the HLB form value back into the appropriate field
            $currentToInput = $('[data-sc-cloned="' + cloneIndex + '"]');
            //Remove the index from the original form element
            $currentToInput[0].removeAttribute("data-sc-cloned");
          }
          if ("radio" === fromInputType || "checkbox" === fromInputType) {
            $currentToInput.prop("checked", $currentFromInput.prop("checked"));
          } else {
            if (false) {
              // In Safari, text inputs opening up in HLB show their contents flush to the bottom
              // instead of vertically centered, unless we tweak the value of the input just after the styles are set
              $currentToInput.val($currentFromInput.val() + " ");
            }
            $currentToInput.val($currentFromInput.val());
          }
        }
      }
      function copyFormDataToPage() {
        // Copy any form input the user may have entered in the HLB back into the page.
        mapForm($hlb, $foundation, true);
      }
      // Return truthy value if a button is pressed on a mouse event.
      // There are three properties for mouse buttons, and they all work differently -- both
      // in terms of browsers and on mousemove events in particular.
      function isButtonDown(mouseEvent) {
        return "undefined" === typeof mouseEvent.buttons ? mouseEvent.which : mouseEvent.buttons;
      }
      /**
   * [onTargetChange is enabled when the HLB is READY.
   * Deflates the HLB if allowed.]
   * @param  {[DOM mousemove event]} event [Mousemove event.]
   */
      function onTargetChange(event) {
        var HLBBoundingBox, newTarget = event.target, mouseX = event.clientX, mouseY = event.clientY, isMouseDown = isButtonDown(event);
        // The mouse has never been within the HLB bounds or
        // debugging is enabled.
        if (preventDeflationFromMouseout || isSticky) {
          return;
        }
        // Mouse is currently hovering over the HLB
        if ($hlb[0] === newTarget) {
          return;
        }
        // Is the left mouse button pressed?
        // The user is click + dragging text to copy.
        if (isMouseDown) {
          return;
        }
        HLBBoundingBox = $hlb[0].getBoundingClientRect();
        // If the mouse coordinates are not within the bounds of
        // the HLB + MOUSE_SAFETY_ZONE, then deflate the HLB.
        if (mouseX < HLBBoundingBox.left - MOUSE_SAFETY_ZONE || mouseX > HLBBoundingBox.right + MOUSE_SAFETY_ZONE || mouseY < HLBBoundingBox.top - MOUSE_SAFETY_ZONE || mouseY > HLBBoundingBox.bottom + MOUSE_SAFETY_ZONE) {
          closeHLB(event);
        }
      }
      /**
   * [turnOnHLBEventListeners turns on HLB event handlers for deflation and scroll]
   */
      function turnOnHLBEventListeners() {
        if (isListeningToMouseEvents) {
          return;
        }
        isListeningToMouseEvents = true;
        // Register mouse mousemove handler for deflating the HLB
        $(document).on("mousemove", onTargetChange);
        // Register mousemove handler on the HLB element to turn on the ability to exit the HLB by mouse
        // This event handler is unique in that it unregisters itself once executed.
        $hlb.on("mousemove", onHLBHover);
        // Register an event handler for closing the HLB by clicking outside of it.
        $("body").on("click", onClick);
        // Make sure mousewheel scrolls HLB but not page
        eventHandlers.captureWheelEvents($hlb);
      }
      /**
   * [onHLBReady executes once the HLB is ready (completed inflation animation).
   * Adds the appropriate event listeners and emits hlb/ready]
   */
      function onHLBReady() {
        // Focus input or textarea
        if (elemClassifier.isEditable($hlb[0])) {
          $hlb.focus();
        }
        // Let the rest of the application know that the hlb is ready
        // Listeners: hpan.js, invert.js, highlight.js, speech.js
        events.emit(constants.HLB_READY, $hlb, state.highlight);
      }
      /**
   * [turnOffHLBEventListeners turns off HLB event handlers for deflation and scroll]
   */
      function turnOffHLBEventListeners() {
        if (!isListeningToMouseEvents) {
          return;
        }
        // UNTrap the mousewheel events (we don't want the event to even think when the user scrolls without the HLB)
        eventHandlers.releaseWheelEvents();
        $hlb[0].removeEventListener(platform.transitionEndEvent, onHLBReady);
        // Turn off the ability to deflate the HLB with mouse
        $(document).off("mousemove", onTargetChange);
        // Register mouse mousemove handler for deflating the HLB
        $("body").off("click", onClick);
        isListeningToMouseEvents = false;
      }
      /**
   * [closeHLB prepares and deflates the HLB.]
   */
      function closeHLB(event) {
        copyFormDataToPage();
        // Set this to true to prevent toggleHLB();
        isHLBClosing = true;
        turnOffHLBEventListeners();
        hlbAnimation.transitionOutHLB({
          $hlb: $hlb,
          $hlbWrapper: $hlbWrapper,
          originCSS: hlbPositioning.getOriginCSS(),
          translateCSS: hlbPositioning.getTranslateCSS(),
          onHLBClosed: function() {
            onHLBClosed(event);
          },
          transitionProperty: hlbStyling.transitionProperty
        });
      }
      function targetHLB(highlight, isRetargeting) {
        state.highlight = highlight;
        if (!highlight.fixedContentRect) {
          return;
        }
        // Highlight is present -- guaranteed to have
        // at least one picked element and fixedContentRect outlining the highlight
        $picked = highlight.picked;
        // Set module scoped variable so the rest of the program has reference.
        initialHLBRect = getInitialHLBRect(highlight);
        // Disable mouse highlighting so we don't copy over the highlighting styles from the picked element.
        // It MUST be called before getFoundation().
        events.emit("mh/pause");
        // Sanitize the input, by accounting for "lonely" elements.
        $foundation = getFoundation($picked);
        // Turn off listeners for the old HLB. createHLB() will add new ones.
        turnOffHLBEventListeners();
        createHLB(highlight, isRetargeting);
      }
      /**
   * [toggleHLB closes or creates a new HLB]
   */
      function toggleHLB(highlight) {
        // Sadly, the HLB animation system does not currently
        // know how to reverse an animation, so we cannot
        // toggle if currently deflating. :(
        if (isHLBClosing) {
          return;
        }
        if ($hlb) {
          closeHLB();
        } else {
          targetHLB(highlight);
        }
      }
      /**
   * This is called when the user presses a key that moves the mouse highlight
   * has changed while the HLB opens
   */
      function retargetHLB(highlight) {
        copyFormDataToPage();
        // Make sure we don't lose any of the form entry from the current HLB
        $hlb.remove();
        targetHLB(highlight, true);
      }
      /**
   * [getInitialHLBRect returns the initial width and height for our HLB when we first create it.
   * Preferably we utilize the highlight rectangle calculated by the picker.]
   * @param  {[object]} highlight [Information about the highlight --
   *          see https://equinox.atlassian.net/wiki/display/EN/Internal+sitecues+API#InternalsitecuesAPI-Highlight]
   * @return {[Object]}   [Dimensions and position]
   */
      function getInitialHLBRect(highlight) {
        return geo.expandOrContractRect(highlight.fixedContentRect, EXTRA_HIGHLIGHT_PADDING);
      }
      /**
   * [createHLB initializes, positions, and animates the HLB]
   * @param isRetargeting -- true if HLB is moving from one place to another, false if brand new HLB mode
   */
      function createHLB(highlight, isRetargeting) {
        // clone, style, filter, emit hlb/did-create,
        // prevent mousemove deflation, disable scroll wheel
        initializeHLB(highlight);
        hlbPositioning.sizeHLB($hlb, $foundation, initialHLBRect);
        hlbPositioning.positionHLB($hlb, initialHLBRect, inheritedZoom);
        // Now that we have extracted all the information from the foundation,
        // it is time to ask whether or not a temporary element has been used
        // and remove it if true.
        if (removeTemporaryFoundation) {
          $foundation.remove();
          removeTemporaryFoundation = false;
        }
        var viewData = {
          $hlb: $hlb,
          $hlbWrapper: $hlbWrapper,
          originCSS: hlbPositioning.getOriginCSS(),
          translateCSS: hlbPositioning.getTranslateCSS(),
          onHLBReady: onHLBReady,
          transitionProperty: hlbStyling.transitionProperty
        };
        // .setTimeout MIGHT be necessary for the browser to complete the rendering and positioning
        // of the HLB.  Before we scale, it absolutely must be positioned correctly.
        // Note: Interestingly enough, this timeout is unnecessary if we comment out the
        // background dimmer in transitionInHLB(), because the operation took long enough
        // for the browser to update/render the DOM.  This is here for safety (until proven otherwise).
        // If we use a .setTimeout, we have to solve the problem of functions being added to the stack before
        // the timeout completes...its a pain.
        hlbAnimation.transitionInHLB(isRetargeting, viewData);
      }
      /**
   * [initializeHLB is the first step in the creation process for the HLB.
   * This function is responsible for cloning the original element, mapping form data,
   * cloning child styles, filtering attributes, styles, and elements, and setting the
   * HLB with default styles and computed styles.]
   */
      function initializeHLB(highlight) {
        // Create and append the HLB and DIMMER wrapper element to the DOM
        $hlbWrapper = getOrCreateHLBWrapper();
        if (false) {
          // TODO try to remove this hack:
          // IE + text fields -- avoid bug where textfield was locked
          if (true && loggingEnabled) {
            console.log("SPECIAL CASE: HLB inside <body>");
          }
          $hlbWrapper.appendTo("body");
          inheritedZoom = pref.get("zoom") || 1;
        } else {
          $hlbWrapper.insertAfter("body");
          inheritedZoom = 1;
        }
        // Prevents mouse movement from deflating the HLB until mouse is inside HLB
        preventDeflationFromMouseout = true;
        // Clone, style, filter
        cloneHLB(highlight);
        turnOnHLBEventListeners();
        // Listeners: speech.js
        events.emit("hlb/did-create", $hlb, highlight);
        new metric.LensOpen().send();
      }
      /**
   * [cloneHLB clones elements and styles from the foundation to the HLB.]
   */
      function cloneHLB(highlight) {
        var hlbStyles;
        // The cloned element (HLB)
        $hlb = $($foundation[0].cloneNode(true));
        var hlb = $hlb[0];
        // Copies form values from the foundation to the HLB
        // Need to do this on a timeout in order to enable Safari input fix hack
        // Commenting out .setTimeout fixes problem on TexasAT
        // .setTimeout(function() {
        mapForm($foundation, $hlb);
        // }, 0);
        // Clone styles of HLB and children of HLB, so layout is preserved
        hlbStyling.initializeStyles($foundation, $hlb, initialHLBRect, highlight.hiddenElements);
        // Remove any elements and styles we dont want on the cloned element (such as <script>, id, margin)
        // Filtering must happen after initializeStyles() because we map all children of the original element
        // to the children of the HLB.  There is a possibility that filter will remove one of those children making
        // it much more difficult to map...
        hlbStyling.filter($hlb, $picked, highlight.hiddenElements);
        // This step must occur after filtering, because some of the HLB default styles (such as padding),
        // are filtered as well.  For example, if we want to HLB an element that has 20px of padding, we filter
        // the padding styles (blacklist) and apply default styles.
        hlbStyles = hlbStyling.getHLBStyles($picked, $foundation, highlight);
        // Set the styles for the HLB and append to the wrapping element
        inlineStyle.set(hlb, hlbStyles);
        $hlb.appendTo($hlbWrapper);
        // Fixes problem with TexasAT home page when opening the top nav (Home, Sitemap, Contact Us) in HLB
        hlbStyling.setHLBChildTextColor($hlb);
        // Set the ID of the hlb.
        hlb.id = constants.HLB_ID;
      }
      /**
   * [getValidListElement if the element chosen is an <li>, then we must wrap it with a <ul>
      We must also append this newly created <ul> to the DOM so the HLB
      module can utilize styles and positioning of the "original element"
      Basically, we create a new original element.]
   * @param  {[jQuery element]} originalElement [The element chosen by the picker]
   * @return {[jQuery element]}                 [The element the HLB will use to create itself]
   */
      function getValidListElement($picked) {
        var i, pickedElement = $picked[0], pickedElementComputedStyle = window.getComputedStyle(pickedElement), pickedElementBoundingBox = pickedElement.getBoundingClientRect(), // TODO: Seth: Why not use jQuery's .clone() ??
        pickedElementClone = pickedElement.cloneNode(true), $pickedAndDescendants = $picked.find("*").addBack(), $pickedCloneAndDescendants = $(pickedElementClone).find("*").addBack(), $foundation = $("<ul>").append(pickedElementClone);
        // ARCHITECTURE PROBLEM: This function does not take into account any elements in the DOM tree
        // between the "lonely" picked element and its "guardian" ul or ol ancestor.
        // Google search results currently have this structure.
        // https://www.google.com/#q=cats
        // Setting this to true will remove the $foundation from the DOM before inflation.
        // This is a very special case where the foundation element is not the same as the picked element.
        // NOTE: This is setting a module scoped variable so the rest of the program as access.
        removeTemporaryFoundation = true;
        // It is important to clone the styles of the parent <ul> of the original element, because it may
        // have important styles such as background images, etc.
        inlineStyle($foundation[0]).cssText = hlbStyling.getComputedStyleCssText($picked.parents("ul, ol")[0]);
        // Create, position, and style this element so that it overlaps the element chosen by the picker.
        inlineStyle.set($foundation[0], {
          position: "absolute",
          left: (pickedElementBoundingBox.left + window.pageXOffset) / inheritedZoom,
          top: (pickedElementBoundingBox.top + window.pageYOffset) / inheritedZoom,
          opacity: 0,
          padding: 0,
          margin: 0,
          width: pickedElementBoundingBox.width / inheritedZoom,
          listStyleType: pickedElementComputedStyle.listStyleType || "none"
        });
        $foundation.insertAfter("body");
        // Map all picked elements children CSS to cloned children CSS
        for (i = 0; i < $pickedAndDescendants.length; i += 1) {
          inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);
        }
        return $foundation;
      }
      // Implemented to fix issue on http://www.gwmicro.com/Support/Email_Lists/ when HLBing Subscription Management
      function getValidFieldsetElement($picked) {
        var i, pickedElement = $picked[0], pickedElementsBoundingBox = pickedElement.getBoundingClientRect(), // TODO: Seth: Why not use jQuery's .clone() ??
        pickedElementClone = pickedElement.cloneNode(true), $pickedAndDescendants = $picked.find("*").addBack(), $pickedCloneAndDescendants = $(pickedElementClone).find("*").addBack(), $foundation = $("<sc>").append(pickedElementClone);
        // Setting this to true will remove the $foundation from the DOM before inflation.
        // This is a very special case where the foundation is not the same as the picked element.
        // NOTE: This is setting a module scoped variable so the rest of the program as access.
        removeTemporaryFoundation = true;
        // Create, position, and style this element so that it overlaps the element chosen by the picker.
        inlineStyle.set($foundation[0], {
          position: "absolute",
          left: (pickedElementsBoundingBox.left + window.pageXOffset) / inheritedZoom,
          top: (pickedElementsBoundingBox.top + window.pageYOffset) / inheritedZoom,
          opacity: 0,
          padding: 0,
          margin: 0,
          width: pickedElementsBoundingBox.width / inheritedZoom
        });
        $foundation.insertAfter("body");
        // Map all picked elements children CSS to cloned children CSS
        for (i = 0; i < $pickedAndDescendants.length; i += 1) {
          inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);
        }
        return $foundation;
      }
      function setCloneIndexOnFormDescendants($picked) {
        var i, $formDescendants = $picked.find(FORMS_SELECTOR).addBack(FORMS_SELECTOR);
        for (i = 0; i < $formDescendants.length; i++) {
          $formDescendants[i].setAttribute("data-sc-cloned", i + 1);
        }
      }
      // Implemented to fix issue on http://www.gwmicro.com/Support/Email_Lists/ when HLBing Subscription Management
      function getValidFormElement($picked) {
        var i, pickedElement = $picked[0], pickedElementsBoundingBox = pickedElement.getBoundingClientRect();
        //Set data attributes on each of the form input elements
        //This allows us to query the DOM for the original elements
        //when we want to give them the values entered into the HLB
        setCloneIndexOnFormDescendants($picked);
        var pickedElementClone = pickedElement.cloneNode(true), $pickedAndDescendants = $picked.find("*").addBack(), $pickedCloneAndDescendants = $(pickedElementClone).find("*").addBack(), $submitButton = $(), // TODO why? This was duplicating the button: $picked.closest('form').find('input[type="submit"],button[type="submit"]'),
        submitButtonClone = $submitButton.clone(true), $foundation = $("<form>").append(pickedElementClone, submitButtonClone);
        // Setting this to true will remove the $foundation from the DOM before inflation.
        // This is a very special case where the foundation is not the same as the picked element.
        // NOTE: This is setting a module scoped variable so the rest of the program as access.
        removeTemporaryFoundation = true;
        // Create, position, and style this element so that it overlaps the element chosen by the picker.
        inlineStyle.set($foundation[0], {
          position: "absolute",
          left: (pickedElementsBoundingBox.left + window.pageXOffset) / inheritedZoom,
          top: (pickedElementsBoundingBox.top + window.pageYOffset) / inheritedZoom,
          opacity: 0,
          padding: 0,
          margin: 0,
          width: pickedElementsBoundingBox.width / inheritedZoom
        });
        $foundation.insertAfter("body");
        // Map all picked elements children CSS to cloned children CSS
        for (i = 0; i < $pickedAndDescendants.length; i += 1) {
          inlineStyle($pickedCloneAndDescendants[i]).cssText = hlbStyling.getComputedStyleCssText($pickedAndDescendants[i]);
        }
        return $foundation;
      }
      /**
   * [getFoundation creates and returns a valid element for the HLB.
   *  SC-1629 - Lonely bullets
   *  It is possible that the picker chooses an element for the HLB that is invalid input, therefore,
   *  return the valid input for the HLB given the invalid input/valid input from the picker.]
   * @param  {[DOM element]} pickedElement   [The element chosen by the picker]
   * @return {[DOM element]}                 [The new element create from the element chosen by the picker]
   */
      function getFoundation($picked) {
        var tag;
        for (tag in foundations) {
          if (Object.prototype.hasOwnProperty.call(foundations, tag)) {
            if ($picked.is(tag)) {
              if (true && loggingEnabled) {
                console.log("%cSPECIAL CASE: Lonely " + tag + ".", "background:orange;");
              }
              return foundations[tag]($picked);
            }
          }
        }
        if (true && loggingEnabled) {
          console.log("%cTAG: " + $picked[0].tagName, "background:orange;");
        }
        return $picked;
      }
      /**
   * [onHLBHover is registered as a "mousemove" event handler when the HLB is ready, and unregisters
   * itself immediately after the mouse moves within the HLB element.  The purpose of this function
   * is to handle the case where the HLB is positioned outside of the mouse coordinates and allows the
   * deflation of the HLB by moving the mouse outside of the HLB area as well as enabling scrolling of the HLB.]
   */
      function onHLBHover() {
        // We only need to know if the mouse has been in the HLB, so remove it once we are certain.
        $hlb.off("mousemove");
        // Any mouse detection within the HLB turns on the ability to exit HLB by moving mouse
        preventDeflationFromMouseout = false;
      }
      function isElementInsideHlb(element) {
        return $hlb[0] === element || $.contains($hlb[0], element);
      }
      function onClick(event) {
        if ($hlb && !isElementInsideHlb(event.target)) {
          // If click is outside of HLB, close it
          // (Need to doublecheck this because HLB can sometimes be inside of <body>)
          toggleHLB();
        }
      }
      /**
   * [onHLBClosed executes once the HLB is deflated (scale = 1).  This function is
   * responsible for setting the state of the application to what it was before
   * any HLB existed.]
   */
      function onHLBClosed(event) {
        // Finally, remove the wrapper element for the HLB and dimmer
        removeHLBWrapper();
        hlbPositioning.setTranslateCSS(void 0);
        hlbPositioning.setOriginCSS(void 0);
        // Clean up "module scoped" vars
        isHLBClosing = false;
        // Listeners: hpan.js, highlight.js, speech.js
        events.emit("hlb/closed", event);
        $foundation = void 0;
        $hlb = void 0;
        $picked = void 0;
        if (true && loggingEnabled) {
          console.log("%c--------------- HLB DESTROYED -----------------", "color:orange; background:purple; font-size: 9pt");
        }
      }
      /**
   * [getHLBWrapper adds the sitecues HLB and DIMMER wrapper outside of the body.]
   */
      function getOrCreateHLBWrapper() {
        var $wrapper = $hlbWrapper || $("<sc>", {
          id: constants.HLB_WRAPPER_ID
        });
        inlineStyle.set($wrapper[0], {
          padding: 0,
          margin: 0,
          top: 0,
          left: 0,
          position: "absolute",
          overflow: "visible"
        });
        return $wrapper;
      }
      /**
   * [removeHLBWrapper removes the sitecues HLB and DIMMER wrapper]
   */
      function removeHLBWrapper() {
        if ($hlbWrapper) {
          $hlbWrapper.remove();
          $hlbWrapper = null;
        }
      }
      //////////////////////////////////
      // PUBLIC FUNCTIONS
      //////////////////////////////////
      // Return the current DOM element for the HLB or falsey value if there is no HLB
      function getElement() {
        return $hlb && $hlb[0];
      }
      // Public methods.
      if (true) {
        console.log("%cToggle HLB logging by executing : sitecues.toggleHLBLogging();", "background:black;color:white;font-size: 11pt");
        /**
     * [toggleStickyHLB enables/disables HLB deflation]
     * @return {[Boolean]} [True if deflation is disabled.  False if deflation is enabled.]
     */
        sitecues.toggleStickyHLB = function() {
          isSticky = !isSticky;
          return isSticky;
        };
        sitecues.toggleHLBLogging = function() {
          loggingEnabled = !loggingEnabled;
          return loggingEnabled;
        };
      }
      return {
        getElement: getElement,
        toggleHLB: toggleHLB,
        retargetHLB: retargetHLB
      };
    }($, hlb_event_handlers, hlb_positioning, hlb_styling, run_conf_preferences, run_platform, page_util_element_classifier, hlb_animation, page_util_geo, run_metric_metric, hlb_constants, run_events, run_inline_style_inline_style);
    page_positioner_util_element_info = function(elementMap, state, platform, events, arrayUtil, hlb) {
      var originalBody, docElem, didCacheBPElements, bpElementMap, isInitialized;
      function getScale(element, position) {
        // If we've never scaled this element before, it's possible that this element is inheriting a transformation from the original body
        // It's important that we know the resolved transformation so that we can calculate the element's untransformed dimensions.
        // This method is less expensive than computing the resolved transformation, and the math is simpler
        var fixed = "fixed" === position, // In IE, fixed elements do not inherit transformations
        inheritedScale = !(fixed && false) && isInOriginalBody(element);
        return elementMap.getField(element, "scale") || (inheritedScale ? state.completedZoom : 1);
      }
      function setScale(element, value) {
        elementMap.setField(element, "scale", value);
      }
      function getPosition(element) {
        return getCacheValue(element, "position");
      }
      function setPosition(element, value) {
        setCacheValue(element, "position", value);
      }
      function getCacheValue(element, property) {
        return elementMap.getField(element, "cache_" + property);
      }
      function setCacheValue(element, property, value) {
        elementMap.setField(element, "cache_" + property, value);
      }
      function clearCacheValue(element, property) {
        elementMap.setField(element, "cache_" + property, void 0);
      }
      function addSubroots(element, newSubroots) {
        elementMap.setField(element, "subroots", getSubroots(element).concat(newSubroots));
      }
      function clearSubroots(element) {
        elementMap.setField(element, "subroots", []);
      }
      function removeSubroots(element, oldSubroots) {
        if (!Array.isArray(oldSubroots)) {
          oldSubroots = [ oldSubroots ];
        }
        var subroots = getSubroots(element);
        oldSubroots.forEach(function(subroot) {
          var index = subroots.indexOf(subroot);
          if (index !== -1) {
            subroots.splice(index, 1);
          }
        });
        elementMap.setField(element, "subroots", subroots);
      }
      function setSubroots(element, subroots) {
        elementMap.setField(element, "subroots", subroots);
      }
      function getSubroots(element) {
        return elementMap.getField(element, "subroots") || [];
      }
      function getRoot(element) {
        return elementMap.getField(element, "root");
      }
      function setRoot(element, root) {
        elementMap.setField(element, "root", root);
      }
      function getPlaceholderOwner(element) {
        return elementMap.getField(element, "placeholderFor");
      }
      function getPlaceholder(element) {
        return elementMap.getField(element, "placeholder");
      }
      function setPlaceholder(element, placeholder) {
        elementMap.setField(element, "placeholder", placeholder);
      }
      function setHostBody(element, body) {
        elementMap.setField(element, "body", body);
      }
      // This returns the body the element is current parented within, either the auxiliary or original body
      function getHostBody(element) {
        // Root elements have a cached reference to their host body in the element map
        var body = elementMap.getField(element, "body");
        if (!body) {
          var ancestor = element;
          if (!ancestor.parentElement) {
            return null;
          }
          do {
            ancestor = ancestor.parentElement;
          } while ("body" !== ancestor.localName.toLowerCase() && ancestor !== docElem);
          body = ancestor === docElem ? null : ancestor;
        }
        return body;
      }
      function isPlaceholder(element) {
        return "placeholder" === element.className;
      }
      function isClone(element, value) {
        return getOrSet(element, "isClone", value);
      }
      function isOriginal(element) {
        return !isClone(element) && !isPlaceholder(element);
      }
      function isBPElement(element) {
        if (!didCacheBPElements) {
          var badge = document.getElementById("sitecues-badge"), bp = document.getElementById("scp-bp-container"), badgeElems = badge ? arrayUtil.from(badge.querySelectorAll("*")).concat(badge) : [], bpElems = bp ? arrayUtil.from(bp.querySelectorAll("*")).concat(bp) : [];
          badgeElems.concat(bpElems).forEach(function(el) {
            bpElementMap.set(el, true);
          });
          // If the badge hasn't been inserted yet, don't bother saving the cached list (it's empty)
          didCacheBPElements = Boolean(badge);
        }
        return Boolean(bpElementMap.get(element));
      }
      function isHLBElement(element) {
        var hlbElement = hlb.getElement();
        if (hlbElement) {
          var ancestor = element.parentElement;
          while (ancestor) {
            if (ancestor === hlbElement) {
              return true;
            }
            ancestor = ancestor.parentElement;
          }
        }
        return false;
      }
      function isSitecuesElement(element) {
        return "sc" === element.localName || hasSitecuesClass(element) || isBPElement(element) || isHLBElement(element);
      }
      function hasSitecuesClass(element) {
        return arrayUtil.from(element.classList).some(function(className) {
          return 0 === className.indexOf("sc-");
        });
      }
      function isTransplantRoot(element, value) {
        if (true === value) {
          hasBeenTransplanted(element, true);
        }
        return getOrSet(element, "isRoot", value);
      }
      function isTransplantAnchor(element) {
        return isTransplantRoot(element) && !getRoot(element);
      }
      function hasBeenTransplanted(element, value) {
        return getOrSet(element, "hasBeenTransplanted", value);
      }
      function isInOriginalBody(element) {
        return getHostBody(element) === originalBody;
      }
      function getOrSet(element, field, value) {
        if ("undefined" !== typeof value) {
          elementMap.setField(element, field, value);
          return;
        }
        return elementMap.getField(element, field);
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        originalBody = document.body;
        docElem = document.documentElement;
        bpElementMap = new WeakMap();
        events.on("bp/did-insert-secondary-markup bp/content-loaded bp/did-insert-bp-element", function() {
          didCacheBPElements = false;
        });
      }
      return {
        getScale: getScale,
        setScale: setScale,
        getCacheValue: getCacheValue,
        setCacheValue: setCacheValue,
        clearCacheValue: clearCacheValue,
        getPosition: getPosition,
        setPosition: setPosition,
        getHostBody: getHostBody,
        setHostBody: setHostBody,
        getPlaceholder: getPlaceholder,
        setPlaceholder: setPlaceholder,
        getPlaceholderOwner: getPlaceholderOwner,
        getRoot: getRoot,
        setRoot: setRoot,
        clearSubroots: clearSubroots,
        getSubroots: getSubroots,
        setSubroots: setSubroots,
        addSubroots: addSubroots,
        removeSubroots: removeSubroots,
        isClone: isClone,
        isOriginal: isOriginal,
        isSitecuesElement: isSitecuesElement,
        isPlaceholder: isPlaceholder,
        hasBeenTransplanted: hasBeenTransplanted,
        isTransplantRoot: isTransplantRoot,
        isTransplantAnchor: isTransplantAnchor,
        isInOriginalBody: isInOriginalBody,
        init: init
      };
    }(page_positioner_util_element_map, page_zoom_state, run_platform, run_events, run_util_array_utility, hlb_hlb);
    page_positioner_style_lock_style_listener_selector_map = function(elementInfo) {
      // Caches references to elements that were selected the last time we queried the selector
      // Note: elements selected by fixed selectors are probably fixed, but haven't had their styles computed
      var selectorToElementsMap = {};
      // Private utility method
      function querySelector(selector) {
        var results;
        // Safari is incapable of processing certain selectors
        // example from chicagolighthouse.org :
        // input[type=\"number\"]::-webkit-inner-spin-button, input[type=\"number\"]::-webkit-outer-spin-button"
        try {
          results = Array.prototype.slice.call(document.querySelectorAll(selector), 0).filter(elementInfo.isOriginal);
          // Only original elements are considered for processing
          return results;
        } catch (e) {
          return [];
        }
      }
      function getCachedQuery(selector) {
        return selectorToElementsMap[selector] || [];
      }
      // if @selector is undefined, query all fixed selectors
      function makeNewQuery(selector) {
        selectorToElementsMap[selector] = querySelector(selector);
        return selectorToElementsMap[selector];
      }
      function cacheInitialQueries(selectors) {
        selectors.forEach(function(selector) {
          makeNewQuery(selector);
        });
      }
      return {
        cacheInitialQueries: cacheInitialQueries,
        makeNewQuery: makeNewQuery,
        getCachedQuery: getCachedQuery
      };
    }(page_positioner_util_element_info);
    page_positioner_style_lock_style_listener_query_manager = function(selectorMap, arrayUtil, nativeGlobal) {
      var resultsHandler, refreshTimer, selectorsToRefresh, // This is an arbitrary timeout, it saves us from requerying the same selectors needlessly in a short interval
      TIMER_DELAY = 50;
      function queue(selectors) {
        if (!Array.isArray(selectors)) {
          selectors = [ selectors ];
        }
        selectors.forEach(function(selector) {
          selectorsToRefresh.add(selector);
        });
        triggerQuery();
      }
      function triggerQuery() {
        if (!refreshTimer) {
          refreshTimer = nativeGlobal.setTimeout(function() {
            selectorsToRefresh.forEach(function(selector) {
              if (selector) {
                processQuery(selector);
              }
            });
            selectorsToRefresh.clear();
            refreshTimer = null;
          }, TIMER_DELAY);
        }
      }
      // Compare elements from the new selector query and the cached selector query
      // We don't know how the resolved value of an element will be impacted by
      // being newly selected or unselected by the given selector, it's possible
      // that a removed rule set was masking or applying the resolved style value we're
      // interested in, so return the difference between the two queries
      function processQuery(selector) {
        var cachedElements = selectorMap.getCachedQuery(selector), currentElements = selectorMap.makeNewQuery(selector), elementsToEvaluate = arrayUtil.symmetricDifference(cachedElements, currentElements);
        function handleResults(element) {
          resultsHandler(element, {
            selector: selector
          });
        }
        for (var i = 0, elementCount = elementsToEvaluate.length; i < elementCount; i++) {
          nativeGlobal.setTimeout(handleResults, 0, elementsToEvaluate[i]);
        }
      }
      function init(handler) {
        selectorsToRefresh = new Set();
        resultsHandler = handler;
      }
      return {
        queue: queue,
        init: init
      };
    }(page_positioner_style_lock_style_listener_selector_map, run_util_array_utility, mini_core_native_global);
    page_positioner_style_lock_style_listener_selectors = function(styleService, constants, arrayUtil) {
      var // Maps attribute name/value keys to buckets of fixed selectors
      // e.g. { id_foo : [selectorA], class_foo : [selectorA, selectorB] }
      // selectors composed of attributes without specific values are mapped as: { attributeName : [selector] }
      attributeValueToSelectorsMap = {}, // maps CSS properties to the selectors for the rule sets they are contained in
      propertyToSelectorsMap = {}, // maps selector to the properties that the style-listener is observing
      selectorToPropertiesMap = {}, // Maps selector to its composite attributes
      selectorToCompositeAttributesMap = {}, parsedSelectors = [], ID_REGEX = constants.ID_REGEX, CLASS_REGEX = constants.CLASS_REGEX, ATTRIBUTE_REGEX = constants.ATTRIBUTE_REGEX;
      // Identifies classes, ids, etc. that compose selectors
      function parseCompositeAttributes(selectors) {
        selectors.forEach(function(selector) {
          var name, match, originalSelector = selector, specialAttributes = {
            id: ID_REGEX,
            class: CLASS_REGEX
          }, results = selector.match(ATTRIBUTE_REGEX);
          while (results) {
            match = results[0];
            name = results[1];
            if (name) {
              attributeValueToSelectorsMap[name] = attributeValueToSelectorsMap[name] || [];
              // It's impractical to re-implement the comparison operations available when selecting by attribute value, so instead we just always
              // re-query selectors composed of mutated attributes, regardless of the attribute's new value
              arrayUtil.addUnique(attributeValueToSelectorsMap[name], originalSelector);
              selectorToCompositeAttributesMap[originalSelector] = selectorToCompositeAttributesMap[originalSelector] || [];
              arrayUtil.addUnique(selectorToCompositeAttributesMap[originalSelector], name);
            }
            // we remove attribute value matches, the values could
            // match the regex patterns for selecting by class or id
            // e.g. [data-foo="#id"]]
            selector = selector.replace(match, "");
            results = selector.match(ATTRIBUTE_REGEX);
          }
          for (name in specialAttributes) {
            if (specialAttributes.hasOwnProperty(name)) {
              var regex = specialAttributes[name];
              results = regex.exec(selector);
              while (results) {
                var value = results[1], key = name + "_" + value;
                selectorToCompositeAttributesMap[originalSelector] = selectorToCompositeAttributesMap[originalSelector] || [];
                arrayUtil.addUnique(selectorToCompositeAttributesMap[originalSelector], name);
                attributeValueToSelectorsMap[key] = attributeValueToSelectorsMap[key] || [];
                arrayUtil.addUnique(attributeValueToSelectorsMap[key], originalSelector);
                results = regex.exec(selector);
              }
            }
          }
        });
      }
      function getPropertiesBySelector(selector) {
        return selectorToPropertiesMap[selector];
      }
      // Get selectors for rule sets that contain declaration
      function getSelectorsForProperty(property) {
        var selectors = propertyToSelectorsMap[property];
        if (!selectors) {
          selectors = propertyToSelectorsMap[property] = styleService.getAllMatchingStyles(property).map(function(styleObject) {
            var selector = styleObject.rule.selectorText;
            // Map selectors to declarations so that we can check the resolved value of styles tied to that selector
            selectorToPropertiesMap[selector] = selectorToPropertiesMap[selector] || [];
            selectorToPropertiesMap[selector].push(property);
            return selector;
          });
          parseCompositeAttributes(selectors);
          parsedSelectors = arrayUtil.union(parsedSelectors, selectors);
        }
        return selectors;
      }
      function getCompositeAttributes(selectors) {
        var allAttributes = [];
        selectors.forEach(function(selector) {
          allAttributes = allAttributes.concat(selectorToCompositeAttributesMap[selector]);
        });
        return arrayUtil.unique(allAttributes);
      }
      // e.g. { id_foo : ['#foo > element', '#foo'] }
      function filterByAttributeValues(attribute, values) {
        // If an attribute value isn't provided, we return selectors mapped to just the attribute name
        // e.g. { data-sc-foo :  [selectorA] }
        if ("undefined" === typeof values) {
          return attributeValueToSelectorsMap[attribute];
        } else {
          if (!Array.isArray(values)) {
            values = [ values ];
          }
        }
        var filteredSelectors = [], length = values.length;
        for (var i = 0; i < length; i++) {
          var value = values[i], key = attribute + "_" + value, selectors = attributeValueToSelectorsMap[key];
          if (selectors) {
            filteredSelectors = filteredSelectors.concat(selectors);
          }
        }
        return filteredSelectors;
      }
      function filterByAttribute(name) {
        return filterByAttributeValues(name);
      }
      function filterByIds(currentId, oldId) {
        var values = [];
        // If ID hasn't changed we don't need to reprocess selectors that depend on it
        if (currentId === oldId) {
          return [];
        }
        if (oldId) {
          values.push(oldId);
        }
        if (currentId) {
          values.push(currentId);
        }
        return filterByAttributeValues("id", values);
      }
      // Return selectors for newly added and removed classes
      function filterByClasses(classes) {
        return filterByAttributeValues("class", classes);
      }
      function init(callback) {
        styleService.init(callback);
      }
      return {
        getCompositeAttributes: getCompositeAttributes,
        getForProperty: getSelectorsForProperty,
        getPropertiesBySelector: getPropertiesBySelector,
        filterByClasses: filterByClasses,
        filterByIds: filterByIds,
        filterByAttribute: filterByAttribute,
        init: init
      };
    }(page_style_service_style_service, page_positioner_constants, run_util_array_utility);
    page_positioner_transplant_anchors = function(exports, constants) {
      var addHandlers = [], removeHandlers = [], anchorElements = [], ANCHOR_STYLESHEET_ID = "sitecues-js-anchors", ANCHOR_ATTR = constants.ANCHOR_ATTR, VISIBLE = constants.VISIBLE, HIDDEN_ANCHOR_SELECTOR = constants.HIDDEN_ANCHOR_SELECTOR, VISIBLE_ANCHOR_SELECTOR = constants.VISIBLE_ANCHOR_SELECTOR;
      function get() {
        return anchorElements;
      }
      function forEach(fn) {
        anchorElements.forEach(fn);
      }
      function add(element) {
        if (anchorElements.indexOf(element) === -1) {
          anchorElements.push(element);
          callHandlers(element, addHandlers);
        }
      }
      function remove(element) {
        var index = anchorElements.indexOf(element);
        if (index >= 0) {
          anchorElements.splice(index, 1);
          callHandlers(element, removeHandlers);
        }
      }
      function callHandlers(element, handlers) {
        handlers.forEach(function(handler) {
          handler.call(element);
        });
      }
      function registerNewAnchorHandler(fn) {
        addHandlers.push(fn);
      }
      function registerRemovedAnchorHandler(fn) {
        removeHandlers.push(fn);
      }
      function insertStylesheet() {
        var visibleDeclarationBlock = " { visibility: visible; }\n", hiddenDeclarationBlock = " { visibility: hidden; }\n", styleText = HIDDEN_ANCHOR_SELECTOR + hiddenDeclarationBlock + VISIBLE_ANCHOR_SELECTOR + visibleDeclarationBlock;
        var sheet = document.createElement("style");
        sheet.id = ANCHOR_STYLESHEET_ID;
        sheet.innerText = styleText;
        document.head.insertBefore(sheet, document.head.firstChild);
      }
      // The anchor attribute is responsible for making it and its subtree visible, if its intended styling makes it visible
      function applyAnchorAttribute(element) {
        element.setAttribute(ANCHOR_ATTR, VISIBLE);
      }
      function onAddedAnchor() {
        /*jshint validthis: true */
        applyAnchorAttribute(this);
      }
      function onRemovedAnchor() {
        /*jshint validthis: true */
        this.removeAttribute(ANCHOR_ATTR);
      }
      function init() {
        insertStylesheet();
        registerNewAnchorHandler(onAddedAnchor);
        registerRemovedAnchorHandler(onRemovedAnchor);
      }
      exports.forEach = forEach;
      exports.get = get;
      exports.add = add;
      exports.remove = remove;
      exports.registerNewAnchorHandler = registerNewAnchorHandler;
      exports.registerRemovedAnchorHandler = registerRemovedAnchorHandler;
      exports.init = init;
      return exports;
    }(page_positioner_transplant_anchors, page_positioner_constants);
    page_positioner_style_lock_style_lock = function(exports, styleListener, constants, coreConstants, elementInfo, nativeGlobal) {
      var stylesheet, noop = function() {}, elementHandlerMap = new WeakMap(), declarationHandlerMap = {}, initCallbacks = [], lockSelectorMap = {}, stylesheetId = "sitecues-js-locked-styles", LOCK_ATTR = constants.LOCK_ATTR, READY_STATE = coreConstants.READY_STATE, readyState = READY_STATE.UNINITIALIZED;
      // This function is the entry point for the module. Depending on the arguments passed to the function, it will either
      // lock a single element's resolved property value, or lock all elements in the document matching a given resolved declaration
      function lock(target, opts) {
        // Target can be either an element or a declaration
        if (target.nodeType === Node.ELEMENT_NODE) {
          lockElementProperty(target, opts);
        } else {
          lockResolvedDeclaration(target, opts);
        }
      }
      // The handlers are run before and after the property's resolved value mutates
      function lockElementProperty(element, opts) {
        var handlers = opts.handlers || {}, property = opts.property;
        styleListener.init(function() {
          function onPropertyMutation(opts) {
            /*jshint validthis: true */
            var value = opts.toValue, results = [], elementHandlers = elementHandlerMap.get(this), propertyHandlers = elementHandlers[property], beforeHandlers = propertyHandlers.before, afterHandlers = propertyHandlers.after;
            for (var i = 0, beforeCount = beforeHandlers.length; i < beforeCount; i++) {
              results.push(beforeHandlers[i].call(this, opts));
            }
            lockStyle(this, property, value);
            for (var j = 0, afterCount = afterHandlers.length; j < afterCount; j++) {
              afterHandlers[j].call(this, results[j]);
            }
          }
          if (opts.lockValue) {
            // We're re-locking a previously applied lock, so we don't need
            // to worry about re-binding a new listener
            lockStyle(element, property, opts.lockValue);
            return;
          }
          var before = handlers.before ? [ handlers.before ] : [], after = handlers.after ? [ handlers.after ] : [], currentValue = getComputedStyle(element)[property], elementHandlers = elementHandlerMap.get(element) || {}, propertyHandlers = elementHandlers[property];
          if (propertyHandlers) {
            propertyHandlers.before.concat(before);
            propertyHandlers.after.concat(after);
          } else {
            elementHandlers[property] = {
              after: after,
              before: before
            };
          }
          elementHandlerMap.set(element, elementHandlers);
          lockStyle(element, property, currentValue);
          styleListener.bindPropertyListener(element, property, onPropertyMutation);
        });
      }
      // Before and after handlers will run respectively before and after a non-sitecues element's resolved style value mutates
      // to or from the declaration
      // The initial handler will run when we identify elements with a resolved value matching the declaration
      function lockResolvedDeclaration(declaration, handlers) {
        styleListener.init(function() {
          var initial = handlers.initial || noop, before = handlers.before || noop, after = handlers.after || noop, property = declaration.property, value = declaration.value, key = getDeclarationKey(declaration);
          function isValidLockTarget(element) {
            return !elementInfo.isSitecuesElement(element);
          }
          function fromHandler(args) {
            /*jshint validthis: true */
            if (isValidLockTarget(this)) {
              var results = [], property = args.property, value = args.fromValue, key = property + "_" + value, handlers = declarationHandlerMap[key];
              var beforeHandlers = handlers.before, afterHandlers = handlers.after;
              for (var i = 0, beforeCount = beforeHandlers.length; i < beforeCount; i++) {
                results.push(beforeHandlers[i].call(this, args));
              }
              unlockStyle(this, property);
              for (var j = 0, afterCount = afterHandlers.length; j < afterCount; j++) {
                afterHandlers[j].call(this, results[j]);
              }
            }
          }
          function toHandler(args) {
            /*jshint validthis: true */
            if (isValidLockTarget(this)) {
              var property = args.property, value = args.toValue, key = property + "_" + value, initialHandlers = declarationHandlerMap[key].initial;
              lockStyle(this, property, value);
              for (var i = 0, initialCount = initialHandlers.length; i < initialCount; i++) {
                initialHandlers[i].call(this, args);
              }
            }
          }
          var declarationHandlers = declarationHandlerMap[key];
          if (declarationHandlers) {
            // We're already listening for when elements lose or gain this resolved style value, add additional handlers
            declarationHandlers.before.push(before);
            declarationHandlers.after.push(after);
            declarationHandlers.initial.push(initial);
          } else {
            declarationHandlerMap[key] = {
              before: [ before ],
              after: [ after ],
              initial: [ initial ]
            };
            styleListener.registerToResolvedValueHandler(declaration, toHandler);
            styleListener.registerFromResolvedValueHandler(declaration, fromHandler);
          }
          // We run this asynchronously because it is an expensive operation
          // and we want to allow the browser to run other events before we begin it
          nativeGlobal.setTimeout(function() {
            var elements = styleListener.getElementsWithResolvedValue(declaration);
            function runHandler(element) {
              toHandler.call(element, {
                toValue: value,
                property: property
              });
            }
            for (var i = 0, elementCount = elements.length; i < elementCount; i++) {
              if (initial !== noop) {
                // Likewise each initial handler call is potentially expensive if we have to transplant the target
                nativeGlobal.setTimeout(runHandler, 0, elements[i]);
              } else {
                lockStyle(elements[i], property, value);
              }
            }
          }, 0);
        });
      }
      function getDeclarationKey(declaration) {
        return declaration.property + "_" + declaration.value;
      }
      function lockStyle(element, property, value) {
        var attributeName = LOCK_ATTR + property, valueLocks = lockSelectorMap[attributeName] || {}, lockSelector = valueLocks[value];
        if (!lockSelector) {
          lockSelector = "[" + attributeName + '="' + value + '"]';
          appendStylesheet(lockSelector + " { " + property + ": " + value + " !important; }\n");
          valueLocks[value] = lockSelector;
          lockSelectorMap[attributeName] = valueLocks;
        }
        element.setAttribute(attributeName, value);
      }
      function unlockStyle(element, property) {
        function removeLock(element, attribute) {
          var lockVal = element.getAttribute(attribute);
          element.removeAttribute(attribute);
          return lockVal;
        }
        // Remove all of the style locks for @element
        // if @property is undefined
        if (!property) {
          var attributes = Object.keys(lockSelectorMap);
          attributes.forEach(function(attribute) {
            removeLock(element, attribute);
          });
          return;
        }
        var lockAttribute = LOCK_ATTR + property;
        // If @element and @property are defined, remove the property lock from @element
        if (element && element.nodeType === Node.ELEMENT_NODE) {
          return removeLock(element, lockAttribute);
        }
        // If @element is undefined, unlock all elements with @property locks
        var propertyLockSelector = "[" + lockAttribute + "]", elements = document.querySelectorAll(propertyLockSelector);
        for (var i = 0, elementCount = elements.length; i < elementCount; i++) {
          removeLock(elements[i], lockAttribute);
        }
      }
      function isLocked(element, property) {
        var handlerMap = elementHandlerMap.get(element);
        return Boolean(handlerMap && handlerMap[property]);
      }
      function insertStylesheet(css) {
        stylesheet = document.createElement("style");
        stylesheet.id = stylesheetId;
        stylesheet.textContent = css;
        document.head.appendChild(stylesheet);
      }
      function appendStylesheet(css) {
        if (!stylesheet) {
          insertStylesheet(css);
        } else {
          stylesheet.textContent += css;
        }
      }
      function executeCallbacks() {
        initCallbacks.forEach(function(callback) {
          callback();
        });
        initCallbacks = null;
      }
      function init(callback) {
        switch (readyState) {
         case READY_STATE.UNINITIALIZED:
          initCallbacks.push(callback);
          readyState = READY_STATE.INITIALIZING;
          styleListener.init(function() {
            readyState = READY_STATE.COMPLETE;
            executeCallbacks();
          });
          break;

         case READY_STATE.INITIALIZING:
          initCallbacks.push(callback);
          break;

         case READY_STATE.COMPLETE:
          callback();
        }
      }
      exports.isLocked = isLocked;
      exports.unlockStyle = unlockStyle;
      exports.lock = lock;
      exports.init = init;
      return exports;
    }(page_positioner_style_lock_style_lock, page_positioner_style_lock_style_listener_style_listener, page_positioner_constants, run_constants, page_positioner_util_element_info, mini_core_native_global);
    page_positioner_style_lock_style_listener_style_listener = function(exports, queryManager, selectorMap, selectors, anchors, arrayUtil, elementInfo, elementMap, coreConstants, nativeGlobal, inlineStyle, transitionUtil, styleLock) {
      var domObserver, docElem, originalBody, observedProperties = [], callbacks = [], READY_STATE = coreConstants.READY_STATE, readyState = READY_STATE.UNINITIALIZED, // We always need to listen for inline style mutations
      observedAttributes = [ "style" ], /*
     * {
     *   property: ['valueA', 'valueB']
     * }
     *
     * Declarations we're listening for
     * */
      observedPropertyToValues = {}, /*
    * {
    *   property_value: [elementA, elementB]
    * }
    *
    * List of elements that have resolved to this declaration
    * */
      resolvedElementsMap = {}, /*
     * {
     *   direction_property_value: [handlerA, handlerB]
     * }
     *
     * Handlers keyed with their directional style hooks
     * e.g. to_position_fixed: [handlerFn]
     * */
      handlerMap = {}, /*
    * {
    *   elementReference: { property: [handler] }
    * }
    *
    * The outer map keys an element reference to a map of the properties we're listening for specifically for this element, and the handlers that fire when
    * this property mutates
    * */
      elementPropertyHandlerMap = new WeakMap(), observerOptions = {
        attributes: true,
        attributeOldValue: true,
        subtree: true,
        attributeFilter: observedAttributes
      }, elementsToUnresolvedPropertyMap = new WeakMap();
      // This handler is run on mutated elements /intended/ to be in the original body, which is to say elements currently nested in the
      // original body and original elements currently nested in the clone body
      function onOriginalElementMutations(mutations) {
        var len = mutations.length, selectorsToRefresh = [];
        function evaluateProperty(target, property) {
          evaluateResolvedValues(target, {
            property: property
          });
        }
        for (var i = 0; i < len; i++) {
          var mutation = mutations[i], target = mutation.target, attribute = mutation.attributeName, oldValue = mutation.oldValue;
          if (elementInfo.isClone(target) || elementInfo.isSitecuesElement(target)) {
            // We only consider changes to original elements when refreshing the fixed elementMap
            // We don't bother listening to sitecues element changes
            continue;
          }
          // This switch evaluates attribute mutations for their styling impact
          switch (attribute) {
           case "class":
            var // SVG elements in IE11 do not define classList
            newClasses = target.classList ? Array.prototype.slice.call(target.classList, 0) : target.className.baseVal.split(" "), oldClasses = oldValue ? oldValue.split(" ") : [], changedClasses = arrayUtil.symmetricDifference(newClasses, oldClasses);
            if (changedClasses.length) {
              selectorsToRefresh = selectorsToRefresh.concat(selectors.filterByClasses(changedClasses));
            }
            break;

           case "id":
            selectorsToRefresh = selectorsToRefresh.concat(selectors.filterByIds(target.id, oldValue));
            break;

           case "style":
            for (var j = 0, propertyCount = observedProperties.length; j < propertyCount; j++) {
              var property = observedProperties[j], inlineKey = getInlineKey(property), inlineValue = inlineStyle(target)[property], oldInlineValue = elementMap.getField(target, inlineKey), didChange = oldInlineValue !== inlineValue, isIntended = inlineStyle.getIntendedStyle(target, property) === inlineValue;
              if (didChange && isIntended) {
                elementMap.setField(target, inlineKey, inlineValue);
                nativeGlobal.setTimeout(evaluateProperty, 0, target, property);
              }
            }
          }
        }
        if (selectorsToRefresh.length) {
          queryManager.queue(selectorsToRefresh);
        }
      }
      function getInlineKey(property) {
        return property + "_inline_value";
      }
      function evaluateResolvedValues(element, opts) {
        var properties;
        if (opts.selector) {
          // Returns the css properties we collected this selector for
          properties = selectors.getPropertiesBySelector(opts.selector);
        } else {
          properties = [ opts.property ];
        }
        properties.forEach(function(property) {
          var lockVal, unresolvedProperties = elementsToUnresolvedPropertyMap.get(element);
          if (!unresolvedProperties) {
            unresolvedProperties = new Set();
            elementsToUnresolvedPropertyMap.set(element, unresolvedProperties);
          }
          if (unresolvedProperties.has(property)) {
            // We're already waiting to get this resolved value
            return;
          }
          var transitionInfo = transitionUtil.getTransitionInfo(element), isLocked = styleLock.isLocked(element, property);
          if (isLocked) {
            lockVal = styleLock.unlockStyle(element, property);
          }
          if (!transitionUtil.canPropertyTransition({
            transitionInfo: transitionInfo,
            property: property
          })) {
            var value = getComputedStyle(element)[property];
            if (isLocked) {
              styleLock.lock(element, {
                property: lockVal,
                lockValue: lockVal
              });
            }
            // If this style can't transition, we can compute its resolved value synchronously and run the relevant property handlers
            runPropertyHandlers(element, {
              property: property,
              value: value
            });
            return;
          }
          unresolvedProperties.add(property);
          // We also restore the inline property to its intended value
          inlineStyle.restore(element, property);
          transitionUtil.getFinalStyleValue(element, {
            property: property,
            transitionInfo: transitionInfo
          }).then(function(value) {
            // The inline value is restored to its previous (potentially overridden by us) value
            inlineStyle.restoreLast(element, property);
            unresolvedProperties.delete(property);
            // Evaluate if we should call style-listeners handlers when / if the property finishes transitioning
            runPropertyHandlers(element, {
              property: property,
              value: value
            });
          });
        });
      }
      function runPropertyHandlers(element, opts) {
        var handlerKey, fromHandlers = [], toHandlers = [], property = opts.property, value = opts.value, observedValues = observedPropertyToValues[property] || [], cachedValue = elementInfo.getCacheValue(element, property), elementHandlers = elementPropertyHandlerMap.get(element), propertyHandlers = elementHandlers && elementHandlers[property], handlerOpts = {
          element: element,
          property: property,
          toValue: value,
          fromValue: cachedValue
        };
        function runHandlers(directionHandlers) {
          directionHandlers.forEach(function(propertyHandlers) {
            for (var i = 0, handlerCount = propertyHandlers.length; i < handlerCount; i++) {
              propertyHandlers[i].call(element, handlerOpts);
            }
          });
        }
        if (propertyHandlers && cachedValue !== value) {
          // These element handlers run when the element's resolved value for a given style property has mutated from its cached value
          propertyHandlers.forEach(function(fn) {
            fn.call(element, handlerOpts);
          });
        }
        for (var i = 0, valueCount = observedValues.length; i < valueCount; i++) {
          var handlers, // Style value we're listening for, e.g. 'fixed' or 'absolute'
          observedValue = observedValues[i], declarationKey = property + "_" + observedValue, resolvedElements = resolvedElementsMap[declarationKey] || [], isMatching = value === observedValue, elementIndex = resolvedElements.indexOf(element), wasMatching = elementIndex !== -1;
          if (isMatching && !wasMatching) {
            handlerKey = "to_" + declarationKey;
            handlers = handlerMap[handlerKey];
            if (handlers) {
              toHandlers.push(handlers);
            }
            resolvedElements.push(element);
          } else {
            if (!isMatching && wasMatching) {
              handlerKey = "from_" + declarationKey;
              handlers = handlerMap[handlerKey];
              if (handlers) {
                fromHandlers.push(handlers);
              }
              resolvedElements.splice(elementIndex, 1);
            }
          }
        }
        elementInfo.setCacheValue(element, property, value);
        runHandlers(fromHandlers);
        runHandlers(toHandlers);
      }
      function disconnectDOMObserver() {
        var mutationRecords = domObserver.takeRecords();
        // Handle the remaining queued mutation records
        if (mutationRecords.length) {
          nativeGlobal.setTimeout(function(mutationRecords) {
            onOriginalElementMutations(mutationRecords);
          }, 0, mutationRecords);
        }
        domObserver.disconnect();
      }
      function observeOriginalElements() {
        anchors.forEach(function(element) {
          domObserver.observe(element, observerOptions);
        });
        domObserver.observe(originalBody, observerOptions);
      }
      function listenForDynamicStyling(property) {
        var propertySelectors = selectors.getForProperty(property), compositeAttributes = selectors.getCompositeAttributes(propertySelectors);
        selectorMap.cacheInitialQueries(propertySelectors);
        observedAttributes = arrayUtil.union(observedAttributes, compositeAttributes);
        observerOptions.attributeFilter = observedAttributes;
        disconnectDOMObserver();
        observeOriginalElements();
      }
      function getDeclarationKey(declaration) {
        return getPropertyValueKey(declaration.property, declaration.value);
      }
      function getPropertyValueKey(property, value) {
        return property + "_" + value;
      }
      function addHandlerToMap(handler, key) {
        if (!handlerMap[key]) {
          handlerMap[key] = [];
        }
        handlerMap[key].push(handler);
      }
      function registerResolvedValueHandler(declaration, handlerKey, handler) {
        var property = declaration.property, value = declaration.value, observedValues = observedPropertyToValues[property] || [], key = getPropertyValueKey(property, value), isPropertyObserved = observedProperties.indexOf(property) !== -1, isValueObserved = observedValues.indexOf(value) !== -1;
        if (!isValueObserved) {
          observedValues.push(value);
          observedPropertyToValues[property] = observedValues;
          if (!isPropertyObserved) {
            observedProperties.push(property);
          }
          nativeGlobal.setTimeout(function() {
            resolvedElementsMap[key] = getElementsWithResolvedValue(declaration);
            if (!isPropertyObserved) {
              listenForDynamicStyling(property);
            }
          }, 0);
        }
        addHandlerToMap(handler, handlerKey);
      }
      // Runs the passed handler when @element's resolved style @property value has changed
      function bindPropertyListener(element, property, handler) {
        var resolvedValue = getComputedStyle(element)[property], isPropertyObserved = observedProperties.indexOf(property) !== -1, handlers = elementPropertyHandlerMap.get(element) || {}, inlineValue = inlineStyle.getIntendedStyle(element, property);
        // Cache the current inline value so that we can tell if it changes
        elementMap.setField(element, getInlineKey(property), inlineValue);
        addToResolvedElementsMap(element, property, resolvedValue);
        // If we've already attached handlers to run when this element's resolved property value mutates,
        // we know that we're already listening for relevant document mutations
        if (handlers[property]) {
          handlers[property].push(handler);
        } else {
          handlers[property] = [ handler ];
          if (!isPropertyObserved) {
            listenForDynamicStyling(property);
            observedProperties.push(property);
          }
        }
        elementPropertyHandlerMap.set(element, handlers);
      }
      function unbindPropertyListener(element, property, handler) {
        var elementHandlers = elementPropertyHandlerMap.get(element) || {}, propertyHandlers = elementHandlers[property] || [], index = propertyHandlers.indexOf(handler);
        if (index >= 0) {
          propertyHandlers.splice(index, 1);
        }
        elementPropertyHandlerMap.set(element, elementHandlers);
      }
      // This map caches elements we know have a given resolved value
      function addToResolvedElementsMap(element, property, value) {
        var key = getPropertyValueKey(property, value);
        if (resolvedElementsMap[key]) {
          resolvedElementsMap[key] = arrayUtil.addUnique(resolvedElementsMap[key], element);
        } else {
          resolvedElementsMap[key] = [ element ];
        }
        elementInfo.setCacheValue(element, property, value);
      }
      // When the document is mutated such that an element's computed style matches the declaration, pass it to the handler
      function registerToResolvedValueHandler(declaration, handler) {
        var declarationKey = getDeclarationKey(declaration), handlerKey = "to_" + declarationKey;
        registerResolvedValueHandler(declaration, handlerKey, handler);
      }
      // When an element's computed style was matching the passed declaration, and the document is mutated such that it no longer matches
      function registerFromResolvedValueHandler(declaration, handler) {
        var declarationKey = getDeclarationKey(declaration), handlerKey = "from_" + declarationKey;
        registerResolvedValueHandler(declaration, handlerKey, handler);
      }
      function getElementsWithResolvedValue(declaration) {
        var property = declaration.property, value = declaration.value, observedValues = observedPropertyToValues[property], declarationKey = getDeclarationKey(declaration);
        // If we're already listening for elements with this resolved style value, return the list
        if (observedValues && observedValues.indexOf(value) >= 0 && resolvedElementsMap[declarationKey]) {
          return resolvedElementsMap[declarationKey];
        }
        var transplantAnchors = anchors.get(), allBodyElements = Array.prototype.slice.call(document.body.getElementsByTagName("*"), 0);
        resolvedElementsMap[declarationKey] = [];
        // If original elements are transplanted to the auxiliary body, include them in the search
        transplantAnchors.forEach(function(anchor) {
          allBodyElements = allBodyElements.concat(Array.prototype.slice.call(anchor.getElementsByTagName("*"), 0));
        });
        for (var i = 0, elementCount = allBodyElements.length; i < elementCount; i++) {
          var element = allBodyElements[i];
          if (getComputedStyle(element)[property] === value) {
            resolvedElementsMap[declarationKey].push(element);
            elementInfo.setCacheValue(element, property, value);
          }
        }
        return resolvedElementsMap[declarationKey];
      }
      function onNewTransplantAnchor() {
        /*jshint validthis: true */
        domObserver.observe(this, observerOptions);
      }
      function onRemovedTransplantAnchor() {
        disconnectDOMObserver();
        observeOriginalElements();
      }
      function executeCallbacks() {
        callbacks.forEach(function(callback) {
          callback();
        });
        callbacks = null;
      }
      function init(callback) {
        switch (readyState) {
         case READY_STATE.UNINITIALIZED:
          callbacks.push(callback);
          elementInfo.init();
          readyState = READY_STATE.INITIALIZING;
          docElem = document.documentElement;
          originalBody = document.body;
          domObserver = new MutationObserver(onOriginalElementMutations);
          selectors.init(function() {
            readyState = READY_STATE.COMPLETE;
            queryManager.init(evaluateResolvedValues);
            executeCallbacks();
          });
          anchors.registerNewAnchorHandler(onNewTransplantAnchor);
          anchors.registerRemovedAnchorHandler(onRemovedTransplantAnchor);
          break;

         case READY_STATE.INITIALIZING:
          callbacks.push(callback);
          break;

         case READY_STATE.COMPLETE:
          callback();
        }
      }
      exports.bindPropertyListener = bindPropertyListener;
      exports.unbindPropertyListener = unbindPropertyListener;
      exports.registerToResolvedValueHandler = registerToResolvedValueHandler;
      exports.registerFromResolvedValueHandler = registerFromResolvedValueHandler;
      exports.getElementsWithResolvedValue = getElementsWithResolvedValue;
      exports.init = init;
      return exports;
    }(page_positioner_style_lock_style_listener_style_listener, page_positioner_style_lock_style_listener_query_manager, page_positioner_style_lock_style_listener_selector_map, page_positioner_style_lock_style_listener_selectors, page_positioner_transplant_anchors, run_util_array_utility, page_positioner_util_element_info, page_positioner_util_element_map, run_constants, mini_core_native_global, run_inline_style_inline_style, page_util_transition_util, page_positioner_style_lock_style_lock);
    page_highlight_fixed_elements = function(constants, styleListener, arrayUtil, nativeGlobal) {
      var docElem, fixedElements, doDisable = false, POINTER_SHEET_ID = "sitecues-js-disable-pointer-events", POINTER_ATTR = constants.POINTER_ATTR;
      function enableMouseEventsForElement(element) {
        element.removeAttribute(POINTER_ATTR);
      }
      function enableMouseEventsForAll() {
        doDisable = false;
        fixedElements.forEach(enableMouseEventsForElement);
      }
      function disableMouseEventsForElement(element) {
        element.setAttribute(POINTER_ATTR, "");
      }
      function disableMouseEventsForAll() {
        doDisable = true;
        fixedElements.forEach(disableMouseEventsForElement);
      }
      function get() {
        return arrayUtil.fromSet(fixedElements);
      }
      function has(element) {
        return fixedElements.has(element);
      }
      function add() {
        /*jshint validthis: true */
        var elements = Array.isArray(this) ? this : [ this ];
        elements.forEach(function(element) {
          fixedElements.add(element);
          if (doDisable) {
            disableMouseEventsForElement(element);
          }
        });
      }
      function remove() {
        /*jshint validthis: true */
        fixedElements.delete(this);
        if (doDisable) {
          enableMouseEventsForElement(this);
        }
      }
      function insertStylesheet() {
        var pointerSelector = "[" + POINTER_ATTR + "]", pointerDeclarationBlock = " { pointer-events: none; }", style = document.createElement("style");
        style.innerHTML = pointerSelector + pointerDeclarationBlock;
        style.id = POINTER_SHEET_ID;
        document.head.appendChild(style);
      }
      function init() {
        var declaration = {
          property: "position",
          value: "fixed"
        };
        docElem = document.documentElement;
        fixedElements = new Set();
        insertStylesheet();
        styleListener.init(function() {
          styleListener.registerToResolvedValueHandler(declaration, add);
          styleListener.registerFromResolvedValueHandler(declaration, remove);
          nativeGlobal.setTimeout(function() {
            add.call(styleListener.getElementsWithResolvedValue(declaration));
          }, 0);
        });
      }
      return {
        enableMouseEvents: enableMouseEventsForAll,
        disableMouseEvents: disableMouseEventsForAll,
        get: get,
        has: has,
        add: add,
        remove: remove,
        init: init
      };
    }(page_positioner_constants, page_positioner_style_lock_style_listener_style_listener, run_util_array_utility, mini_core_native_global);
    page_highlight_move_keys = function($, mh, common, picker, bodyGeo, geo, events, fixedElements, nativeGlobal, inlineStyle) {
      var // Helps us know whether it's the first repeat and therefore how much to delay
      isKeyRepeating, isInitialized, repeatDelayTimer, hlbElement, isKeyStillDown, lastMoveCommand, $lastPicked, STEP_SIZE_VERT = 18, STEP_SIZE_HORIZ = 24, // Different step sizes because content tends to be wider than tall (lines of text)
      SPREAD_STEP_SIZE = 32, // How quickly do we fan out in our point testing?
      // If this is too large, we will go diagonally too often. Too small and we miss stuff that's not quite in line
      SPREAD_SLOPE = .1, MAX_SPREAD = 200, PIXELS_TO_PAN_PER_MS_HIGHLIGHT = .3, PIXELS_TO_PAN_PER_MS_HLB_SEARCH = 2, PIXELS_TO_SCROLL_PER_MS_HLB = .1, // For highlight moves, it's hard to track a quickly moving highlight with your eyes
      // This is the delay before the first repeat
      HIGHLIGHT_MOVE_FIRST_REPEAT_DELAY_MS = 400, // For highlight moves, prevent one keystroke from acting like two
      // This is the delay before additional repeats
      HIGHLIGHT_MOVE_NEXT_REPEAT_DELAY_MS = 250, MAX_PIXELS_TO_PAN = 999, HEADING_TAGS = {
        h1: 1,
        h2: 1,
        h3: 1,
        h4: 1,
        h5: 1,
        h6: 1
      }, DO_SHOW_DEBUG_POINTS = false, MH_EXTRA_WIDTH = 10, // Amount to account for padding/border of mouse highlight
      isShowingDebugPoints = false, // Queue of key navigation command
      navQueue = [], // Approximate amount of time for one animation frame
      ONE_ANIMATION_FRAME_MS = 16, // 16ms is about 60fps
      // Method for animation
      requestFrame = window.requestAnimationFrame, isNavigationEnabled = true, // labs.isEnabled('arrowKeyNav'), // We no longer use labs here, it is on by default
      SAFE_ZONE = 30;
      // Begin scrolling when we get this close to window edge
      // Move the highlight in the direction requested
      // We start with a point in the middle of the highlight
      // Then move the point in the direction until we
      // are outside of the current highlight and we can pick something from that point.
      // Whenever the point gets close to the edge, we pan/scroll to bring up new content until we cant anymore.
      function queueKey(event, keyName) {
        if (isKeyStillDown) {
          return;
        }
        if (true) {
          $(".sc-debug-dots").remove();
        }
        navQueue.push({
          keyName: keyName,
          shiftKey: event.shiftKey
        });
        clearKeyRepeat();
        isKeyStillDown = true;
        // Assume it's down until it's let up
        if (1 === navQueue.length) {
          // Key was just pressed
          dequeueNextCommand();
        }
      }
      function clearKeyRepeat() {
        isKeyRepeating = false;
        isKeyStillDown = false;
        clearTimeout(repeatDelayTimer);
      }
      // Execute the next navigation command off the front of the queue
      function dequeueNextCommand() {
        var nextCommand = navQueue.shift();
        if (nextCommand) {
          lastMoveCommand = null;
          var keyName = nextCommand.keyName;
          // Non-movement command
          if ("space" === keyName) {
            onSpace(nextCommand.shiftKey);
          } else {
            if ("esc" === keyName) {
              onEscape(keyName);
            } else {
              lastMoveCommand = nextCommand;
              onMovementCommand(nextCommand);
            }
          }
        } else {
          mh.setScrollTracking(true);
        }
      }
      function onMovementCommand(nextMove) {
        // Movement command
        if (hlbElement && !nextMove.shiftKey && performHLBScroll(nextMove)) {
          return;
        }
        if (isNavigationEnabled) {
          performMovement(nextMove);
        }
      }
      // TODO Use bottoms of lines when scrolling down, so that the bottom of a line
      // matches with the bottom of the HLB
      function getHLBLineTops(currTop) {
        // Measure height of one line for first visible text node
        var nodeIterator = document.createNodeIterator(hlbElement, NodeFilter.SHOW_TEXT, null, false), range = document.createRange(), lineTops = [], hlbZoom = common.getComputedScale(hlbElement);
        while (true) {
          var rawClientRects, textNode = nodeIterator.nextNode(), index = 0;
          if (!textNode) {
            break;
          }
          range.selectNode(textNode);
          rawClientRects = range.getClientRects();
          for (;index < rawClientRects.length; index++) {
            // Add each rectangle with a top greater than the last
            var numLines = lineTops.length, lineTop = Math.floor(rawClientRects[index].top / hlbZoom) + currTop;
            if (0 === numLines || lineTop > lineTops[numLines - 1]) {
              lineTops[numLines] = lineTop;
            }
          }
        }
        return lineTops;
      }
      function getLineInRange(origTop, direction, seekStart, seekEnd) {
        var currTop, minSeek = Math.min(seekStart, seekEnd), maxSeek = Math.max(seekStart, seekEnd), lineTops = getHLBLineTops(origTop), numLines = lineTops.length, index = direction < 0 ? numLines - 1 : 0;
        for (;index >= 0 && index < numLines; index += direction) {
          currTop = lineTops[index];
          if (currTop >= minSeek && currTop < maxSeek) {
            return currTop;
          }
        }
        // No line top found -- go as far as allowed
        return seekEnd;
      }
      // Scroll HLB and return truthy value if a significant scroll occurred
      function performHLBScroll(nextMove) {
        var targetTop, startScrollTime, direction, SCROLL_KEYS = // Map key codes to scroll direction
        {
          up: {
            dir: -1,
            type: "line"
          },
          /* up */
          pageup: {
            dir: -1,
            type: "page"
          },
          /* pageup */
          home: {
            dir: -1,
            type: "doc"
          },
          /* home */
          down: {
            dir: 1,
            type: "line"
          },
          /* down */
          pagedn: {
            dir: 1,
            type: "page"
          },
          /* pagedown */
          end: {
            dir: 1,
            type: "doc"
          }
        }, keyEntry = SCROLL_KEYS[nextMove.keyName], origTop = hlbElement.scrollTop, // Where it's scrolled to now
        lastTop = origTop, // Where we want to scroll to
        hlbHeight = hlbElement.offsetHeight, FUZZ_FACTOR = 5, // Make sure we can scroll far enough in all browsers
        maxTop = Math.max(0, hlbElement.scrollHeight - hlbHeight + FUZZ_FACTOR), MIN_SCROLL = 5, MAX_SCROLL = 50;
        if (!keyEntry) {
          return;
        }
        direction = keyEntry.dir;
        switch (keyEntry.type) {
         case "page":
          // Pageup/pagedown default behavior always affect window/document scroll
          // (simultaneously with element's local scroll).
          // So prevent default and define new scroll logic.
          targetTop = getLineInRange(origTop, direction, origTop + .8 * hlbHeight * direction, direction < 0 ? 0 : maxTop);
          break;

         case "line":
          targetTop = getLineInRange(origTop, direction, origTop + MIN_SCROLL * direction, origTop + MAX_SCROLL * direction);
          break;

         case "doc":
          hlbElement.scrollTop = direction < 0 ? 0 : maxTop;
          dequeueNextCommand();
          return true;
        }
        function smoothScroll() {
          var isTargetReached, msElapsed = Date.now() - startScrollTime + ONE_ANIMATION_FRAME_MS, // How many pixels to scroll from the original start
          pixelsToScroll = msElapsed * PIXELS_TO_SCROLL_PER_MS_HLB, // Value to scroll to for this animation frame
          midAnimationTop = Math.floor(lastTop + direction * pixelsToScroll);
          if (lastTop !== midAnimationTop) {
            hlbElement.scrollTop = midAnimationTop;
            if (direction < 0 ? midAnimationTop <= targetTop : midAnimationTop >= targetTop) {
              isTargetReached = true;
            }
          }
          // Didn't move or target reached
          if (isTargetReached) {
            // Finished
            if (isKeyStillDown) {
              performHLBScroll(nextMove);
            }
          } else {
            requestFrame(smoothScroll);
          }
        }
        // Sanity constraints on scrolling request
        targetTop = Math.round(constrained(targetTop, 0, maxTop));
        if (Math.abs(targetTop - origTop) > MIN_SCROLL) {
          startScrollTime = Date.now();
          smoothScroll();
          return true;
        }
      }
      function getHighlight() {
        var highlight = mh.getHighlight();
        return highlight && (highlight.isVisible || hlbElement) && highlight;
      }
      function performMovement(nextMove) {
        if (!getHighlight()) {
          return;
        }
        prepareMovement();
        var type = nextMove.keyName, shiftKey = nextMove.shiftKey;
        switch (type) {
         case "up":
          moveInDirection(0, -1, shiftKey);
          break;

         case "down":
          moveInDirection(0, 1, shiftKey);
          break;

         case "left":
          moveInDirection(-1, 0, shiftKey);
          break;

         case "right":
          moveInDirection(1, 0, shiftKey);
          break;

         case "heading":
          moveByTagName(HEADING_TAGS, shiftKey);
          break;

         default:
          if (true) {
            console.log("Illegal command");
          }
        }
      }
      // Prepare movement by hiding existing HLB and fixed position content so they do not interfere with elementFromPoint()
      function prepareMovement() {
        // Hide current HLB so it doesn't interfere with getElementFromPoint
        if (hlbElement) {
          inlineStyle(hlbElement).display = "none";
        }
        fixedElements.disableMouseEvents();
        !function(audio) {
          audio.init();
        }(audio_audio);
      }
      function fail(origPanX, origPanY) {
        // Don't process the rest of the command queue
        navQueue = [];
        // Restore mouse events and highlighting
        mh.setScrollTracking(true);
        fixedElements.enableMouseEvents();
        // Make lens visible again
        if (hlbElement) {
          inlineStyle(hlbElement).display = "block";
          // Scroll back to original position if the lens is now offscreen
          if ("number" === typeof origPanX) {
            var lensRect = hlbElement.getBoundingClientRect();
            if (lensRect.left < 0 && lensRect.right > window.innerWidth || lensRect.top < 0 || lensRect.bottom > window.innerHeight) {
              window.scrollTo(origPanX, origPanY);
            }
          }
        }
        !function(audio) {
          audio.playEarcon("bump");
        }(audio_audio);
      }
      function speakHighlight() {
        !function(commands) {
          commands.speakHighlight();
        }(page_keys_commands);
      }
      function succeed(doAllowRepeat, doSpeakText) {
        fixedElements.enableMouseEvents();
        if (doSpeakText) {
          speakHighlight();
        }
        if (hlbElement) {
          // Open new HLB
          if (true) {
            console.log("Retarget HLB");
          }
          retargetHLB();
        } else {
          if (doAllowRepeat && isKeyStillDown && lastMoveCommand) {
            // For movement, we need a delay between command, otherwise it can happen too fast
            var isFirstRepeat = !isKeyRepeating, repeatDelay = isFirstRepeat ? HIGHLIGHT_MOVE_FIRST_REPEAT_DELAY_MS : HIGHLIGHT_MOVE_NEXT_REPEAT_DELAY_MS;
            // Repeat last command if key is still pressed down
            isKeyRepeating = true;
            repeatDelayTimer = nativeGlobal.setTimeout(function() {
              onMovementCommand(lastMoveCommand);
            }, repeatDelay);
            return;
          }
        }
        dequeueNextCommand();
      }
      function moveInDirection(horizDir, vertDir, isShifted) {
        var // ** Panning state **
        // Starting pan time and location
        startPanTime, // Target end point for panning
        targetPanLeft, targetPanRight, targetPanUp, targetPanDown, lastPanX, lastPanY, highlight = getHighlight(), // *** Window size ***
        winRight = window.innerWidth - 1, winBottom = window.innerHeight - 1, // Farthest panning could possibly go
        maxPanUp = 0, maxPanLeft = bodyGeo.getBodyLeft(), maxPanRight = bodyGeo.getBodyRight() - winRight, maxPanDown = document.documentElement.scrollHeight - winBottom;
        updateLastPanXY();
        var doPickNewHighlight, // *** Highlight state ***
        origPanX = lastPanX, origPanY = lastPanY, origPickedRect = getHighlightRect(highlight, origPanX, origPanY), // *** Current position and direction of dot movement ***
        isHorizMovement = !vertDir, isVertMovement = !isHorizMovement, // x start point will be at the left edge, middle or right edge
        // depending on whether horizDir is -1, 0 or 1
        x = Math.floor(constrained(origPickedRect.left + (1 + horizDir) * origPickedRect.width / 2, 0, winRight)), // y start point will be at the top edge, middle or bottom edge
        // depending on whether vertDir is -1, 0 or 1
        y = Math.floor(constrained(origPickedRect.top + (1 + vertDir) * origPickedRect.height / 2, 0, winBottom)), // *** Spread state for dots as we go farther out (how it fans out) ****
        // The minimum size of a row (spread is how far from the center do to venture on that row)
        minSpread = Math.max((isHorizMovement ? origPickedRect.height : origPickedRect.width) / 2, SPREAD_STEP_SIZE + 1), // How many pixels from the original screen coordinate ar we?
        distanceFromOriginal = 0, // How many rows of points from the original aka how far from the original are we?
        numberOfDotRowsChecked = 0, // How fast to pan -- if HLB we want to pan immediately (better UX)
        pixelsToPanPerMs = hlbElement ? PIXELS_TO_PAN_PER_MS_HLB_SEARCH : PIXELS_TO_PAN_PER_MS_HIGHLIGHT;
        isShowingDebugPoints = DO_SHOW_DEBUG_POINTS && isShifted;
        // Show debugging dots if shift is pressed
        var doSpeakText = !isShowingDebugPoints && isShifted;
        $lastPicked = highlight.picked;
        function testPointIfOnscreen(x, y) {
          if (x < 0 || y < 0 || x > winRight || y > winBottom) {
            return null;
          }
          return testPoint(x, y, $lastPicked, "blue");
        }
        function testNextRowOfPointsAt(x, y, distance) {
          ++numberOfDotRowsChecked;
          var // Can we pick something from the center dot?
          $picked = testPoint(x, y, $lastPicked, "red"), // How far from center dot will we check?
          spreadEnd = constrained(distance * SPREAD_SLOPE, minSpread, MAX_SPREAD), // These are to enable the cross-hatch pattern that allows fewer points to be more effective
          toggleExtraY = 0, spreadStart = isHorizMovement ? SPREAD_STEP_SIZE * (numberOfDotRowsChecked % 2 ? .7 : 1.2) : SPREAD_STEP_SIZE;
          // Each iteration of this loop will test another dot on the current row of dots
          // spread out from the red center dot
          for (var spreadDistance = spreadStart; !$picked && spreadDistance < spreadEnd; spreadDistance += SPREAD_STEP_SIZE) {
            if (isVertMovement) {
              // Enable crosshatch pattern
              toggleExtraY = toggleExtraY ? 0 : SPREAD_STEP_SIZE / 2;
            }
            // Test dots in orthogonal directions from base direction of movement
            // Spreading out in a fan shape in the direction of travel
            $picked = testPointIfOnscreen(x - isVertMovement * spreadDistance, y - isHorizMovement * spreadDistance + toggleExtraY) || testPointIfOnscreen(x + isVertMovement * spreadDistance, y + isHorizMovement * spreadDistance + toggleExtraY);
          }
          if (!$picked) {
            return;
          }
          updateLastPanXY();
          if (isValidDirectionForNewHighlight(origPickedRect, $picked, origPanX, origPanY, lastPanX, lastPanY, horizDir, vertDir) && tryHighlight($picked)) {
            // Pan until highlight is fully visible onscreen (if necessary)
            var pickedRect = getHighlight().fixedContentRect;
            if (horizDir < 0 && pickedRect.left < SAFE_ZONE) {
              // Pan left far enough so that full width of the highlight is visible
              targetPanLeft = lastPanX + pickedRect.left - SAFE_ZONE;
            } else {
              if (horizDir > 0 && pickedRect.right > winRight - SAFE_ZONE) {
                // Pan right far enough so that full width of the highlight is visible
                targetPanRight = lastPanX + pickedRect.right - winRight + SAFE_ZONE;
              } else {
                if (vertDir < 0 && pickedRect.top < SAFE_ZONE) {
                  // Pan up far enough so that the full height of the highlight is visible
                  targetPanUp = lastPanY + pickedRect.top - SAFE_ZONE;
                } else {
                  if (vertDir > 0 && pickedRect.bottom > winBottom - SAFE_ZONE) {
                    targetPanDown = lastPanY + pickedRect.bottom - winBottom + SAFE_ZONE;
                  } else {
                    // No need to pan -- finish up
                    succeed(!hlbElement, doSpeakText);
                    return true;
                  }
                }
              }
            }
            // Start final highlight panning after all other operations are finished
            startPanning(false);
            return true;
          }
        }
        function updateLastPanXY() {
          lastPanX = window.pageXOffset;
          lastPanY = window.pageYOffset;
        }
        function startPanning(isHighlightStillNeeded) {
          // Don't allow the mouse highlight to follow scroll events from keyboard panning
          mh.setScrollTracking(false);
          targetPanUp = Math.floor(constrained(targetPanUp, maxPanUp, maxPanDown));
          targetPanLeft = Math.floor(constrained(targetPanLeft, maxPanLeft, maxPanRight));
          targetPanRight = Math.floor(constrained(targetPanRight, maxPanLeft, maxPanRight));
          targetPanDown = Math.floor(constrained(targetPanDown, maxPanUp, maxPanDown));
          doPickNewHighlight = isHighlightStillNeeded;
          startPanTime = Date.now();
          // Turn mousemove-to-highlight off
          // so that the invisible mouse doesn't pick stuff moving underneath it
          panInDirection();
        }
        function isPanningTargetReached(panX, panY) {
          return horizDir < 0 && panX <= targetPanLeft || horizDir > 0 && panX >= targetPanRight || vertDir < 0 && panY <= targetPanUp || vertDir > 0 && panY >= targetPanDown;
        }
        function panInDirection() {
          // Check if there is anything more to pan to
          var msElapsed = Date.now() - startPanTime, pixelsToPan = msElapsed * pixelsToPanPerMs, attemptPanX = Math.floor(constrained(lastPanX + pixelsToPan * horizDir, targetPanLeft, targetPanRight)), attemptPanY = Math.floor(constrained(lastPanY + pixelsToPan * vertDir, targetPanUp, targetPanDown));
          // TODO can we find a way to disable the mouse pointer
          // without making scrolling jerkier? The problem is we need pointer-events for checking the highlight
          // Maybe we can put a fixed 1px thing right under the mouse that captures it?
          // Unfortunately, fixed position stuff doesn't work with zoom!
          // Perhaps we can do a row of dots
          window.scrollTo(attemptPanX, attemptPanY);
          // If we haven't found anything yet, check the next row of points
          if (doPickNewHighlight && testNextRowOfPointsAt(x - horizDir, y, distanceFromOriginal + pixelsToPan)) {
            // FOUND SOMETHING!
            return;
          }
          if (isPanningTargetReached(attemptPanX, attemptPanY)) {
            // THE TARGET HAS BEEN REACHED!
            if (doPickNewHighlight) {
              // Was not successful
              fail(origPanX, origPanY);
            } else {
              // Successful -- already had a highlight
              succeed(!hlbElement, doSpeakText);
            }
            return;
          }
          // Continue panning
          requestFrame(panInDirection);
        }
        // Go quickly through visible possibilities
        while (true) {
          var panX = 0, panY = 0;
          if (horizDir) {
            x += horizDir * STEP_SIZE_HORIZ;
            if (x < SAFE_ZONE) {
              panX = SAFE_ZONE - x;
            } else {
              if (x > winRight - SAFE_ZONE) {
                panX = winRight - SAFE_ZONE - x;
              }
            }
          } else {
            y += vertDir * STEP_SIZE_VERT;
            if (y < SAFE_ZONE) {
              panY = SAFE_ZONE - y;
            } else {
              if (y > winBottom - SAFE_ZONE) {
                panY = winBottom - SAFE_ZONE - y;
              }
            }
          }
          if (panX || panY) {
            // NO HIGHLIGHT FOUND ON VISIBLE SCREEN (Haven't panned yet though ...)
            // Reached the edge -- but we haven't found a highlight yet.
            // We need to begin panning to find a highlight
            x += panX;
            y += panY;
            // Panning too much is crazy. Give up after MAX_PIXELS_TO_PAN pixels.
            // User can keep arrowing in that direction if they want ... but don't autoscroll forever!
            targetPanUp = lastPanY - MAX_PIXELS_TO_PAN;
            targetPanLeft = lastPanX - MAX_PIXELS_TO_PAN;
            targetPanRight = lastPanX + MAX_PIXELS_TO_PAN;
            targetPanDown = lastPanY + MAX_PIXELS_TO_PAN;
            startPanning(true);
            break;
          }
          distanceFromOriginal += isHorizMovement ? STEP_SIZE_HORIZ : STEP_SIZE_VERT;
          if (testNextRowOfPointsAt(x, y, distanceFromOriginal)) {
            break;
          }
        }
      }
      // Ensure that the entire newly picked item's rect is in the correct direction
      // It may not be if the spread picks an object that covers a a large area
      function isValidDirectionForNewHighlight(origPickedRect, $picked, origPanX, origPanY, panX, panY, horizDir, vertDir) {
        var newRect = $picked[0].getBoundingClientRect(), FUZZ_FACTOR = 9;
        if (horizDir > 0) {
          // Correct move to the right?
          return newRect.left + panX + FUZZ_FACTOR > origPickedRect.right + origPanX;
        }
        if (horizDir < 0) {
          // Correct move to the left?
          return newRect.right + panX - FUZZ_FACTOR < origPickedRect.left + origPanX;
        }
        if (vertDir > 0) {
          // Correct move down?
          return newRect.top + panY + FUZZ_FACTOR > origPickedRect.bottom + origPanY;
        }
        // Correct move up?
        return newRect.bottom + panY - FUZZ_FACTOR < origPickedRect.top + origPanY;
      }
      // The current target that we might want to pick/highlight
      // is not an ancestor of the last picked item, or vice-versa
      function isValidTarget(target, $lastPicked) {
        if (!$lastPicked) {
          return !!target;
        }
        return target && !$lastPicked.is(target) && !$.contains(target, $lastPicked[0]) && !$.contains($lastPicked[0], target);
      }
      function testPoint(x, y, $lastPicked, color) {
        var target = document.elementFromPoint(x, y);
        if (true && isShowingDebugPoints) {
          // Briefly display the points being tested
          var debugDiv = $('<div class="sc-debug-dots">').appendTo("html");
          inlineStyle.set(debugDiv[0], {
            position: "absolute",
            left: x + window.pageXOffset + "px",
            top: y + window.pageYOffset + "px",
            width: "0px",
            height: "0px",
            outline: "3px solid " + color,
            zIndex: 999999
          });
        }
        // Need to use something that's not a container of the last picked item
        if (!isValidTarget(target, $lastPicked)) {
          return null;
        }
        var $picked = picker.find(target);
        if (!$picked || !isValidTarget($picked[0], $lastPicked)) {
          return null;
        }
        return $picked;
      }
      function tryHighlight($picked) {
        var doKeepHighlightHidden = !!hlbElement;
        return mh.highlight($picked, false, false, doKeepHighlightHidden);
      }
      function moveByTagName(acceptableTagsMap, isReverse) {
        var treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false), $lastPicked = getHighlight().picked;
        function doesMatchTags(element) {
          if (!acceptableTagsMap[element.localName]) {
            return;
          }
          if (!isValidTarget(element, $lastPicked)) {
            return;
          }
          var $picked = $(element);
          if (!$picked.text().trim()) {
            return;
          }
          element.scrollIntoView(true);
          if (!tryHighlight($picked)) {
            return;
          }
          if (!isValidTarget(getHighlight().picked[0], $lastPicked)) {
            return;
          }
          // Successful highlight
          return true;
        }
        function searchDocument() {
          while (true) {
            var newNode = isReverse ? treeWalker.previousNode() : treeWalker.nextNode();
            if (!newNode) {
              return false;
            }
            if (doesMatchTags(newNode)) {
              return true;
            }
          }
        }
        // Set the starting point (can do with tree walker but doesn't look like the similar node iterator API can do this)
        if ($lastPicked) {
          treeWalker.currentNode = $lastPicked[0];
        }
        if (!searchDocument()) {
          // Search one more time, from beginning instead of mid-point.
          // Wraps to beginning/end of document depending on direction.
          // This doesn't happen often so code here is optimized for size rather than speed.
          // Don't try to use H command to navigate headings in the fixed areas.
          treeWalker.currentNode = isReverse ? treeWalker.currentNode = $(document.body).find("*").last()[0] : document.body;
          if (!searchDocument()) {
            fail();
            return;
          }
        }
        // Adjust final scroll position so that highlight that it's not jammed against the top/left of window unless it needs to
        window.scrollBy(-100, -100);
        succeed();
      }
      function constrained(value, min, max) {
        if (value < min) {
          return min;
        }
        if (value > max) {
          return max;
        }
        return value;
      }
      function getHighlightRect(highlight, pageOffsetX, pageOffsetY) {
        // First get the outline in absolute coordinates
        var outlineRect = geo.expandOrContractRect(highlight.absoluteRect, -MH_EXTRA_WIDTH);
        // Next subtract the current scroll position
        outlineRect.left -= pageOffsetX;
        outlineRect.right -= pageOffsetX;
        outlineRect.top -= pageOffsetY;
        outlineRect.bottom -= pageOffsetY;
        return outlineRect;
      }
      function toggleHLB() {
        !function(hlb) {
          hlb.toggleHLB(getHighlight());
        }(hlb_hlb);
      }
      function retargetHLB() {
        !function(hlb) {
          // Nothing found .. close HLB and enable highlight on last known item
          hlb.retargetHLB(getHighlight());
        }(hlb_hlb);
      }
      function onSpace(doSpeakText) {
        if (hlbElement || getHighlight()) {
          // Has an HLB or a highlight -- toggle HLB
          toggleHLB();
        } else {
          if (isNavigationEnabled) {
            // No highlight -- make one
            mh.autoPick();
          }
        }
        if (doSpeakText) {
          speakHighlight();
        }
      }
      function onEscape() {
        if (hlbElement) {
          toggleHLB();
        } else {
          // TODO next arrow key is still moving highlight
          // Probably the invisible mouse cursor is messing us up as well
          mh.hide(true);
          navQueue = [];
        }
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        fixedElements.init();
        $(window).on("keyup", function() {
          clearTimeout(repeatDelayTimer);
          isKeyStillDown = false;
          isKeyRepeating = false;
        });
        events.on("hlb/did-create", function($hlb) {
          hlbElement = $hlb[0];
        });
        events.on("hlb/closed", function() {
          hlbElement = null;
        });
      }
      return {
        queueKey: queueKey,
        init: init
      };
    }($, page_highlight_highlight, page_util_common, page_highlight_pick, page_zoom_util_body_geometry, page_util_geo, run_events, page_highlight_fixed_elements, mini_core_native_global, run_inline_style_inline_style);
    page_keys_commands = function(zoomMod, moveKeys, mh, reset) {
      return {
        decreaseZoom: function(event) {
          zoomMod.init();
          zoomMod.beginZoomDecrease(event);
        },
        increaseZoom: function(event) {
          zoomMod.init();
          zoomMod.beginZoomIncrease(event);
        },
        stopZoom: function() {
          zoomMod.zoomStopRequested();
        },
        queueKey: function(event, keyName) {
          moveKeys.init();
          moveKeys.queueKey(event, keyName);
        },
        resetSitecues: function(event) {
          // 0 by itself -> reset zoom
          // Alt+0 -> Also reset speech
          // Alt+Shift+0 -> Full reset for all of sitecues, including themes, cursors, cues ... everything
          // Turn off zoom
          reset.resetZoom();
          if (event.altKey) {
            reset.resetAudio(function() {
              if (event.shiftKey) {
                reset.resetMinorSettings();
                !function(audio) {
                  audio.playEarcon("quit-organ");
                }(audio_audio);
              }
            });
          }
        },
        speakHighlight: function() {
          var highlight = mh.getHighlight();
          if (highlight) {
            !function(audio) {
              audio.init();
              audio.speakContent(highlight.picked);
            }(audio_audio);
          }
        },
        stopAudio: function() {
          !function(audio) {
            audio.init();
            audio.stopAudio();
          }(audio_audio);
        },
        toggleSpeech: function() {
          !function(audio) {
            audio.init();
            audio.toggleSpeech();
          }(audio_audio);
        },
        notImplemented: function() {}
      };
    }(page_zoom_zoom, page_highlight_move_keys, page_highlight_highlight, page_reset_reset);
    page_keys_keys = function(elemClassifier, commands, metric, events, HIGHLIGHT_CONST, CORE_CONST, nativeGlobal) {
      var wasOnlyShiftKeyDown, isStopSpeechKey, isHighlightVisible, isLensVisible, // Init called when sitecues turned on for the first time
      isAudioPlaying, isInitialized, didFireLastKeyInfoMetric, fakeKeyRepeatTimer, // KEY_TESTS defines keys used to bind actions to hotkeys.
      // The key tests return true if the correct key was pressed, the current focus
      // is not on an element that needs the key, and the sitecues state is appropriate).
      // 'Correct key' includes all key possible codes including alternate keys on the numeric keypad for +/-
      // and additional codes resulting from browser differences.
      // See http://www.javascripter.net/faq/keycodes.htm
      //
      // ** A key test should return true if the key is considered fired and valid **
      //
      // Note: for movement keys we also support the numeric keypad:
      // [7 Home ]  [ 8 Up ]  [9 PgUp  ]
      // [4 Left ]  [ 5    ]  [6 Right ]
      // [1 End  ]  [ 2 Dn ]  [3 PgDn  ]
      keyCode = CORE_CONST.KEY_CODE, ZOOM_IN_CODES = CORE_CONST.ZOOM_IN_CODES, ZOOM_OUT_CODES = CORE_CONST.ZOOM_OUT_CODES, HIGHLIGHT_TOGGLE_EVENT = HIGHLIGHT_CONST.HIGHLIGHT_TOGGLE_EVENT, isSitecuesOn = true, lastKeyInfo = {}, KEY_TESTS = {
        space: function(event) {
          var isUnmodifiedSpace = event.keyCode === keyCode.SPACE && !hasCommandModifier(event), isNeededByPage = elemClassifier.isSpacebarConsumer(event.target);
          return isUnmodifiedSpace && isSitecuesOn && !isNeededByPage;
        },
        minus: function(event) {
          // Test all of the possible minus keycodes, including from the numeric keypad
          if (ZOOM_OUT_CODES.indexOf(event.keyCode) > -1) {
            return canUseZoomKey(event);
          }
        },
        plus: function(event) {
          // Test all of the possible plus keycodes, including from the numeric keypad.
          // Also tests for equals (=) key, which is effectively an unmodified + key press
          if (ZOOM_IN_CODES.indexOf(event.keyCode) > -1) {
            return canUseZoomKey(event);
          }
        },
        hlbMinus: function(event) {
          // Test all of the possible minus keycodes, including from the numeric keypad
          if (ZOOM_OUT_CODES.indexOf(event.keyCode) > -1) {
            return isLensVisible && hasCommandModifier(event);
          }
        },
        hlbPlus: function(event) {
          // Test all of the possible plus keycodes, including from the numeric keypad.
          // Also tests for equals (=) key, which is effectively an unmodified + key press
          if (ZOOM_IN_CODES.indexOf(event.keyCode) > -1) {
            return isLensVisible && hasCommandModifier(event);
          }
        },
        reset: function(event) {
          // Ctrl+0, Cmd+0 or just 0 to reset zoom only, Alt+0 to reset zoom & speech, Alt+Shift+0 to reset all
          return event.keyCode === keyCode.NUMPAD_0 && (!elemClassifier.isEditable(event.target) || hasCommandModifier(event));
        },
        speech: function(event) {
          return event.keyCode === keyCode.QUOTE && event.altKey && !elemClassifier.isEditable(event.target);
        },
        esc: function(event) {
          // Escape key is only valid if there is an lens to close
          return event.keyCode === keyCode.ESCAPE && (isHighlightVisible || isLensVisible);
        },
        // For arrow keys, allow number pad usage as well (2/4/6/8)
        up: function(event) {
          return (event.keyCode === keyCode.UP || event.keyCode === keyCode.NUMPAD_8) && canMoveHighlight(event);
        },
        down: function(event) {
          return (event.keyCode === keyCode.DOWN || event.keyCode === keyCode.NUMPAD_2) && canMoveHighlight(event);
        },
        left: function(event) {
          return (event.keyCode === keyCode.LEFT || event.keyCode === keyCode.NUMPAD_4) && canMoveHighlight(event);
        },
        right: function(event) {
          return (event.keyCode === keyCode.RIGHT || event.keyCode === keyCode.NUMPAD_6) && canMoveHighlight(event);
        },
        heading: function(event) {
          return event.keyCode === keyCode.LETTER_H && !elemClassifier.isEditable(event.target) && !event.altKey && !event.ctrlKey && !event.metaKey;
        },
        pageup: function(event) {
          return (event.keyCode === keyCode.PAGE_UP || event.keyCode === keyCode.NUMPAD_9) && canScrollLens(event);
        },
        pagedn: function(event) {
          return (event.keyCode === keyCode.PAGE_DN || event.keyCode === keyCode.NUMPAD_3) && canScrollLens(event);
        },
        home: function(event) {
          // Also support cmd+up on Mac
          if (!canScrollLens(event)) {
            return false;
          }
          return event.keyCode === keyCode.HOME && !hasAnyModifier(event) || event.keyCode === keyCode.NUMPAD_7 || event.keyCode === keyCode.UP && event.metaKey;
        },
        end: function(event) {
          // Also support cmd+down on Mac
          if (!canScrollLens(event)) {
            return false;
          }
          return event.keyCode === keyCode.END && !hasAnyModifier(event) || event.keyCode === keyCode.NUMPAD_1 || event.keyCode === keyCode.DOWN && event.metaKey;
        }
      }, // define keys map used to bind actions to hotkeys
      KEY_EVENT_MAP = {
        minus: "decreaseZoom",
        plus: "increaseZoom",
        hlbMinus: "notImplemented",
        hlbPlus: "notImplemented",
        reset: "resetSitecues",
        speech: "toggleSpeech"
      }, KEY_EVENT_DEFAULT = "queueKey";
      function canMoveHighlight(event) {
        // Visible highlight or HLB
        return !hasCommandModifier(event) && (isHighlightVisible || isLensVisible) && !elemClassifier.isEditable(event.target);
      }
      function canScrollLens(event) {
        return isLensVisible && !elemClassifier.isEditable(event.target);
      }
      function canUseZoomKey(event) {
        // Minus/plus cannot trigger if there is a lens
        if (isLensVisible) {
          return;
        }
        // If modified (ctrl/cmd/etc.), then the minus/plus command can be used no matter what is focused,
        // because it is not being used to type '-'
        if (hasCommandModifier(event)) {
          return true;
        }
        // Plain minus/plus was pressed without a modifier -- the command is only valid if we're not in an editable field
        // (which needs to allow the user to type the minus/plus key)
        return !elemClassifier.isEditable(event.target);
      }
      // Non-shift modifier keys (ctrl, cmd, alt)
      function hasCommandModifier(event) {
        return event.altKey || event.ctrlKey || event.metaKey;
      }
      // Any modifer key, including shift
      function hasAnyModifier(event) {
        return event.shiftKey || hasCommandModifier(event);
      }
      // Handle key
      function handle(commandName, event, keyName) {
        // Prevent default behavior of key. The browser listens to these events
        // and does not execute command based on the key pressed
        // (such as spacebar to page down, cmd+plus to zoom, arrow key to scroll, shift+arrow to select)
        event.preventDefault();
        // Keeps the rest of the handlers from being executed and prevents the event from bubbling up the DOM tree.
        // It's nother layer of protection. Here's why we need it even though web browsers respect the defaultPrevented flag.
        // Scripts generally do not look at that flag. If they get a key, they just consume it.
        // Therefore, if the user is focused on a JS widget, such as a
        // <div onkeydown="..."/>, there is the possibility that both sitecues and the widget would handle the key.
        // Examples:
        // - spacebar in a button
        // - plus or minus key in a tree view or map (for zoom)
        // Spacebar is probably the most likely, but as we start handling other keys such
        // as arrows, we need to be careful. We could either decide which keys that we consume
        // need stopImmediatePropagation, or just do it always to be safe.
        event.stopImmediatePropagation();
        executeCommand(event, commandName, keyName);
      }
      function executeCommand(event, commandName, keyName) {
        // Emit event defined for key
        commands[commandName](event, keyName);
        // Ready metric info to be fired during keyup
        var isDifferentKey = lastKeyInfo.keyName !== keyName;
        if (isDifferentKey) {
          // Different key from last time -- fire no matter what
          didFireLastKeyInfoMetric = false;
          lastKeyInfo = {
            keyName: keyName,
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            metaKey: event.metaKey,
            ctrlKey: event.ctrlKey,
            repeatCount: 0
          };
        } else {
          // Same key
          ++lastKeyInfo.repeatCount;
        }
      }
      // key event hook
      function onKeyDown(event) {
        // Shift key gets additional processing before other keys
        preProcessKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
        processKey(event);
      }
      function processKey(event) {
        // iterate over key map
        for (var key in KEY_TESTS) {
          if (KEY_TESTS.hasOwnProperty(key) && KEY_TESTS[key](event)) {
            handle(KEY_EVENT_MAP[key] || KEY_EVENT_DEFAULT, event, key);
            notifySitecuesKeyDown(true);
            return key;
          }
        }
        // All other keys will fall through to default processing
        // Don't allow panning via arrow or other scroll keys to accidentally activate highlighting.
        // This happens when the panning causes the mouse on the screen to go over new content, firing a mouseover event.
        notifySitecuesKeyDown(false);
      }
      function onKeyUp(event) {
        notifySitecuesKeyDown(true);
        if (event.keyCode === keyCode.SHIFT) {
          if (isBeginSpeechCommand()) {
            commands.speakHighlight();
          }
        }
        // Once the shift key is up, we clear the any key down flag.
        // This is a simple approach that handles all except very weird key behavior
        // such as shift up down up all while another key is pressed.
        isStopSpeechKey = false;
        wasOnlyShiftKeyDown = false;
        emitOnlyShiftStatus();
        fireLastCommandMetric();
      }
      function fireLastCommandMetric() {
        if (!didFireLastKeyInfoMetric && lastKeyInfo.keyName) {
          // Fire key metric, but only if it wasn't fired for this key yet (we don't fire multiple events for key repeats)
          new metric.KeyCommand(lastKeyInfo).send();
          didFireLastKeyInfoMetric = true;
        }
        clearTimeout(fakeKeyRepeatTimer);
        fakeKeyRepeatTimer = nativeGlobal.setTimeout(function() {
          // If the next key is the same and occurs quickly after the last keyup, it will be considered a key repeat,
          // because some configurations on Windows seem to fire multiple keyups and keydowns for key repeats
          // Once this timer fires, we clear a flag that allows even the same key to be fired as a new metric
          didFireLastKeyInfoMetric = false;
          lastKeyInfo = {};
        }, CORE_CONST.MIN_TIME_BETWEEN_KEYS);
      }
      // Track to find out whether the shift key is pressed by itself
      function emitOnlyShiftStatus() {
        events.emit("key/only-shift", wasOnlyShiftKeyDown);
      }
      function isBeginSpeechCommand() {
        return wasOnlyShiftKeyDown && !isStopSpeechKey;
      }
      // If shift key down, process it
      function preProcessKeyDown(event) {
        var isShift = event.keyCode === keyCode.SHIFT;
        if (!isShift || isAudioPlaying) {
          // Key down stops speech/audio
          // Exception is repeated shift key, which also starts speech when shift is held down
          commands.stopAudio();
          isStopSpeechKey = true;
        }
        wasOnlyShiftKeyDown = isShift;
        emitOnlyShiftStatus();
      }
      function notifySitecuesKeyDown(isFollowMouseEnabled) {
        events.emit("keys/sitecues-key-down", isFollowMouseEnabled);
      }
      function init(keyEvent, isKeyAlreadyReleased) {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        // bind key hook to window
        // 3rd param changes event order: false == bubbling; true = capturing.
        // We use capturing because we want to get the key before anything else does --
        // this allows us to have the first choice, and we can preventDefault on it so that
        // nothing else uses it after us.
        addEventListener("keydown", onKeyDown, true);
        // Will reenable highlight on mouse follow
        addEventListener("keyup", onKeyUp, true);
        events.on(HIGHLIGHT_TOGGLE_EVENT, function(isVisible) {
          isHighlightVisible = isVisible;
        });
        events.on("hlb/did-create", function() {
          isLensVisible = true;
        });
        events.on("hlb/closed", function() {
          isLensVisible = false;
        });
        events.on("sitecues/did-toggle", function(isOn) {
          isSitecuesOn = isOn;
        });
        events.on("audio/did-toggle", function(isOn) {
          isAudioPlaying = isOn;
        });
        if (keyEvent) {
          var executedKey = processKey(keyEvent);
          if (isKeyAlreadyReleased && ("minus" === executedKey || "plus" === executedKey)) {
            // If zoom key was released before zoom module was listening for keyup, make sure we stop zoom
            // This can happen when the key was captured before the keys/zoom module were requested,
            // and released before they finished loading/initializing.
            commands.stopZoom();
          }
        }
        events.emit("keys/did-init");
      }
      return {
        init: init
      };
    }(page_util_element_classifier, page_keys_commands, run_metric_metric, run_events, page_highlight_constants, run_constants, mini_core_native_global);
    page_hpan_hpan = function(bodyGeo, events, viewport, domEvents, zoomMod) {
      var isListeningToResize, xLastPos, isOn = false, isHlbOn = false, isSitecuesUIOpen = false, isZooming = false, MIN_EDGE_PORTION = .1, MAX_EDGE_PORTION = .25, SPEED_FACTOR = 4, MAX_SPEED = 100;
      // get dependencies
      function mousemove(evt) {
        var // Get direction to pan, or return if mouse too near center of screen to cause panning
        direction, // Amount of horizontal mouse movement
        movementX = getBackfillMovementX(evt), // Right side of body in absolute coordinates
        bodyRight = bodyGeo.getBodyRight(), pageXOffset = viewport.getPageXOffset(), // Width of window
        winWidth = viewport.getInnerWidth(), // Amount of content that didn't fit in the window
        ratioContentToWindowWidth = bodyRight / winWidth, // Amount of edge to use for panning
        edgePortion = Math.max(Math.min(ratioContentToWindowWidth / 2 - .55, MAX_EDGE_PORTION), MIN_EDGE_PORTION), edgeSize = winWidth * edgePortion;
        if (evt.clientX < edgeSize && movementX < 0) {
          direction = -1;
        } else {
          if (evt.clientX > winWidth - edgeSize && movementX > 0) {
            direction = 1;
          } else {
            return;
          }
        }
        var // How far into the panning zone are we?
        pixelsUntilMouseAtWindowEdge = 1 === direction ? winWidth - evt.clientX : evt.clientX, pixelsIntoPanningZone = edgeSize - pixelsUntilMouseAtWindowEdge, percentageIntoPanningZone = pixelsIntoPanningZone / edgeSize, // .5 = 50%, 1 = 100%, etc.
        // How much to boost mouse movement?
        // Factor in how much more content there is than can fit in the window
        // Factor in how far into the panning zone we are, so it accelerates as we get toward edge
        // (sort of a magic formula developed through tinkering, which seems to work nicely)
        extraMovement = Math.max(.5, (ratioContentToWindowWidth - .3) * SPEED_FACTOR * (percentageIntoPanningZone + .5)), // How far can we move until we reach the right edge of the visible content
        maxMovementUntilRightEdge = bodyRight - winWidth - pageXOffset, // Calculate movement size: amount of mouse movement + extraMovement
        movementSize = Math.min(Math.round(Math.abs(movementX) * extraMovement), MAX_SPEED), // Finally, calculate the total movement -- do not allow move past right or left edge
        movement = Math.min(direction * movementSize, maxMovementUntilRightEdge);
        movement = Math.max(movement, -pageXOffset);
        // Scroll it
        if (movement >= 1 || movement <= -1) {
          window.scrollBy(movement, 0);
        }
      }
      function getBackfillMovementX(evt) {
        var movementX = evt.movementX;
        if ("undefined" !== typeof movementX) {
          return movementX;
        }
        movementX = evt.mozMovementX;
        if ("undefined" !== typeof movementX) {
          return movementX;
        }
        movementX = evt.webkitMovementX;
        if ("undefined" !== typeof movementX) {
          return movementX;
        }
        // Does not require new browser capabilities, but not quite as smooth
        movementX = "undefined" === typeof xLastPos ? 0 : evt.clientX - xLastPos;
        xLastPos = evt.clientX;
        return movementX;
      }
      function onZoomBegin() {
        isZooming = true;
      }
      function onZoomChange(zoomLevel) {
        if (zoomLevel > 1 && !isListeningToResize) {
          isListeningToResize = true;
          events.on("resize", refresh);
        }
        isZooming = false;
        refresh();
      }
      function getZoom() {
        return zoomMod.getCompletedZoom() || 1;
      }
      function refresh() {
        // Turn on if zoom is > 1 and content overflows window more than a tiny amount
        var zoom = getZoom(), doTurnOn = zoom > 1 && bodyGeo.getBodyRight() / viewport.getInnerWidth() > 1.02 && !isHlbOn && !isSitecuesUIOpen && !isZooming;
        if (doTurnOn !== isOn) {
          if (doTurnOn) {
            domEvents.on(document, "mousemove", mousemove);
          } else {
            domEvents.off(document, "mousemove", mousemove);
            xLastPos = void 0;
          }
        }
        isOn = doTurnOn;
      }
      function init() {
        events.on("hlb/ready", function() {
          isHlbOn = true;
          refresh();
        });
        events.on("hlb/closed", function() {
          isHlbOn = false;
          refresh();
        });
        // Dont pan while the bp is expanded.
        events.on("bp/will-expand", function() {
          isSitecuesUIOpen = true;
          refresh();
        });
        // Allow panning while the bp is shrunk.
        events.on("bp/did-shrink", function() {
          isSitecuesUIOpen = false;
          refresh();
        });
        events.on("bp/did-toggle-menu", function(isOpen) {
          isSitecuesUIOpen = isOpen;
          refresh();
        });
        events.on("zoom/begin", onZoomBegin);
        // react on any zoom change
        events.on("zoom", onZoomChange);
        onZoomChange(getZoom());
      }
      return {
        init: init
      };
    }(page_zoom_util_body_geometry, run_events, page_viewport_viewport, run_dom_events, page_zoom_zoom);
    page_positioner_transplant_clone = function($, elementMap, elementInfo, styleLock, constants, viewport, inlineStyle) {
      var docElem, originalBody, auxiliaryBody;
      function clone(target, opts) {
        opts = opts || {};
        var resultWrapper = {}, // Aliases for the shorter options names at the call site
        wordyOpts = {};
        // Is @target a transplant root
        // We cache this information in the element map for each element in its subtree
        wordyOpts.isRoot = opts.isRoot;
        // Defined if @target is nested in the subtree of an ancestor transplant root
        wordyOpts.superRoot = opts.superRoot;
        // Do not clone @target
        wordyOpts.doExcludeTargetElement = opts.excludeTarget;
        // An element's heredity structure is:
        // 1. The sibling elements of @target
        // 2. Each of @target's ancestor elements until the body, and all of their siblings
        wordyOpts.doCloneHeredityStructure = opts.heredityStructure;
        // Insert @target into its clone's position in the heredity structure
        wordyOpts.doInsertTargetIntoCloneTree = opts.insertTargetIntoCloneTree;
        // Return a reference to the nearest ancestor clone of the target
        // That's probably where we want to insert the heredity tree
        // We save a little work with this option, because we already need to find it when cloning heredityStructure from the body
        wordyOpts.doGetNearestAncestorClone = opts.getNearestAncestorClone;
        if (!wordyOpts.doExcludeTargetElement) {
          resultWrapper.clone = cloneElement(target, wordyOpts);
        }
        if (wordyOpts.doCloneHeredityStructure) {
          var results = cloneHeredityStructure(target, wordyOpts);
          resultWrapper.heredityStructure = results.heredityStructure;
          // This could conceivably be undefined, but there aren't any code paths currently where that is true
          resultWrapper.nearestAncestorClone = results.nearestAncestorClone;
          return resultWrapper;
        }
        return resultWrapper.clone;
      }
      // Clone all the children of each of the element's ancestors until the body, or until a generation that has already been cloned
      function cloneHeredityStructure(target, opts) {
        // Returns an array of all the clean ancestors until and including the first cloned ancestor or the original body
        function getAncestorsToWalk(element) {
          var isCloned, ancestor = element, ancestors = [];
          do {
            ancestor = ancestor.parentElement;
            isCloned = Boolean(getComplement(ancestor));
            ancestors.push(ancestor);
          } while (!isCloned && ancestor !== originalBody);
          return ancestors;
        }
        var container, nearestAncestorClone, ancestorsToWalk = getAncestorsToWalk(target), nearestClonedAncestor = ancestorsToWalk[ancestorsToWalk.length - 1], ancestorCount = ancestorsToWalk.length, originalInChain = target, // As an optimization we can insert the target into the clone heredityStructure, typically because we are trying to insert a fixed element
        // into the auxiliary body with the clone heredityStructure in place to catch inherited styles
        cloneInChain = opts.doInsertTargetIntoCloneTree ? target : cloneElement(target);
        for (var i = 0; i < ancestorCount; i++) {
          var ancestorClone, ancestor = ancestorsToWalk[i], children = Array.prototype.slice.call(ancestor.children, 0), generationFragment = document.createDocumentFragment(), isAncestorCloned = ancestor === nearestClonedAncestor, childrenCount = children.length;
          if (isAncestorCloned) {
            ancestorClone = ancestor === originalBody ? getAuxiliaryBody() : getComplement(ancestor);
            nearestAncestorClone = ancestorClone;
          } else {
            ancestorClone = cloneElement(ancestor);
          }
          for (var j = 0; j < childrenCount; j++) {
            var originalChild = children[j];
            // We've already cloned this child, because in the previous iteration we cloned
            // and appended its children to it, so now we just need to append the existing clone
            if (originalChild === originalInChain) {
              generationFragment.appendChild(cloneInChain);
            } else {
              generationFragment.appendChild(cloneElement(originalChild));
            }
          }
          if (isAncestorCloned) {
            container = generationFragment;
          } else {
            // If the ancestor is newly cloned, we know that the clone isn't inserted into the document
            ancestorClone.appendChild(generationFragment);
          }
          originalInChain = ancestor;
          cloneInChain = ancestorClone;
        }
        var results = {
          heredityStructure: container
        };
        if (opts.doGetNearestAncestorClone) {
          results.nearestAncestorClone = nearestAncestorClone;
        }
        return results;
      }
      function cloneElement(element, opts) {
        opts = opts || {};
        var len, i, // If @element should be considered the root element for its subtree
        isRoot = opts.isRoot, // The closest ancestor root of @element
        superRoot = opts.superRoot, clone = element.cloneNode(), $element = $(element), $clone = $(clone), traitFields = [ "complement", "isRoot" ], traitValues = [ clone, isRoot ], tagName = element.localName;
        switch (tagName) {
         case "script":
          // This prevents clone script tags from running when we insert them into the DOM
          clone.type = "application/json";
          break;

         case "video":
          // This prevents clone video elements from playing
          clone.pause();
          clone.src = "";
          clone.load();
          break;

         case "link":
          // Don't reload link tags
          clone.href = "";
        }
        if (superRoot) {
          elementInfo.isTransplantRoot(superRoot, true);
          if (isRoot) {
            elementInfo.addToSubroots(superRoot, element);
          }
        }
        //Currently this doesn't allow for the sitecues badge to be cloned, that creates some bad behavior
        //This maintains the structure / order of the cloned subtree, but it won't interfere with selectors
        //TODO: Figure out how to remove these elements completely from the clone set, and still retain 1 to 1 mapping to the original set
        var $badgeClone = $clone.find("#sitecues-badge");
        if ($badgeClone.get().length) {
          var $sitecuesCloneSet = $badgeClone.find("*").addBack(), sitecuesSet = $sitecuesCloneSet.add($element.find("#sitecues-badge").find("*").addBack()).get();
          len = sitecuesSet.length;
          for (i = 0; i < len; i++) {
            elementMap.setField(sitecuesSet[i], [ "complement", "isClone" ], [ null, null ]);
          }
          $sitecuesCloneSet.attr("id", "").attr("class", "");
        }
        // Remove attributes tied to styles we're applying to anchor elements
        clone.removeAttribute(constants.ROOT_ATTR);
        clone.removeAttribute(constants.ANCHOR_ATTR);
        // Remove all the style-locks from the clone element
        styleLock.unlockStyle(clone);
        elementMap.setField(element, traitFields, traitValues);
        elementMap.setField(clone, [ "isClone", "complement" ], [ true, element ]);
        return clone;
      }
      // Returns the clone of an original element, or the original element of a clone
      function getComplement(element) {
        return elementMap.getField(element, "complement");
      }
      function getAuxiliaryBody() {
        if (!auxiliaryBody) {
          auxiliaryBody = cloneElement(originalBody);
          // Removes position lock from clone
          styleLock.unlockStyle(auxiliaryBody);
          var bodyStyle = inlineStyle(auxiliaryBody);
          // Strange bug, don't really understand it, but visible elements nested in hidden elements don't show up as
          // expected when the original body has overflowY set to scroll (reproduces on Desire To Learn)
          bodyStyle.visibility = "scroll" === getComputedStyle(originalBody).overflowY ? "" : "hidden";
          bodyStyle.transform = "none";
          bodyStyle.pointerEvents = "";
          bodyStyle.position = "absolute";
          bodyStyle.top = 0;
          bodyStyle.height = viewport.getInnerHeight();
          bodyStyle.width = viewport.getInnerWidth();
          docElem.appendChild(auxiliaryBody);
        }
        return auxiliaryBody;
      }
      function init() {
        docElem = document.documentElement;
        originalBody = document.body;
      }
      clone.init = init;
      clone.get = getComplement;
      clone.getAuxiliaryBody = getAuxiliaryBody;
      return clone;
    }($, page_positioner_util_element_map, page_positioner_util_element_info, page_positioner_style_lock_style_lock, page_positioner_constants, page_viewport_viewport, run_inline_style_inline_style);
    page_positioner_transplant_graft = function(elementMap, elementInfo, clone) {
      var originalBody, rejectionListenerMap;
      function implantNodeStructure(element, parent, sibling) {
        if (sibling) {
          parent.insertBefore(element, sibling);
        } else {
          parent.appendChild(element);
        }
      }
      // This function listens for removed roots, if we haven't set a flag indicating we're replanting the root somewhere else in the DOM
      // it will return the root to the auxiliary body. If the root has been replanted to a new location in the original body
      // from where it was transplanted from, transplant it into the auxiliary body at the complementary position
      function onTransplantRejection(mutations) {
        function replantNode(node) {
          /* jshint validthis: true */
          var isRoot = elementInfo.isTransplantRoot(node), wasReplanted = elementMap.flushField(node, "wasReplanted");
          // If we didn't remove this root intentionally, it's been removed by another script and we need to re-implant it
          if (!wasReplanted && isRoot) {
            var newParent = node.parentElement, inAuxBody = newParent && !elementInfo.isInOriginalBody(newParent), cloneParent = newParent && clone.get(newParent), newSibling = node.nextSibling, cloneSibling = newSibling && clone.get(newSibling);
            if (!inAuxBody && newParent && !cloneParent) {
              var insertionGroup = clone(node, {
                heredityStructure: true,
                excludeTarget: true,
                getNearestAncestorClone: true,
                insertTargetIntoCloneTree: true
              });
              graftToAuxiliaryBody({
                root: node,
                insertionTarget: insertionGroup.heredityStructure,
                parent: insertionGroup.getNearestAncestorClone,
                handleTransplantRejection: true
              });
            } else {
              if (!inAuxBody && cloneParent) {
                graftToAuxiliaryBody({
                  root: node,
                  parent: cloneParent,
                  sibling: cloneSibling,
                  handleTransplantRejection: true
                });
              } else {
                if (inAuxBody) {
                  graftToAuxiliaryBody({
                    root: node,
                    parent: newParent,
                    sibling: newSibling,
                    handleTransplantRejection: true
                  });
                }
              }
            }
          }
        }
        for (var i = 0, mutationCount = mutations.length; i < mutationCount; i++) {
          var mutation = mutations[i], removedNodes = Array.prototype.slice.call(mutation.removedNodes, 0);
          removedNodes.forEach(replantNode, mutation);
        }
      }
      function disconnectRejectionListener(target) {
        rejectionListenerMap.get(target).disconnect();
      }
      function listenForTransplantRejection(target) {
        var observer = rejectionListenerMap.get(target);
        if (!observer) {
          observer = new MutationObserver(onTransplantRejection);
          rejectionListenerMap.set(target, observer);
        } else {
          observer.disconnect();
        }
        observer.observe(target.parentElement, {
          childList: true
        });
      }
      function graftToBody(opts) {
        var // The insertion target is either the root itself, or the top of its node structure
        insertionTarget = opts.insertionTarget || opts.root, root = opts.root, sibling = opts.sibling, parent = opts.parent, hostBody = opts.hostBody;
        elementInfo.setHostBody(root, hostBody);
        elementMap.setField(root, "transplantParent", parent);
        elementMap.setField(root, "transplantSibling", sibling);
        implantNodeStructure(insertionTarget, parent, sibling);
      }
      function graftToOriginalBody(opts) {
        opts.hostBody = originalBody;
        graftToBody(opts);
      }
      function graftToAuxiliaryBody(opts) {
        opts.hostBody = clone.getAuxiliaryBody();
        graftToBody(opts);
      }
      function init() {
        originalBody = document.body;
        rejectionListenerMap = new WeakMap();
      }
      return {
        listenForTransplantRejection: listenForTransplantRejection,
        disconnectRejectionListener: disconnectRejectionListener,
        implantNodeStructure: implantNodeStructure,
        toAuxiliaryBody: graftToAuxiliaryBody,
        toOriginalBody: graftToOriginalBody,
        init: init
      };
    }(page_positioner_util_element_map, page_positioner_util_element_info, page_positioner_transplant_clone);
    page_positioner_transplant_mutation_relay = function(elementInfo, clone) {
      var domObserver, originalBody;
      function copyClassToComplement(mutation) {
        var target = mutation.target, complement = clone.get(target);
        if (complement) {
          complement.className = target.className;
        }
      }
      function init() {
        originalBody = document.body;
        domObserver = new MutationObserver(function(mutations) {
          var len = mutations.length;
          for (var i = 0; i < len; i++) {
            var mutation = mutations[i], target = mutation.target;
            // Don't bother looking for a complement to Sitecues elements, they have been removed
            if (elementInfo.isSitecuesElement(target)) {
              continue;
            }
            copyClassToComplement(mutation);
          }
        });
        domObserver.observe(originalBody, {
          attributes: true,
          attributeOldValue: true,
          subtree: true,
          // For now we only need to copy classes over, it's the simplest case. Copying inline styles over is more complicated
          // and will need to be more thoroughly thought through
          attributeFilter: [ "class" ]
        });
      }
      return {
        init: init
      };
    }(page_positioner_util_element_info, page_positioner_transplant_clone);
    page_positioner_transplant_transplant = function(elementMap, clone, constants, arrayUtil, elementInfo, graft, anchors, mutationRelay) {
      var originalBody, elementQuerySelectorAll, documentQuerySelectorAll, getElementsByClassName, TRANSPLANT_STATE = constants.TRANSPLANT_STATE, ROOT_ATTR = constants.ROOT_ATTR, ROOT_SELECTOR = constants.ROOT_SELECTOR;
      // When we transplant elements into the auxiliary body, we need to re-direct queries in the original body to include
      // the original element's new position in the DOM tree, and to exclude clone elements in the heredity tree
      // TODO: If we ever drop IE11, use a Proxy intercept to accomplish this
      function rerouteDOMQueries() {
        getElementsByClassName = Document.prototype.getElementsByClassName;
        elementQuerySelectorAll = Element.prototype.querySelectorAll;
        documentQuerySelectorAll = Document.prototype.querySelectorAll;
        function scElementQuerySelectorAll(selector) {
          /*jshint validthis: true */
          var complement = clone.get(this);
          if (complement) {
            var auxResults = elementQuerySelectorAll.call(complement, selector), originalResults = elementQuerySelectorAll.call(this, selector), results = arrayUtil.union(auxResults, originalResults);
            return results.filter(elementInfo.isOriginal);
          }
          return elementQuerySelectorAll.call(this, selector);
        }
        function scDocumentQuerySelectorAll(selector) {
          var elements = Array.prototype.slice.call(documentQuerySelectorAll.call(document, selector), 0);
          return elements.filter(elementInfo.isOriginal);
        }
        // NOTE: this will break scripts that rely on getElementsByClassName to be a live list!
        function scGetElementsByClassName(selector) {
          var elements = Array.prototype.slice.call(getElementsByClassName.call(document, selector), 0);
          return elements.filter(elementInfo.isOriginal);
        }
        Document.prototype.querySelectorAll = scDocumentQuerySelectorAll;
        Element.prototype.querySelectorAll = scElementQuerySelectorAll;
        Document.prototype.getElementsByClassName = scGetElementsByClassName;
      }
      // Returns falsey if there isn't a root in the element's ancestor chain
      function getClosestRoot(element) {
        var ancestor = element.parentElement, cloneBody = clone.get(originalBody), doesCloneBodyExist = Boolean(cloneBody);
        function elementIsBody(element) {
          var isOriginalBody = element === originalBody;
          if (doesCloneBodyExist) {
            return isOriginalBody || element === cloneBody;
          }
          return isOriginalBody;
        }
        while (ancestor && !elementIsBody(ancestor)) {
          if (elementInfo.isTransplantRoot(ancestor)) {
            return ancestor;
          }
          ancestor = ancestor.parentElement;
        }
      }
      function insertPlaceholder(element, parent, sibling) {
        function createPlaceholder(element) {
          var placeholder = document.createElement("div");
          placeholder.className = "placeholder";
          elementMap.setField(element, "placeholder", placeholder);
          elementMap.setField(placeholder, "placeholderFor", element);
          return placeholder;
        }
        var placeholder = elementInfo.getPlaceholder(element) || createPlaceholder(element);
        graft.implantNodeStructure(placeholder, parent, sibling);
      }
      function evaluateTransplantState(element) {
        var hasDescendantPlaceholders = element.querySelectorAll(".placeholder").length > 0, isCloned = Boolean(clone.get(element)), isTransplantRoot = elementInfo.isTransplantRoot(element), isNested = Boolean(getClosestRoot(element));
        if (isNested) {
          return isTransplantRoot ? TRANSPLANT_STATE.NESTED_ROOT : TRANSPLANT_STATE.NESTED;
        }
        if (hasDescendantPlaceholders) {
          return TRANSPLANT_STATE.MIXED;
        }
        if (isTransplantRoot) {
          return TRANSPLANT_STATE.ROOT;
        }
        return isCloned ? TRANSPLANT_STATE.CLONED : TRANSPLANT_STATE.UNCLONED;
      }
      function doRunTransplantOperation(element, flags) {
        // We never want Sitecues elements to be transplant roots
        if (elementInfo.isSitecuesElement(element)) {
          return false;
        }
        // Transplant iframes causes the content to reload, which is problematic for nested scripts
        if ("iframe" === element.localName) {
          return false;
        }
        var isFixed = flags.isFixed, isInOriginalBody = flags.isInOriginalBody, isInAuxBody = !isInOriginalBody, isTransplantRoot = flags.isTransplantRoot, isNestedElement = !isTransplantRoot && isInAuxBody;
        // Basic transplant case, if an element is fixed then transplant the element
        if (isInOriginalBody && isFixed) {
          return true;
        }
        // Anchor roots need to be positioned, otherwise they should be replanted into the original body
        // Nested roots that no longer need to be transplanted if their anchor root is re-planted should have their
        // cached transplant information (subroots, etc.) updated
        if (isTransplantRoot && !isFixed) {
          return true;
        }
        // Nested elements that need to be transplanted if their anchor root is re-planted should have their
        // cached transplant information updated
        if (isNestedElement && isFixed) {
          return true;
        }
      }
      function evaluateCandidate(element, flags) {
        var results = {
          flags: flags
        };
        if (doRunTransplantOperation(element, flags)) {
          results.transplantState = evaluateTransplantState(element);
          return results;
        }
      }
      // If an element hasn't been cloned, we need to clone the rest of its heredity structure (which at a minimum is its own generation), insert the
      // root element into the node structure, and graft the structure to the element's closest clone ancestor
      function transplantUnclonedRoot(element) {
        var parent = element.parentElement, sibling = element.nextSibling, insertionGroup = clone(element, {
          // The inheritance tree for an element is all of the children of each of its ancestors up to and including the body's children.
          // Each child's subtree is not cloned. Its likely that part of this element's inheritance tree has already been cloned and
          // inserted into the auxiliary body, in which case we clone the remainder of the tree and insert it in the appropriate place
          heredityStructure: true,
          excludeTarget: true,
          getNearestAncestorClone: true,
          insertTargetIntoCloneTree: true
        });
        graft.toAuxiliaryBody({
          root: element,
          // Accepts either an element or a document fragment
          insertionTarget: insertionGroup.heredityStructure,
          parent: insertionGroup.nearestAncestorClone,
          handleTransplantRejection: true
        });
        insertPlaceholder(element, parent, sibling);
      }
      function transplantClonedRoot(element) {
        var parent = element.parentElement, sibling = element.nextSibling, cloneEl = clone.get(element), cloneParent = cloneEl.parentElement, cloneSibling = cloneEl.nextSibling;
        cloneEl.remove();
        graft.toAuxiliaryBody({
          root: element,
          parent: cloneParent,
          sibling: cloneSibling,
          handleTransplantRejection: true
        });
        insertPlaceholder(element, parent, sibling);
      }
      // A transplant root is 'anchoring' if it is not nested in the subtree of an ancestor transplant root. It 'anchors' all of the elements
      // in its subtree to remain implanted in the auxiliary body. If, for example, a nested transplant root became unpositioned, it would not
      // be replanted into the original body because of the anchoring root above it. 
      // When we replant an anchoring transplant root, we have to implant each of its subroots into the auxiliary body as new anchor roots.
      function replantAnchorRoot(root, opts) {
        var cloneParent, cloneSibling, placeholder = opts.placeholder || elementInfo.getPlaceholder(root), originalParent = placeholder.parentElement, originalSibling = placeholder.nextSibling, subroots = elementInfo.getSubroots(), // It's important that we clone the root if it hasn't already been cloned, otherwise nested roots might not find a cloned original ancestor
        // in the auxiliary body. We can then insert the heredity trees of each of the nested roots into this clone, and then finally insert this clone
        // into its complement's position in the auxiliary body.
        rootClone = clone.get(root) || clone(root);
        for (var i = 0, subrootCount = subroots.length; i < subrootCount; i++) {
          var subroot = subroots[i], subrootParent = subroot.parentElement, subrootSibling = subroot.nextSibling, subrootClone = clone.get(subroot);
          // If the subroot is already cloned, we know that its complete heredity tree is already built
          if (subrootClone) {
            cloneParent = subrootClone.parentElement;
            cloneSibling = subrootClone.nextSibling;
            graft.toAuxiliaryBody({
              root: subroot,
              parent: cloneParent,
              sibling: cloneSibling
            });
          } else {
            var insertionGroup = clone(subroot, {
              heredityStructure: true,
              excludeTarget: true,
              getNearestAncestorClone: true,
              insertTargetIntoCloneTree: true
            });
            graft.toAuxiliaryBody({
              root: subroot,
              // Accepts either an element or a document fragment
              insertionTarget: insertionGroup.heredityStructure,
              parent: insertionGroup.nearestAncestorClone
            });
          }
          anchors.add(subroot);
          elementMap.setField(subroot, "wasReplanted", true);
          elementInfo.setRoot(subroot, null);
          insertPlaceholder(subroot, subrootParent, subrootSibling);
        }
        elementInfo.clearSubroots(root);
        graft.implantNodeStructure(rootClone, root.parentElement, root.nextSibling);
        placeholder.remove();
        graft.toOriginalBody({
          root: root,
          parent: originalParent,
          sibling: originalSibling
        });
      }
      // Transplant roots that are nested in the subtree of an anchor root do not need to be replanted when they no longer qualify as roots.
      // We just need to re-direct its subroot's root reference to its super root, and add its subroot references to the super root's subroots
      function removeNestedRoot(root) {
        var subroots = elementInfo.getSubroots(root), superRoot = elementInfo.getRoot(root);
        subroots.forEach(function(subroot) {
          elementInfo.setRoot(subroot, superRoot);
        });
        graft.disconnectRejectionListener(root);
        elementInfo.removeSubroots(superRoot, root);
        elementInfo.clearSubroots(root);
        elementInfo.addSubroots(superRoot, subroots);
      }
      // Identifying a nested element as a transplant root doesn't require us to move the element's position in the DOM, we just need to update the
      // cached transplant information
      function addNestedRoot(element) {
        var superRoot = getClosestRoot(element), siblingSubroots = elementInfo.getSubroots(superRoot), deepSubroots = Array.prototype.slice.call(element.querySelectorAll(ROOT_SELECTOR), 0), directSubroots = arrayUtil.intersection(deepSubroots, siblingSubroots);
        directSubroots.forEach(function(subroot) {
          elementInfo.setRoot(subroot, element);
        });
        graft.listenForTransplantRejection(element);
        elementInfo.setRoot(element, superRoot);
        elementInfo.setSubroots(element, directSubroots);
        elementInfo.removeSubroots(superRoot, directSubroots);
        elementInfo.addSubroots(superRoot, element);
      }
      // Elements in the original body may have placeholder elements in their subtree
      // Before we transplant @element, we need to return the transplanted subroots to @element's subtree
      function unifyMixedSubtree(element) {
        var nestedPlaceholders = element.querySelectorAll(".placeholder");
        for (var i = 0, placeholderCount = nestedPlaceholders.length; i < placeholderCount; i++) {
          var placeholder = nestedPlaceholders[i], transplantedRoot = elementInfo.getPlaceholderOwner(placeholder), cloneParent = transplantedRoot.parentElement, cloneSibling = transplantedRoot.nextSibling, originalParent = placeholder.parentElement, originalSibling = placeholder.nextSibling, cloneRoot = clone.get(transplantedRoot) || clone(transplantedRoot);
          transplantedRoot.remove();
          placeholder.remove();
          // Technically we're replanting this into the original body right now, but its anchoring root will be transplanted
          // to the auxiliary body after this operation so the cached information should describe this element has being implanted in
          // the auxiliary body
          graft.toAuxiliaryBody({
            root: transplantedRoot,
            parent: originalParent,
            sibling: originalSibling
          });
          // This portion of the heredity tree will be removed from the DOM when we transplant the anchor root, but it's important that we keep the
          // heredity body intact so that we can rely on its structure if we have to replant the anchor root
          graft.implantNodeStructure(cloneRoot, cloneParent, cloneSibling);
          anchors.remove(element);
          elementInfo.addSubroots(element, transplantedRoot);
          elementInfo.setRoot(transplantedRoot, element);
          elementMap.setField(transplantedRoot, "wasReplanted", true);
        }
      }
      function performOperation(element, opts) {
        var status = TRANSPLANT_STATE, flags = opts.flags, transplantState = opts.transplantState;
        flags.wasTransplantRoot = flags.isTransplantRoot;
        flags.wasTransplantAnchor = flags.isTransplantAnchor;
        switch (transplantState) {
         case status.UNCLONED:
          transplantUnclonedRoot(element, opts);
          flags.isTransplantAnchor = true;
          flags.isTransplantRoot = true;
          flags.isInOriginalBody = false;
          break;

         case status.MIXED:
          unifyMixedSubtree(element);
          transplantClonedRoot(element, opts);
          flags.isTransplantAnchor = true;
          flags.isTransplantRoot = true;
          flags.isInOriginalBody = false;
          break;

         case status.CLONED:
          transplantClonedRoot(element, opts);
          flags.isTransplantAnchor = true;
          flags.isTransplantRoot = true;
          flags.isInOriginalBody = false;
          break;

         case status.ROOT:
          replantAnchorRoot(element, opts);
          flags.isTransplantRoot = false;
          flags.isTransplantAnchor = false;
          flags.isInOriginalBody = true;
          break;

         case status.NESTED_ROOT:
          removeNestedRoot(element);
          flags.isTransplantRoot = false;
          break;

         case status.NESTED:
          addNestedRoot(element);
          flags.isTransplantRoot = true;
        }
      }
      function postOperation(element, args) {
        var flags = args.flags;
        if (flags.isTransplantAnchor) {
          if (!elementQuerySelectorAll) {
            rerouteDOMQueries();
          }
          anchors.add(element);
        } else {
          if (flags.wasTransplantAnchor) {
            anchors.remove(element);
          }
        }
        if (flags.isTransplantRoot) {
          element.setAttribute(ROOT_ATTR, true);
          elementInfo.isTransplantRoot(element, true);
        } else {
          if (flags.wasTransplantRoot) {
            element.removeAttribute(ROOT_ATTR);
            elementInfo.isTransplantRoot(element, false);
          }
        }
      }
      function init() {
        originalBody = document.body;
        anchors.init();
        clone.init();
        mutationRelay.init();
        graft.init();
      }
      return {
        evaluateCandidate: evaluateCandidate,
        performOperation: performOperation,
        postOperation: postOperation,
        init: init
      };
    }(page_positioner_util_element_map, page_positioner_transplant_clone, page_positioner_constants, run_util_array_utility, page_positioner_util_element_info, page_positioner_transplant_graft, page_positioner_transplant_anchors, page_positioner_transplant_mutation_relay);
    page_positioner_transform_targets = function(arrayUtil) {
      var addHandler, removeHandler, fixedTargets;
      function removeTarget(element) {
        if (hasElement(element)) {
          fixedTargets.delete(element);
          removeHandler(element);
        }
      }
      function addTarget(element) {
        if (!hasElement(element)) {
          fixedTargets.add(element);
          addHandler(element);
        }
      }
      function hasElement(element) {
        return fixedTargets.has(element);
      }
      function getTargets() {
        return arrayUtil.fromSet(fixedTargets);
      }
      function getCount() {
        return fixedTargets.size;
      }
      function registerAddHandler(fn) {
        addHandler = fn;
      }
      function forEach(fn) {
        fixedTargets.forEach(fn);
      }
      function registerRemoveHandler(fn) {
        removeHandler = fn;
      }
      function init() {
        var noop = function() {};
        addHandler = noop;
        removeHandler = noop;
        fixedTargets = new Set();
      }
      return {
        init: init,
        add: addTarget,
        get: getTargets,
        has: hasElement,
        forEach: forEach,
        remove: removeTarget,
        registerAddHandler: registerAddHandler,
        registerRemoveHandler: registerRemoveHandler,
        getCount: getCount
      };
    }(run_util_array_utility);
    page_positioner_transform_rect_cache = function($, helper, styleLock, styleListener, events, domEvents, viewport) {
      var isTransformXOriginCentered, noop = function() {}, // For convenience this map keeps track of which elements we're currently observing
      observedElementMap = new WeakMap(), // This map caches the bounding rectangle for observed elements
      elementToRectDataMap = new WeakMap();
      function clearCache() {
        /*jshint validthis: true */
        if (this && this.nodeType === Node.ELEMENT_NODE) {
          elementToRectDataMap.set(this, null);
        } else {
          elementToRectDataMap = new WeakMap();
        }
      }
      function getUnscaledRect(element, position, scale) {
        var rect = getRect(element, position);
        function getRectLeft() {
          // If the element has been transformed from 50 0 origin, the left boundary of its bounding box has been shifted by half of the scaled width
          // When we unscale the rect, take the difference between the scaled width and the unscaled width
          // then divide this number by 2 (because 50% of that width is shifting the right boundary) and add it to the left boundary to get its
          // unscaled position
          return isTransformXOriginCentered ? rect.left + rect.width * (1 - 1 / scale) / 2 : rect.left;
        }
        rect.left = getRectLeft();
        rect.height /= scale;
        rect.width /= scale;
        rect.right = rect.left + rect.width;
        rect.bottom = rect.top + rect.height;
        return rect;
      }
      function getRect(element, position) {
        var offsetDeltas, rectData = elementToRectDataMap.get(element) || {}, rect = rectData.rect ? $.extend({}, rectData.rect) : null, isFixed = rectData.isFixed, isElementObserved = observedElementMap.get(element);
        function getOffsetDeltas(currentOffsets, cachedOffsets) {
          return {
            x: cachedOffsets.x - currentOffsets.x,
            y: cachedOffsets.y - currentOffsets.y
          };
        }
        if (rect) {
          if (isFixed) {
            // If the rectangle is fixed, we don't need to update its location coordinates on scroll
            // because fixed elements don't move on scroll
            return rect;
          }
          offsetDeltas = getOffsetDeltas(viewport.getPageOffsets(), rectData.offsets);
          rect.top += offsetDeltas.y;
          rect.bottom += offsetDeltas.y;
          rect.left += offsetDeltas.x;
          rect.right += offsetDeltas.x;
          return rect;
        }
        rect = helper.getRect(element);
        if (isElementObserved) {
          isFixed = "fixed" === position;
          elementToRectDataMap.set(element, {
            rect: rect,
            offsets: viewport.getPageOffsets(),
            isFixed: isFixed
          });
        }
        return rect;
      }
      function updateRect(element, rect) {
        var currentRectData = elementToRectDataMap.get(element);
        // The rect may have been invalidated already, in which case we should recalculate the rectangle on the next request
        if (currentRectData) {
          currentRectData.rect = rect;
          currentRectData.offsets = viewport.getPageOffsets();
          elementToRectDataMap.set(element, currentRectData);
        }
      }
      function deleteRect(element) {
        elementToRectDataMap.delete(element);
      }
      // listen for style mutations that will impact the element's bounding rectangle
      function listenForMutatedRect(element, handler) {
        handler = handler || noop;
        // We only allow a single handler to be attached
        if (observedElementMap.get(element)) {
          return;
        }
        styleLock.init(function() {
          styleListener.bindPropertyListener(element, "top", function() {
            /*jshint validthis: true */
            clearCache.call(this);
            handler.call(this);
          });
          // We don't want to lock width or height because they are styles that a commonly animated, so a lock is impractical
          styleListener.bindPropertyListener(element, "width", function() {
            /*jshint validthis: true */
            clearCache.call(this);
            handler.call(this);
          });
          styleListener.bindPropertyListener(element, "height", function() {
            /*jshint validthis: true */
            clearCache.call(this);
            handler.call(this);
          });
          styleLock.lock(element, {
            property: "display",
            handlers: {
              before: clearCache,
              after: handler
            }
          });
          styleLock.lock(element, {
            property: "position",
            handlers: {
              before: clearCache
            }
          });
          // This listener is a hacky way to detect if jQuery.fadeIn / fadeOut has been called on an element
          // We need to unlock display in this case, otherwise we see a flicker when opacity is removed but before
          // the display style lock is removed. This is an issue on TICC.com
          styleListener.bindPropertyListener(element, "opacity", function() {
            /*jshint validthis: true */
            styleLock.unlockStyle(this, "display");
          });
          observedElementMap.set(element, true);
        });
      }
      function init(isOriginCentered) {
        isTransformXOriginCentered = isOriginCentered;
        events.on("zoom", clearCache);
        domEvents.on(window, "resize", clearCache);
      }
      return {
        listenForMutatedRect: listenForMutatedRect,
        getUnscaledRect: getUnscaledRect,
        getRect: getRect,
        update: updateRect,
        delete: deleteRect,
        init: init
      };
    }($, run_bp_helper, page_positioner_style_lock_style_lock, page_positioner_style_lock_style_listener_style_listener, run_events, run_dom_events, page_viewport_viewport);
    page_positioner_transform_transform = function(elementMap, bodyGeo, state, targets, viewport, elementInfo, platform, rectCache, domEvents, arrayUtil, zoomStyle, scrollbars, config, events, nativeGlobal, inlineStyle, transitionUtil) {
      var shouldRestrictWidth, originalBody, isTransformXOriginCentered, shouldRepaintOnZoomChange, // Fixed elements taller than the viewport
      tallElements = [], // Fixed elements wider than the viewport
      wideElements = [], cachedXOffset = null, cachedYOffset = null, animationFrame = null, lastRepaintZoomLevel = null, resizeTimer = null, toolbarHeight = 0, MARGIN_FROM_EDGE = 15, isTransformingOnResize = false, // If we're using the toolbar, we need to transform fixed elements immediately or they may cover the toolbar / be covered
      isTransformingOnScroll = false;
      // This function scales and translates fixed elements as needed, e.g. if we've zoomed and the body is wider than the element
      function transformFixedElement(element, opts) {
        function getRectLeft(left, width, scale) {
          // Since transform origin 50 0 splits the scaled width evenly between the left and right sides, we need to subtract
          // half of the difference between the scaled and unscaled width from the left side
          return isTransformXOriginCentered ? left - width * (scale - 1) / 2 : left;
        }
        var resetCurrentTranslation = opts.resetTranslation, pageOffsets = viewport.getPageOffsets(), viewportDims = viewport.getInnerDimensions(), currentPageXOffset = pageOffsets.x, currentPageYOffset = pageOffsets.y, lastPageXOffset = elementMap.getField(element, "lastPageXOffset") || cachedXOffset, lastPageYOffset = elementMap.getField(element, "lastPageYOffset") || cachedYOffset, viewportWidth = viewportDims.width, viewportHeight = viewportDims.height, currentScale = elementInfo.getScale(element, "fixed"), unscaledRect = rectCache.getUnscaledRect(element, "fixed", currentScale), translationValues = getTranslationValues(element), currentXTranslation = translationValues.x, currentYTranslation = translationValues.y;
        // On zoom we should reset the current translations to
        // 1. reassess if we should shift the element vertically down by the toolbar offset
        // 2. we may not need to horizontally pan the element depending on its new width
        if (resetCurrentTranslation) {
          unscaledRect.left -= currentXTranslation;
          unscaledRect.top -= currentYTranslation;
          currentYTranslation = 0;
          currentXTranslation = 0;
        }
        var newXTranslation, newYTranslation, newScale = getRestrictedScale(unscaledRect, opts.onResize);
        elementInfo.setScale(element, newScale);
        if (!unscaledRect.width || !unscaledRect.height) {
          setNewTransform(element, 0, 0, newScale);
          cachePageOffsets(element, currentPageXOffset, currentPageYOffset);
          return;
        }
        // Calculate the dimensions of the fixed element after we apply the next scale transform
        var rect = {
          width: unscaledRect.width * newScale,
          height: unscaledRect.height * newScale,
          top: unscaledRect.top
        };
        rect.left = getRectLeft(unscaledRect.left, unscaledRect.width, newScale);
        rect.bottom = rect.top + rect.height;
        rect.right = rect.left + rect.width;
        newXTranslation = calculateXTranslation({
          scale: newScale,
          dimensions: rect,
          viewportWidth: viewportWidth,
          lastPageXOffset: lastPageXOffset,
          scrollDifference: currentPageXOffset - lastPageXOffset,
          currentPageXOffset: currentPageXOffset,
          currentXTranslation: currentXTranslation
        });
        newYTranslation = calculateYTranslation({
          dimensions: rect,
          viewportHeight: viewportHeight,
          scrollDifference: currentPageYOffset - lastPageYOffset,
          currentPageYOffset: currentPageYOffset,
          currentYTranslation: currentYTranslation,
          resetCurrentTranslation: resetCurrentTranslation
        });
        var xDelta = resetCurrentTranslation ? newXTranslation : newXTranslation - currentXTranslation, yDelta = resetCurrentTranslation ? newYTranslation : newYTranslation - currentYTranslation;
        // Translate the rectangle by our transformation, so that we can update the cached rectangle for this element. This allows us to avoid re-calculating
        // the binding rectangle on scroll, which is a very expensive operation
        rect.top += yDelta;
        rect.bottom += yDelta;
        rect.left += xDelta;
        rect.right += xDelta;
        setNewTransform(element, newXTranslation, newYTranslation, newScale);
        cachePageOffsets(element, currentPageXOffset, currentPageYOffset);
        rectCache.update(element, rect);
      }
      function getTranslationValues(element) {
        var split = inlineStyle(element).transform.split(/(?:\()|(?:px,*)/), index = split.indexOf("translate3d"), values = {
          x: 0,
          y: 0
        };
        if (index >= 0) {
          values.x = parseFloat(split[index + 1]);
          values.y = parseFloat(split[index + 2]);
        }
        return values;
      }
      function cachePageOffsets(element, xOffset, yOffset) {
        elementMap.setField(element, "lastPageXOffset", xOffset);
        elementMap.setField(element, "lastPageYOffset", yOffset);
      }
      function setNewTransform(element, translateX, translateY, scale) {
        var transform = "translate3d(" + translateX + "px, " + translateY + "px, 0) scale(" + scale + ")";
        transitionUtil.applyInstantTransform(element, transform);
      }
      function calculateXTranslation(args) {
        var currentXTranslation = args.currentXTranslation, elementWidth = Math.round(args.dimensions.width), left = args.dimensions.left, viewportWidth = args.viewportWidth, currentPageXOffset = args.currentPageXOffset, scrollDifference = args.scrollDifference, offLeft = elementWidth > viewportWidth ? left - scrollDifference : left, offRight = elementWidth - viewportWidth + offLeft, newXTranslation = elementWidth > viewportWidth ? currentXTranslation - scrollDifference : currentXTranslation, scrollWidth = bodyGeo.getScrollWidth();
        var bodyRect = rectCache.getRect(originalBody), percentOff = (bodyRect.left + currentPageXOffset) / bodyRect.width, intendedOff = elementWidth * percentOff;
        // Shift fixed elements out of the viewport by the same proportion as the body
        offLeft -= intendedOff;
        scrollWidth -= intendedOff;
        // If the fixed element is wider than the viewport
        if (elementWidth >= viewportWidth) {
          var scrollLimit = scrollWidth - viewportWidth, remainingScroll = scrollLimit - currentPageXOffset;
          // If the length of the element outside of the right side of the viewport is greater than the remaining scroll width, shift
          // the element the difference between the two values (so that we can pan the entire element into view)
          if (offRight > remainingScroll) {
            newXTranslation -= offRight - remainingScroll;
          } else {
            if (offRight < 0) {
              newXTranslation -= offRight;
            } else {
              if (currentPageXOffset >= 0 && currentPageXOffset < -offLeft || currentPageXOffset < 0 && currentPageXOffset !== -offLeft) {
                // Subtract
                newXTranslation -= offLeft + currentPageXOffset;
              } else {
                if (offLeft > 0 && currentPageXOffset >= 0) {
                  // Shift the element to the left side of the viewport
                  newXTranslation -= offLeft;
                }
              }
            }
          }
        } else {
          if (offRight > 0) {
            newXTranslation = -offRight + currentXTranslation - MARGIN_FROM_EDGE;
          } else {
            if (offLeft < 0) {
              newXTranslation = -offLeft + currentXTranslation + MARGIN_FROM_EDGE;
            }
          }
        }
        return newXTranslation;
      }
      function calculateYTranslation(args) {
        var viewportHeight = args.viewportHeight, currentYTranslation = args.currentYTranslation, currentPageYOffset = args.currentPageYOffset, resetCurrentTranslation = args.resetCurrentTranslation, elementHeight = args.dimensions.height, bottom = args.dimensions.bottom, top = args.dimensions.top, scrollDifference = args.scrollDifference, scrollHeight = bodyGeo.getScrollHeight(), isTallerThanViewport = elementHeight > viewportHeight - toolbarHeight;
        if (resetCurrentTranslation && toolbarHeight) {
          if (shouldVerticallyShiftFixedElement(top, bottom, viewportHeight, elementHeight)) {
            currentYTranslation += toolbarHeight;
            top += toolbarHeight;
            bottom += toolbarHeight;
          }
        }
        var newYTranslation = currentYTranslation, bottomOutOfView = bottom > viewportHeight, topOutOfView = top < toolbarHeight;
        if (resetCurrentTranslation) {
          // On reset, translate fixed elements below the toolbar
          // or if they're below the viewport, translate them into view
          if (isTallerThanViewport) {
            var correctedYTranslation = currentYTranslation, yTranslationLimit = viewportHeight - elementHeight - toolbarHeight, scrollLimit = scrollHeight - viewportHeight, offsetRemaining = Math.abs(yTranslationLimit - currentYTranslation), scrollRemaining = scrollLimit - currentPageYOffset, scrollPercent = currentPageYOffset / scrollLimit;
            // If the scroll distance to the edge of the page is less than the distance required to translate the
            // fixed element completely into the viewport, set the current y offset to a proportional value to the current pageYOffset
            if (offsetRemaining > scrollRemaining) {
              correctedYTranslation = yTranslationLimit * scrollPercent;
            }
            newYTranslation = correctedYTranslation;
          } else {
            if (bottomOutOfView) {
              newYTranslation += viewportHeight - bottom;
            }
          }
        } else {
          if (isTallerThanViewport) {
            // If we've scrolled down
            if (scrollDifference > 0) {
              if (bottomOutOfView) {
                newYTranslation -= Math.min(scrollDifference, bottom - viewportHeight);
              }
            } else {
              if (scrollDifference < 0) {
                if (topOutOfView) {
                  newYTranslation += Math.min(-scrollDifference, toolbarHeight - top);
                }
              }
            }
          }
        }
        return newYTranslation;
      }
      function getRestrictedScale(dimensions, isOnResize) {
        var scrollWidth = bodyGeo.getScrollWidth(isOnResize), elementWidth = dimensions.width;
        return Math.min(state.fixedZoom, scrollWidth / elementWidth);
      }
      function shouldVerticallyShiftFixedElement(top, bottom, viewportHeight, elementHeight) {
        // We shift fixed elements if they are clipping the boundaries of the toolbar
        // or if they are positioned in the middle 60% of the viewport height. This heuristic works pretty well, we don't shift elements that
        // are near the bottom of the screen, and we don't shift dropdown fixed menus that are intended to be flush with the top menu
        var isOverlappingToolbar = top < toolbarHeight, isFlushWithToolbar = top === toolbarHeight, isCloseToBottom = .8 * viewportHeight < bottom, isTallerThanViewport = elementHeight > viewportHeight;
        // Fixed elements that are close to the bottom or top are much more likely to be part of fixed menus that are
        // intended to be flush with the edges of the viewport
        return isTallerThanViewport || isOverlappingToolbar || !isFlushWithToolbar && !isCloseToBottom;
      }
      function transformAllTargets(opts) {
        targets.forEach(function(element) {
          transformFixedElement(element, opts);
        });
        if (lastRepaintZoomLevel !== state.completedZoom && shouldRepaintOnZoomChange) {
          lastRepaintZoomLevel = state.completedZoom;
          zoomStyle.repaintToEnsureCrispText();
        }
      }
      function refreshResizeListener() {
        function onResize() {
          clearTimeout(resizeTimer);
          resizeTimer = nativeGlobal.setTimeout(function() {
            targets.forEach(scaleTopInstant);
            transformAllTargets({
              resetTranslation: true,
              onResize: true
            });
            refreshScrollListener();
          }, 200);
        }
        var doTransformOnResize = Boolean(targets.getCount());
        if (!isTransformingOnResize && doTransformOnResize) {
          // There may be css media rules that change positioning of fixed elements when the viewport is resized
          window.addEventListener("resize", onResize);
        } else {
          if (isTransformingOnResize && !doTransformOnResize) {
            window.removeEventListener("resize", onResize);
          }
        }
      }
      function refreshElementTransform(element) {
        transformFixedElement(element, {
          resetTranslation: true
        });
        refreshScrollListener(element);
        refreshResizeListener();
      }
      function fixZIndex(element) {
        // In IE, transformed fixed elements show up underneath other elements on the page when we apply a transformation
        // This is because we don't transplant fixed elements in IE, so the new containing blocks created by the transformation
        // are layered within the original body
        if (false) {
          var zIndex = getComputedStyle(element).zIndex;
          if ("auto" === zIndex) {
            inlineStyle.override(element, {
              zIndex: "999999"
            });
          }
        }
      }
      function scaleTopInstant(element) {
        transitionUtil.disableStyleTransition(element, "top");
        restoreTop(element);
        if (1 === state.completedZoom) {
          // We don't need to scale the top if we aren't zooming
          return;
        }
        // Absolute elements return the used top value if there isn't one specified. Setting the position to static ensures
        // that only specified top values are returned with the computed style
        // EXCEPTION: IE returns the used value for both
        if (true) {
          inlineStyle.override(element, [ "position", "static", "important" ]);
        }
        var specifiedTop = getComputedStyle(element).top, specifiedValue = parseFloat(specifiedTop), newValue = specifiedValue * state.fixedZoom + "px";
        if (newValue !== specifiedValue && !isNaN(specifiedValue) && specifiedTop.indexOf("px") >= 0) {
          inlineStyle.override(element, [ "top", newValue ]);
        }
        inlineStyle.restoreLast(element, "position");
        inlineStyle.restoreLast(element, "transition");
      }
      function restoreTop(element) {
        inlineStyle.restore(element, "top");
      }
      function onTargetAdded(element) {
        inlineStyle.override(element, [ "transformOrigin", isTransformXOriginCentered ? "50% 0" : "0 0" ]);
        // This handler runs when a style relevant to @element's bounding rectangle has mutated
        rectCache.listenForMutatedRect(element, function() {
          /*jshint validthis: true */
          if (targets.has(this)) {
            scaleTopAndTransform(element);
            fixZIndex(element);
          }
        });
        rectCache.listenForMutatedRect(originalBody);
        scaleTopAndTransform(element);
        fixZIndex(element);
      }
      function onTargetRemoved(element) {
        inlineStyle.restore(element, [ "transform", "transformOrigin", "top" ]);
        rectCache.delete(element);
        // This is the cached metadata we used for transforming the element. We need to clear it now that
        // the information is stale
        elementMap.flushField(element, [ "lastPageXOffset", "lastPageYOffset", "scale", "unscaledTop" ]);
        refreshResizeListener();
        refreshScrollListener(element);
      }
      function scaleTopAndTransform(element) {
        scaleTopInstant(element);
        refreshElementTransform(element);
      }
      function onScroll() {
        function transformOnScroll() {
          if (animationFrame) {
            cancelAnimationFrame(animationFrame);
          }
          animationFrame = requestAnimationFrame(function() {
            transformAllTargets({});
          });
        }
        var currentOffsets = viewport.getPageOffsets(), xDelta = currentOffsets.x - cachedXOffset, yDelta = currentOffsets.y - cachedYOffset, doVerticalTransform = Boolean(tallElements.length), doHorizontalTransform = Boolean(wideElements.length);
        cachedXOffset = currentOffsets.x;
        cachedYOffset = currentOffsets.y;
        if (xDelta && doHorizontalTransform || yDelta && doVerticalTransform) {
          transformOnScroll();
        }
      }
      function refreshScrollListener(element) {
        var viewportDims = viewport.getInnerDimensions(), viewportHeight = viewportDims.height, viewportWidth = viewportDims.width;
        function identifyTallOrWideElement(element) {
          var rect = rectCache.getRect(element, "fixed"), height = rect.height, width = rect.width;
          if (height > viewportHeight) {
            arrayUtil.addUnique(tallElements, element);
          } else {
            tallElements = arrayUtil.remove(tallElements, element);
          }
          if (width > viewportWidth) {
            arrayUtil.addUnique(wideElements, element);
          } else {
            wideElements = arrayUtil.remove(wideElements, element);
          }
        }
        // If this function is called when we add a transform target, evaluate the new target
        if (element) {
          identifyTallOrWideElement(element);
        } else {
          tallElements = [];
          wideElements = [];
          targets.forEach(identifyTallOrWideElement);
        }
        var addOrRemoveFn, doTransformOnHorizontalScroll = Boolean(wideElements.length), doTransformOnVerticalScroll = Boolean(tallElements.length), doTransformOnScroll = doTransformOnHorizontalScroll || doTransformOnVerticalScroll;
        scrollbars.forceScrollbars(doTransformOnHorizontalScroll, doTransformOnVerticalScroll);
        if (doTransformOnScroll !== isTransformingOnScroll) {
          addOrRemoveFn = doTransformOnScroll ? domEvents.on : domEvents.off;
          addOrRemoveFn(window, "scroll", onScroll, {
            capture: false
          });
          isTransformingOnScroll = doTransformOnScroll;
        }
      }
      function onZoom() {
        nativeGlobal.setTimeout(function() {
          targets.forEach(scaleTopInstant);
          refresh();
        }, 0);
      }
      // Typically these are shift transforms that assume that the body is untransformed. Once we transform the body, these fixed elements will effectively
      // be absolutely positioned relative to the body and thus do not need to be specifically shifted. We'll update these transformations once they've been
      // transplanted.
      function clearInvalidTransforms() {
        targets.forEach(function(element) {
          if (true && 1 === state.completedZoom && elementInfo.isInOriginalBody(element)) {
            inlineStyle.restore(element, "transform");
          }
        });
      }
      function refresh() {
        transformAllTargets({
          resetTranslation: true
        });
        refreshScrollListener();
      }
      function init(toolbarHght) {
        if (toolbarHght) {
          toolbarHeight = toolbarHght;
        }
        originalBody = document.body;
        shouldRestrictWidth = config.shouldRestrictWidth;
        isTransformXOriginCentered = !shouldRestrictWidth;
        rectCache.init(isTransformXOriginCentered);
        // In Chrome we have to trigger a repaint after we transform elements because it causes blurriness
        shouldRepaintOnZoomChange = true;
        targets.init();
        targets.registerAddHandler(onTargetAdded);
        targets.registerRemoveHandler(onTargetRemoved);
        events.on("zoom", onZoom);
        events.on("zoom/begin", clearInvalidTransforms);
      }
      return {
        init: init,
        refresh: refresh,
        allTargets: transformAllTargets
      };
    }(page_positioner_util_element_map, page_zoom_util_body_geometry, page_zoom_state, page_positioner_transform_targets, page_viewport_viewport, page_positioner_util_element_info, run_platform, page_positioner_transform_rect_cache, run_dom_events, run_util_array_utility, page_zoom_style, page_viewport_scrollbars, page_zoom_config_config, run_events, mini_core_native_global, run_inline_style_inline_style, page_util_transition_util);
    page_positioner_positioner = function(platform, transplant, transform, transformTargets, state, styleLock, elementInfo, constants, bodyGeo, events, nativeGlobal) {
      var originalBody, docElem, unprocessedTransplantCandidates, // Should we transplant elements from the original body to the auxiliary body
      isTransplanting = false, isTransplantInitialized = false, // Should we replant elements from the auxiliary body to the original body
      isReplanting = false, // Do we ever use the transplant operation (not IE browser flag)
      doUseTransplantOperation = false, isInitialized = false, // If there's a toolbar we need to translate fixed elements down
      areFixedHandlersRegistered = false, isFirstZoom = true, TRANSPLANT_STATE = constants.TRANSPLANT_STATE;
      function onZoom(completedZoom) {
        isTransplanting = Boolean(completedZoom > 1 && doUseTransplantOperation);
        if (isTransplanting) {
          initializeTransplant();
          processTransplantCandidates();
        }
        // If we we're listening for fixed positioning, initialize the listener
        if (isFirstZoom) {
          onFirstZoom();
        }
        unlockPositionIfNotZoomed();
      }
      function onFirstZoom() {
        if (!areFixedHandlersRegistered) {
          styleLock.init(function() {
            initFixedPositionListener();
          });
        }
        // This flag means that we should run the transplant operation even if we're aren't zoomed in cases
        // where we have to replant an element back to the original body
        isReplanting = doUseTransplantOperation;
        isFirstZoom = false;
      }
      function initializeTransplant() {
        if (!isTransplantInitialized) {
          transplant.init();
          isTransplantInitialized = true;
        }
      }
      function processTransplantCandidates() {
        unprocessedTransplantCandidates.forEach(function(candidate) {
          // TODO: order these initial position handlers by distance from body, closest distance runs first
          nativeGlobal.setTimeout(function(candidate) {
            var position = getComputedStyle(candidate).position;
            if ("fixed" === position) {
              toPositionHandler.call(candidate, {
                toValue: position
              });
            }
          }, 0, candidate);
        });
        unprocessedTransplantCandidates.clear();
      }
      function initFixedPositionListener() {
        styleLock.lock({
          property: "position",
          value: "fixed"
        }, {
          initial: toPositionHandler,
          before: fromPositionBeforeHandler,
          after: fromPositionAfterHandler
        });
        areFixedHandlersRegistered = true;
      }
      function unlockPositionIfNotZoomed(element) {
        // If we haven't zoomed we haven't applied a horizontal translation to the fixed element, so it isn't worth the delay
        // to unlock the element (there is a slight blink on chicagolighthouse's fixed navbar without this)
        if (1 === state.completedZoom) {
          // If @element is undefined, unlocks all elements with a locked position
          styleLock.unlockStyle(element, "position");
        }
      }
      // This handler runs when we find an element with a resolved fixed or absolute position
      function toPositionHandler(args) {
        /*jshint validthis: true */
        var position = args.toValue, oldPosition = args.fromValue, wasFixed = "fixed" === oldPosition;
        // These cases are handled by fromPosition hooks
        if (wasFixed) {
          return;
        }
        var isFixed = "fixed" === position, isInOriginalBody = elementInfo.isInOriginalBody(this), flags = {
          isFixed: isFixed,
          isInOriginalBody: isInOriginalBody
        };
        if (isReplanting) {
          var results = transplant.evaluateCandidate(this, flags);
          if (results) {
            var transplantState = results.transplantState, needsTransplant = transplantState === TRANSPLANT_STATE.UNCLONED || transplantState === TRANSPLANT_STATE.CLONED || transplantState === TRANSPLANT_STATE.MIXED;
            if (!needsTransplant || needsTransplant && isTransplanting) {
              transplant.performOperation(this, results);
              transformElement(this, flags);
              transplant.postOperation(this, results);
            } else {
              unprocessedTransplantCandidates.add(this);
            }
          }
        } else {
          if (doUseTransplantOperation) {
            // Evaluate the element's transplant status once we have to transplant fixed elements (after a zoom is applied to the body)
            unprocessedTransplantCandidates.add(this);
          }
        }
        // Even if we don't transplant the fixed element, potentially we still need to shift the element below the toolbar
        if (isFixed && !isTransplanting) {
          transformTargets.add(this);
        }
        unlockPositionIfNotZoomed(this);
      }
      // This handler runs when the document is mutated such that an element no longer resolves to the specified style value
      // Since we've applied a 'locking' style, that resolved style hasn't taken effect yet when this handler runs
      function fromPositionBeforeHandler(args) {
        /*jshint validthis: true */
        var oldPosition = args.fromValue, position = args.toValue, // A transplant root is an element with a position value that requires that it be transplanted into the auxiliary body.
        // Typically this value is 'fixed', but occasionally we also need to transplant absolute elements
        isTransplantRoot = elementInfo.isTransplantRoot(this), // A transplant anchor is a root element with no ancestor roots. All of the elements in its subtree are original,
        // regardless of their current position value. If a subroot becomes statically positioned, it will not be replanted
        // into the original body. If a transplant anchor becomes statically positioned, it will be replanted into the original body
        // and each of its subroots will be transplanted back into the auxiliary body
        isTransplantAnchor = elementInfo.isTransplantAnchor(this), isInOriginalBody = elementInfo.isInOriginalBody(this), isFixed = "fixed" === position, wasFixed = "fixed" === oldPosition, flags = {
          isTransplantAnchor: isTransplantAnchor,
          isTransplantRoot: isTransplantRoot,
          isInOriginalBody: isInOriginalBody,
          isFixed: isFixed,
          wasFixed: wasFixed
        };
        if (isReplanting) {
          var results = transplant.evaluateCandidate(this, flags);
          if (results) {
            var transplantState = results.transplantState, needsTransplant = transplantState === TRANSPLANT_STATE.UNCLONED || transplantState === TRANSPLANT_STATE.CLONED || transplantState === TRANSPLANT_STATE.MIXED;
            if (!needsTransplant || needsTransplant && isTransplanting) {
              results.doPerformTransplant = true;
              return results;
            } else {
              unprocessedTransplantCandidates.add(this);
            }
          }
        } else {
          if (doUseTransplantOperation) {
            // Evaluate the element's transplant status once we have to transplant fixed elements (after a zoom is applied to the body)
            unprocessedTransplantCandidates.add(this);
          }
        }
        return {
          flags: flags
        };
      }
      // This handler runs after we've unlocked the style value on the element, so that its new resolved value takes effect
      // e.g., if we we're applying 'position: absolute !important', that style has now been removed and the element's true position is in effect
      function fromPositionAfterHandler(opts) {
        /*jshint validthis: true */
        var flags = opts.flags, doPerformTransplant = opts.doPerformTransplant;
        if (doPerformTransplant) {
          transplant.performOperation(this, opts);
          transformElement(this, flags);
          transplant.postOperation(this, opts);
        } else {
          transformElement(this, flags);
        }
        unlockPositionIfNotZoomed(this);
      }
      // Applies or removes transformation from element, based on position and transplant status
      function transformElement(element, flags) {
        var isTransplantAnchor = flags.isTransplantAnchor, isFixed = flags.isFixed;
        if (isTransplantAnchor || isFixed) {
          transformTargets.add(element);
        } else {
          transformTargets.remove(element);
        }
      }
      function initFromToolbar(callback, toolbarHeight) {
        if (isInitialized) {
          callback();
          return;
        }
        init(function() {
          transform.init(toolbarHeight);
          styleLock.init(function() {
            // The toolbar may overlap with fixed elements so we'll need to transform them immediately
            // Fixed position elements are located and their position locked, so that we can run handlers before
            // and after the element's position changes.
            initFixedPositionListener();
            callback();
          });
        });
      }
      function initFromZoom() {
        if (isInitialized) {
          return;
        }
        init(function() {
          transform.init();
          // We only need to use the transplant algorithm once we've applied a transformation on the body, i.e. when we've zoomed
          nativeGlobal.setTimeout(onZoom, 0, state.completedZoom);
        });
      }
      function init(callback) {
        isInitialized = true;
        function onBodyGeoInitialized() {
          elementInfo.init();
          if (doUseTransplantOperation) {
            unprocessedTransplantCandidates = new Set();
          }
          events.on("zoom", onZoom);
          callback();
        }
        // Internet Explorer doesn't require us to use the transplant algorithm because transformed elements do not create new
        // containing blocks for fixed descendants, and fixed descendants do not inherit transformations
        doUseTransplantOperation = true;
        docElem = document.documentElement;
        originalBody = document.body;
        return bodyGeo.init(onBodyGeoInitialized);
      }
      return {
        initFromZoom: initFromZoom,
        initFromToolbar: initFromToolbar
      };
    }(run_platform, page_positioner_transplant_transplant, page_positioner_transform_transform, page_positioner_transform_targets, page_zoom_state, page_positioner_style_lock_style_lock, page_positioner_util_element_info, page_positioner_constants, page_zoom_util_body_geometry, run_events, mini_core_native_global);
    page_focus_focus = function($, pref) {
      var isDark, isEnabled, MIN_ZOOM = 1.4, // minimum zoom at which focus enhancement appears
      FOCUS_RING_COLOR_ON_LIGHT = "rgba(82,168,236,.8)", // color of focus enhancement on normal/warm/bold theme
      FOCUS_RING_COLOR_ON_DARK = "rgba(255,255,100,.8)", // color of focus enhancement on dark theme
      $styleSheet = $(), zoomLevel = 1;
      // show focus enhancement
      function show() {
        // hide focus first to allow
        // recalculate outline thickness
        hide();
        var color = isDark ? FOCUS_RING_COLOR_ON_DARK : FOCUS_RING_COLOR_ON_LIGHT;
        // create style element
        // append focus css rule to it
        $styleSheet = $("<style>").html('*:not(html):not(body):not(#sitecues-badge):not([id^="scp-"]):focus{outline:0;box-shadow:0 0 3pt 2pt ' + color + ";}").appendTo("head");
      }
      // hide focus enhancement
      function hide() {
        $styleSheet.remove();
      }
      // refresh focus enhancement bindings on the page
      function refreshFeatureEnablement() {
        if (isEnabled) {
          // if focus enhancement is enabled,
          // bind `blur` and `focus` events to
          // proper handlers. use selector for
          // filtering of matched elements
          show();
        } else {
          // unbind event handlers if focus
          // enhancement is disabled
          hide();
        }
      }
      function refresh(newZoomLevel, willBeDark) {
        // remember previous state of focus
        var wasEnabled = isEnabled, isColorChanging = willBeDark !== isDark;
        zoomLevel = newZoomLevel;
        isDark = willBeDark;
        // determinate should focus enhancement
        // be enabled or not
        isEnabled = newZoomLevel >= MIN_ZOOM || willBeDark;
        // if state of enhancement was changed
        // refresh module bindings on the page
        if (wasEnabled !== isEnabled || isColorChanging) {
          refreshFeatureEnablement();
        }
      }
      function init() {
        // subscribe to zoom changes and update
        // enhancement state with each change
        pref.bindListener("zoom", function(currZoom) {
          refresh(currZoom, isDark);
        });
        pref.bindListener("themeName", function(themeName) {
          refresh(zoomLevel, "dark" === themeName);
        });
      }
      return {
        init: init
      };
    }($, run_conf_preferences);
    page_page = function(reset) {
      function init() {
        reset.init();
      }
      return {
        init: init
      };
    }(page_reset_reset);
    theme_color_choices = function($, colorUtil) {
      var hslToRgb = colorUtil.hslToRgb, rgbToHsl = colorUtil.rgbToHsl;
      function getReducedIntensity(rgba, intensity) {
        var hsl = rgbToHsl(rgba.r, rgba.g, rgba.b);
        if (hsl.l < .5) {
          hsl.l = 1 - intensity * (1 - hsl.l);
        } else {
          hsl.l *= intensity;
        }
        var lightenedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
        lightenedRgb.a = rgba.a;
        return lightenedRgb;
      }
      //    function getInvertedLightness(rgba) {
      //      var hsl = rgbToHsl(rgba.r, rgba.g, rgba.b);
      //      hsl.l = 1 - hsl.l;  // Invert lightness
      //      var invertedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
      //      invertedRgb.a = rgba.a;
      //      return invertedRgb;
      //    }
      // style object is as follows:
      // rgba: color
      // prop: property name ('background', 'background-color' or 'color')
      //    function monochrome (style, intensity) {
      //      var mixInHsl = (style.prop === 'color') ? monoForegroundHsl : monoBackgroundHsl,
      //        rgba = style.parsedVal,
      //        origHsl = rgbToHsl(rgba.r, rgba.g, rgba.b),
      //        origLightness = Math.max(origHsl.l, 1 - origHsl.l);
      //      intensity = Math.max(intensity * origLightness, MIN_INTENSITY);
      //      var newRgba = $.extend({}, rgba, hslToRgb(mixInHsl.h, mixInHsl.s, mixInHsl.l));
      //      return getReducedIntensity(newRgba, intensity);
      //    };
      //    function darkWithHue(hue, style, intensity) {
      //      if (style.prop === 'color') {
      //        var rgba = style.parsedVal,
      //          hsl = rgbToHsl(rgba.r, rgba.g, rgba.b),
      //          origLightness = Math.max(Math.max(hsl.l, 1 - hsl.l), 0.5);
      //        intensity = Math.max(origLightness, intensity);
      //        var newRgba = $.extend({}, rgba, hslToRgb(hue, 1, 0.5));
      //        return getReducedIntensity(newRgba, intensity);
      //      }
      //      else {
      //        return getReducedIntensity(BLACK, intensity);
      //      }
      //    }
      //
      function isHueBrightEnoughForDarkTheme(hue) {
        return hue <= .56 || hue >= .8 && hue <= .92;
      }
      function getClosestGoodHueForDarkTheme(hue) {
        if (isHueBrightEnoughForDarkTheme(hue)) {
          return hue;
        }
        if (hue >= .96) {
          return 0;
        } else {
          if (hue >= .92) {
            return .92;
          } else {
            if (hue >= .68) {
              // .56-.8 is a hole
              return .8;
            }
          }
        }
        return .56;
      }
      function getSampleElements(selector) {
        var REMOVE_PSEUDO_CLASSES_AND_ELEMENTS = /::?[^ ,:.]+/g, $result = $();
        try {
          $result = $(selector.replace(REMOVE_PSEUDO_CLASSES_AND_ELEMENTS, ""));
        } catch (ex) {}
        return $result;
      }
      function isInDarkParagraph($sampleElements, luminosity) {
        var isInDarkPara;
        $sampleElements.each(function(index, sampleElement) {
          var sampleElementStyle = getComputedStyle(sampleElement);
          if ("inline" === sampleElementStyle.display) {
            var parentLuminosity, parentElement = sampleElement.parentElement, parentStyle = getComputedStyle(parentElement), parentInnerText = parentElement.innerText, sampleInnerText = sampleElement.innerText;
            if (parentInnerText && parentInnerText.trim().length > (sampleInnerText && sampleInnerText.length) && sampleElementStyle.backgroundColor === parentStyle.backgroundColor) {
              parentLuminosity = colorUtil.getLuminanceFromColorName(parentStyle.color);
              if (parentLuminosity !== luminosity) {
                if (parentLuminosity < .3) {
                  isInDarkPara = true;
                  return false;
                }
                if (parentLuminosity > .7) {
                  isInDarkPara = false;
                  return false;
                }
              }
            }
          }
        });
        return isInDarkPara;
      }
      function isWithDarkForeground($sampleElements) {
        return colorUtil.getLuminanceFromColorName($sampleElements.css("color")) < .5;
      }
      /**
   * @param {object} style { parsedVal: rgba, selector, prop: 'color', etc. }
   * @return -1: decrease lightness, 0: do nothing, 1: increase lightness
   */
      function computeContrastEnhancementDirection(style) {
        var $sampleElements, rgba = style.parsedVal, luminosity = colorUtil.getLuminanceFromColorName(rgba);
        if ("color" === style.prop) {
          // Foreground decision
          $sampleElements = getSampleElements(style.selector);
          var isInDarkPara = isInDarkParagraph($sampleElements, luminosity);
          if ("undefined" !== typeof isInDarkPara) {
            return isInDarkPara ? 1 : -1;
          }
          // Middle of the road foreground color -- analyze background
          // If on light background make text darker, and vice-versa
          var isOnDarkBg = colorUtil.isOnDarkBackground($sampleElements[0]);
          if ("undefined" !== typeof isOnDarkBg) {
            return isOnDarkBg ? 1 : -1;
          }
          return luminosity < .5 ? -1 : 1;
        }
        // Background decision
        if (luminosity > .4 && luminosity < .6) {
          // Not sure about bg, check fg darkness
          $sampleElements = getSampleElements(style.selector);
          var isWithDarkFg = isWithDarkForeground($sampleElements);
          if ("undefined" !== typeof isWithDarkFg) {
            return isWithDarkFg ? 1 : -1;
          }
        }
        return luminosity < .5 ? -1 : 1;
      }
      function getContrastEnhancementDirection(style) {
        if ("undefined" !== typeof style.contrastEnhancementDirection) {
          return style.contrastEnhancementDirection;
        }
        var direction = computeContrastEnhancementDirection(style);
        style.contrastEnhancementDirection = direction;
        // Cache
        return direction;
      }
      function getSaturationImpactOnContrast(saturation) {
        return .3 + .8 * saturation;
      }
      function bold(style, intensity) {
        var colorChangeIntensity = intensity / 1.6 + .1, textShadowIntensity = intensity / 3.5, rgba = style.parsedVal, hsl = rgbToHsl(rgba.r, rgba.g, rgba.b), newLightness = hsl.l, saturation = hsl.s, // Reduce contrast change for saturated colors so that we remain colorful
        power = 4 * (1 - colorChangeIntensity) * getSaturationImpactOnContrast(saturation) + ("color" === style.prop ? 0 : .2), factor = "color" === style.prop ? 2 : 6, contrastEnhancementDirection = getContrastEnhancementDirection(style), newAlpha = rgba.a;
        if (contrastEnhancementDirection < 0) {
          // Reduce lightness
          newLightness = hsl.l - Math.pow(hsl.l / factor, power) * colorChangeIntensity;
          // Also increase the alpha if it's < 1
          // This multiplies the alpha, so that if the original is fully transparent it remains transparent
          if (newAlpha < 1) {
            newAlpha = Math.min(1, newAlpha * (colorChangeIntensity + 1));
          }
        } else {
          if (contrastEnhancementDirection > 0) {
            // Reduce darkness
            var darkness = 1 - hsl.l, newDarkness = darkness - Math.pow(darkness / factor, power) * colorChangeIntensity;
            newLightness = 1 - newDarkness;
          }
        }
        var lightnessDiff = Math.abs(newLightness - hsl.l), MIN_SIGNIFICANT_LIGHTNESS_DIFF = .01, isSignificantChange = lightnessDiff > MIN_SIGNIFICANT_LIGHTNESS_DIFF || newAlpha !== rgba.a, returnVal = isSignificantChange ? $.extend({
          a: newAlpha
        }, hslToRgb(hsl.h, hsl.s, newLightness)) : rgba;
        if ("color" === style.prop) {
          // Make the text thicker
          returnVal = $.extend({}, returnVal, {
            textShadow: textShadowIntensity
          });
        }
        return returnVal;
      }
      //    var yowza = 0;
      //    function darkCreative (style, intensity) {
      //
      //      // Hues from .1 - .56 and .84 - .86 are dark enough
      //      var MIN_CONTRAST_RATIO = 4.4,
      //        NUM_COLORS = 50,
      //        newHue,
      //        contrastRatio,
      //        oldYowza = yowza;
      //      while (true) {
      //        yowza = ((yowza + 1) % NUM_COLORS);
      //        newHue = yowza / NUM_COLORS;
      //        contrastRatio = colorUtil.getContrastRatio(hslToRgb(newHue, 1, 0.5), BLACK);
      //        if (contrastRatio > MIN_CONTRAST_RATIO) {
      //          if (SC_DEV) { console.log('--> ' + yowza + ' ' + newHue + ' ' + contrastRatio + ':1'); }
      //          break;
      //        }
      //        if (yowza === oldYowza) {
      //          break;
      //        }
      //      }
      //      return darkWithHue(newHue, style, intensity);
      //    };
      function getSaturation(rgba) {
        return rgbToHsl(rgba.r, rgba.g, rgba.b).s;
      }
      function colorizeGrayText(rgba, textHue) {
        var FOREGROUND_MIXIN_INTENSITY = .5, grayness = 1 - getSaturation(rgba), mixInRatio = FOREGROUND_MIXIN_INTENSITY * (grayness + .2) / 1.2, // More gray (less saturated)  = more channel reduction, so we can keep colors
        mixInRgba = hslToRgb(textHue, 1, .5);
        return mixRgbaColors(rgba, mixInRgba, mixInRatio);
      }
      function dark(style, intensity, textHue) {
        var hsl, colorizedRgba, newRgba, origLightness, newLightness, bgAddedLightness, bgPreservationFactor, newHue, rgba = style.parsedVal, foregroundIntensity = .4 + Math.min(intensity, .8) / 1.3, textShadowIntensity = .6 * Math.max(0, intensity - .8);
        if ("color" === style.prop) {
          colorizedRgba = textHue && textHue <= 1 ? colorizeGrayText(rgba, textHue) : rgba;
          hsl = rgbToHsl(colorizedRgba.r, colorizedRgba.g, colorizedRgba.b);
          origLightness = Math.max(hsl.l, 1 - hsl.l);
          newLightness = foregroundIntensity * (origLightness + .1);
          newLightness *= 1.2 - hsl.s / 6;
          // Saturated colors should be kept a bit
          newLightness = Math.max(newLightness, foregroundIntensity / 3);
          newLightness = Math.min(newLightness, 1);
          newHue = getClosestGoodHueForDarkTheme(hsl.h);
          newRgba = $.extend({}, rgba, hslToRgb(newHue, hsl.s, newLightness));
          if (textShadowIntensity > 0) {
            newRgba.textShadow = textShadowIntensity;
          }
        } else {
          hsl = rgbToHsl(rgba.r, rgba.g, rgba.b);
          bgAddedLightness = (1 - intensity) / 8;
          // Add a little lightness when theme is less intense
          bgPreservationFactor = .6 - intensity / 8;
          origLightness = hsl.l;
          newLightness = origLightness < .4 ? origLightness : 3 * (1 - origLightness);
          newRgba = $.extend({}, rgba, hslToRgb(hsl.h, hsl.s, Math.min(.16, newLightness) * bgPreservationFactor + bgAddedLightness));
        }
        return newRgba;
      }
      //    // Invert all colors using HSL inversion
      //    hslInvert (style, intensity) {
      //      return getReducedIntensity(getInvertedLightness(style.parsedVal), intensity);
      //    };
      //
      //    // Invert all colors using RGB inversion
      //    rgbInvert (style, intensity) {
      //      var rgba = style.parsedVal,
      //        newRgba = {
      //          r: 255 - rgba.r,
      //          g: 255 - rgba.g,
      //          b: 255 - rgba.b,
      //          a: rgba.a
      //        };
      //      return getReducedIntensity(newRgba, intensity);
      //    };
      function mixRgbaColors(origRgba, mixInRgba, mixInRatio) {
        var reductionRatio = 1 - mixInRatio;
        function mixChannel(origChannelValue, mixInChannelValue) {
          return Math.min(Math.round(origChannelValue * reductionRatio + mixInChannelValue * mixInRatio), 255);
        }
        return {
          r: mixChannel(origRgba.r, mixInRgba.r),
          g: mixChannel(origRgba.g, mixInRgba.g),
          b: mixChannel(origRgba.b, mixInRgba.b),
          a: origRgba.a
        };
      }
      function warm(style, intensity) {
        var rgba = $.extend({}, style.parsedVal);
        intensity = 1 - intensity / 3;
        if ("color" === style.prop && rgbToHsl(rgba.r, rgba.g, rgba.b).l < .2) {
          return getReducedIntensity(rgba, intensity - .15);
        }
        var mixInRatio = /*rgba.b * 0.001 */
        .2 * (1 - intensity), mixInRgba = hslToRgb(.15, 1, .5);
        return mixRgbaColors(rgba, mixInRgba, mixInRatio);
      }
      return {
        dark: dark,
        bold: bold,
        warm: warm
      };
    }($, page_util_color);
    theme_custom_site_theme = function(site, urls) {
      // TODO build system could create this variable based on the available themes
      // var SITES_WITH_CUSTOM_THEMES = '__SITES_WITH_CUSTOM_THEMES__';
      var isInitialized, SITES_WITH_CUSTOM_THEMES = {
        "s-0000ee0c": 1,
        "s-05fd6c66": 1,
        "s-0796b61d": 1,
        "s-167ff09a": 1,
        "s-190630d2": 1,
        "s-2158b12a": 1,
        "s-252baed8": 1,
        "s-25cecd79": 1,
        "s-389f76da": 1,
        "s-4bfe60ab": 1,
        "s-570759e3": 1,
        "s-6d6f89a3": 1,
        "s-73dd0fcf": 1,
        "s-7b90f601": 1,
        "s-9afa6ab9": 1,
        "s-acc8f046": 1,
        "s-b427fffb": 1,
        "s-c27fa71d": 1,
        "s-f2a9dde2": 1
      };
      function insertSheet(siteId) {
        var cssLink = document.createElement("link"), cssUrl = urls.resolveResourceUrl("css/site-themes/" + siteId + ".css");
        cssLink.setAttribute("rel", "stylesheet");
        cssLink.setAttribute("href", cssUrl);
        cssLink.id = "sitecues-js-custom-theme";
        document.querySelector("head").appendChild(cssLink);
      }
      function init() {
        if (!isInitialized) {
          isInitialized = true;
          var siteId = site.getSiteId();
          if (SITES_WITH_CUSTOM_THEMES.hasOwnProperty(siteId)) {
            insertSheet(siteId);
          }
        }
      }
      return {
        init: init
      };
    }(run_conf_site, run_conf_urls);
    theme_theme = function($, Promise, pref, styleService, platform, colorChoices, colorUtil, customTheme, events, nativeGlobal, inlineStyle) {
      var cachedStyleInfo, // TODO remove once no longer necessary -- should be soon
      shouldRepaintToEnsureFullCoverage, isPanelExpanded, isRepaintNeeded, isInitialized, originalBodyBackgroundColor, isOriginalThemeDark, // Are images currently inverted
      finishThemeTimer, requestedThemeName, requestedThemePower, requestedThemeTextHue, currentThemeName, // one of the theme names from color-choices.js
      currentThemePower, // .01 - 1
      currentThemeTextHue, // 0 - 1
      basicThemeSupportReady, // Promise that style info is ready
      imageInversionSupportReady, // Promise that image inversion service is ready
      imageInverter, THEME_STYLESHEET_ID = "sitecues-js-theme", TRANSITION_STYLESHEET_ID = "sitecues-js-theme-transition", REPAINT_MS = 40, isCurrentlyInverted = false, // Is dark theme currently applied
      didInvertImages = false, MAX_USER_SPECIFIED_HUE = 1.03, // If > 1.0 then use white
      TRANSITION_CLASS_FAST = "sc-animate-theme-fast", TRANSITION_CLASS_SLOW = "sc-animate-theme-slow", TRANSITION_MS_FAST = 300, TRANSITION_MS_SLOW = 1400, DEFAULT_INTENSITY = .61, // Must match default slider position in settings-template.hbs #scp-theme-power
      URL_REGEXP = /url\((?:(?:[\'\" ])*([^\"\'\)]+)[\'\" ]*)/i, GRADIENT_REGEXP = /^\s*([\w-]+\s*gradient)\((.*)\).*$/i, BUTTON_REGEXP = /(?:^| |,)(?:(?:input\s*\[\s*type\s*=\s*\"(?:button|color|submit|reset)\"\s*\]\s*)|button)(?:$| |,|:)/;
      // ---- PUBLIC ----
      function finalizeTheme() {
        if (shouldRepaintToEnsureFullCoverage) {
          repaintPage();
        }
        // Only our color changes should use our transitions
        $("html").removeClass(TRANSITION_CLASS_FAST + " " + TRANSITION_CLASS_SLOW);
        if (false) {
          !function(bpAdaptive) {
            bpAdaptive.adaptToSitecuesThemeChange(currentThemeName);
          }(bp_adaptive_bp_adaptive);
        }
      }
      /**
   * Apply the current theme to the current document
   * Uses currentThemeName, currentThemePower and currentThemeTextHue for theme settings
   */
      function onThemeChange() {
        // Requested theme name
        requestedThemeName = pref.get("themeName");
        requestedThemePower = pref.get("themePower") || DEFAULT_INTENSITY;
        requestedThemeTextHue = pref.get("themeTextHue");
        if (!requestedThemeName && !currentThemeName) {
          return;
        }
        // Relevant theme -- has it changed?
        if (needToApplyRequestedTheme()) {
          // New theme settings are different -- apply them!
          applyRequestedTheme();
        }
      }
      function getColorFn(themeName) {
        return colorChoices[themeName];
      }
      function toggleBodyClasses() {
        // Set class sitecues-[themename]-theme on <body> and clear other theme classes
        Object.keys(colorChoices).forEach(function(checkName) {
          $("body").toggleClass("sitecues-" + checkName + "-theme", currentThemeName === checkName);
        });
      }
      function needToApplyImageInversion() {
        var requestedImageInversion = isDarkTheme(requestedThemeName);
        return requestedImageInversion !== didInvertImages;
      }
      // Apply image inversion if still necessary
      function applyImageInversion() {
        var doInvertImages = isDarkTheme(requestedThemeName);
        if (doInvertImages !== didInvertImages) {
          imageInverter.toggle(doInvertImages);
          didInvertImages = doInvertImages;
        }
      }
      function applyColors() {
        var colorMapFn = getColorFn(requestedThemeName);
        if (needToApplyRequestedTheme()) {
          var themeCss = colorMapFn ? getThemeCssText(colorMapFn, requestedThemePower, requestedThemeTextHue) : "", isInversionRequested = isDarkTheme(requestedThemeName), isFastTransition = isCurrentlyInverted === isInversionRequested;
          // Apply new CSS
          themeCss = "@media screen {\n" + themeCss + "\n}";
          // Do not use in print!
          styleService.updateSheet(THEME_STYLESHEET_ID, {
            text: themeCss
          });
          currentThemeName = requestedThemeName;
          currentThemePower = requestedThemePower || DEFAULT_INTENSITY;
          currentThemeTextHue = requestedThemeTextHue;
          isCurrentlyInverted = isInversionRequested;
          // Turn on transitions
          // We want to transition quickly between similar themes, but slowly when performing a drastic change
          // such as going from light to dark or vice-versa
          $("html").addClass(isFastTransition ? TRANSITION_CLASS_FAST : TRANSITION_CLASS_SLOW);
          // Enable site-specific theme changes
          toggleBodyClasses();
          finishThemeTimer = nativeGlobal.setTimeout(finalizeTheme, isFastTransition ? TRANSITION_MS_FAST : TRANSITION_MS_SLOW);
        }
      }
      function needToApplyRequestedTheme() {
        return requestedThemeName !== currentThemeName || requestedThemePower !== currentThemePower || requestedThemeTextHue !== currentThemeTextHue;
      }
      // Apply colors and image inversion as necessary
      function applyRequestedTheme() {
        // Cancel previous theme application
        clearTimeout(finishThemeTimer);
        // Prepare style info
        basicThemeSupportReady = basicThemeSupportReady || initThemeSupport();
        // Apply image inversions if necessary (depending on most recently requested theme)
        if (needToApplyImageInversion()) {
          imageInversionSupportReady = imageInversionSupportReady || basicThemeSupportReady.then(initImageInversions);
          imageInversionSupportReady.then(applyImageInversion);
        }
        // Apply the most recently requested new colors
        var allRequestedThemeSupportReady = imageInversionSupportReady || basicThemeSupportReady;
        allRequestedThemeSupportReady.then(applyColors);
      }
      function initThemeSupport() {
        var bgStyles, fgStyles, bgImageStyles;
        return new Promise(function(resolve) {
          styleService.init(resolve);
        }).then(function() {
          bgStyles = styleService.getAllMatchingStylesCustom(getSignificantBgColor);
        }).then(function() {
          fgStyles = styleService.getAllMatchingStylesCustom(getFgColor);
        }).then(function() {
          bgImageStyles = styleService.getAllMatchingStylesCustom(getSignificantBgImageProperties);
          cachedStyleInfo = bgStyles.concat(fgStyles).concat(bgImageStyles);
        }).then(prepareTransitionCss);
      }
      function initImageInversions() {
        return new Promise(function(resolve) {
          !function(inverter) {
            imageInverter = inverter;
            resolve();
          }(inverter_inverter);
        }).then(function() {
          return imageInverter.init(cachedStyleInfo);
        });
      }
      // Returns true even if not 'dark', but page themed itself dark already
      function isDarkTheme(themeName) {
        var colorMapFn = getColorFn(themeName);
        if (!colorMapFn) {
          return isOriginalThemeDark;
        }
        var originalBg = {
          prop: "background-color",
          parsedVal: originalBodyBackgroundColor
        };
        var themedBg = colorMapFn(originalBg, 1);
        return colorUtil.isDarkColor(themedBg);
      }
      function getThemeTransitionCss(transitionMs, className) {
        var selectorBuilder = "html." + className + ", html." + className + "> body", transitionCss = "{transition: background-color " + transitionMs + "ms;}\n\n";
        // Set the transition for every selector in the page that targets a background color
        cachedStyleInfo.forEach(function(themeStyle) {
          var selectors, type = themeStyle.value.prop;
          if ("background" === type || "background-color" === type) {
            selectors = themeStyle.rule.selectorText.split(",");
            selectors.forEach(function(bgSelector) {
              selectorBuilder += ",." + className + " " + bgSelector;
            });
          }
        });
        return "\n" + selectorBuilder + transitionCss;
      }
      function prepareTransitionCss() {
        // Create or update transition stylesheet if needed
        var css = getThemeTransitionCss(TRANSITION_MS_FAST, TRANSITION_CLASS_FAST) + getThemeTransitionCss(TRANSITION_MS_SLOW, TRANSITION_CLASS_SLOW);
        styleService.updateSheet(TRANSITION_STYLESHEET_ID, {
          text: css
        });
      }
      function createRule(prop, newValue, important) {
        // Check for non-values but allow 0 or false through
        if (null === newValue || "undefined" === typeof newValue || "" === newValue) {
          return "";
        }
        return prop + ": " + newValue + (important ? " !important; " : "; ");
      }
      // Split a,b,c(d, e, f), g as
      // ['a', 'b', 'c(d, e, f)', 'g']
      function splitOutsideParens(str, splitter) {
        var nextSplitIndex, nextItem, length = str.length, // String to eat as it gets processed left ot right
        splitterLength = splitter.length, resultArray = [], lastSplitIndex = 0, nextParenIndex = indexOf("(");
        function indexOf(lookFor, startIndex) {
          var index = str.indexOf(lookFor, startIndex);
          return index < 0 ? length : index;
        }
        while (lastSplitIndex < length) {
          nextSplitIndex = indexOf(splitter, lastSplitIndex);
          if (nextParenIndex < nextSplitIndex) {
            // Found open paren before splitter
            // get comma after next closed paren
            nextParenIndex = indexOf(")", nextParenIndex);
            nextSplitIndex = indexOf(splitter, nextParenIndex);
            nextParenIndex = indexOf("(", nextParenIndex);
          }
          nextItem = str.substring(lastSplitIndex, nextSplitIndex);
          if (nextItem) {
            resultArray.push(nextItem);
          }
          lastSplitIndex = nextSplitIndex + splitterLength;
        }
        return resultArray;
      }
      function getThemedGradientCssText(gradientType, gradientVal, colorMapFn, intensity) {
        var gradientParams = splitOutsideParens(gradientVal, ","), // Split on commas not in parens
        newGradientParams = gradientParams.map(mapParam);
        function mapParam(param) {
          var newRgba, trimmedParam = param.trim(), words = splitOutsideParens(trimmedParam, " "), // Split on spaces not in parens
          rgba = colorUtil.getRgbaIfLegalColor(words[0]);
          if (rgba) {
            newRgba = colorMapFn({
              prop: "background-color",
              parsedVal: rgba
            }, intensity);
            if (newRgba) {
              words[0] = colorUtil.getColorString(newRgba);
            }
          }
          return words.join(" ");
        }
        return gradientType + "(" + newGradientParams.join(",") + ")";
      }
      function createTextShadowRule(size, hue) {
        // Create 3 shadows:
        // - To the right
        // - Below
        // - Below AND right
        var right = size.toFixed(2), below = (size / 2).toFixed(2), // Stretched vertically only half as much -- just looks better that way
        shadowValue = createShadow(right, below) + "," + createShadow(right, 0) + "," + createShadow(0, below);
        function createShadow(x, y) {
          return x + "px " + y + "px " + hue;
        }
        return createRule("text-shadow", shadowValue);
      }
      /**
   * Retrieve the CSS text required to apply the requested theme
   * @param type
   * @param intensity
   * @returns {string}
   */
      function getThemeCssText(colorMapFn, intensity, textHue) {
        var styleSheetText = "";
        // Backgrounds
        cachedStyleInfo.forEach(function(style) {
          var newRgba, newValue, selector = style.rule.selectorText, prop = style.value.prop;
          if ("-sc-gradient" === prop) {
            newRgba = {};
            prop = "background";
            newValue = getThemedGradientCssText(style.value.gradientType, style.value.gradientVal, colorMapFn, intensity);
          } else {
            if ("color" === prop || "background-color" === prop) {
              newRgba = colorMapFn(style.value, intensity, textHue);
              newValue = newRgba && colorUtil.getColorString(newRgba);
            }
          }
          if (newValue) {
            var important = style.value.important && ":link" !== selector && ":visited" !== selector, // Don't let these UA rules override page's <a> rules
            formFixes = "", textShadow = "";
            if (isButtonRule(selector)) {
              // Don't alter buttons -- it will change it from a native button and the appearance will break
              // color, background-color
              formFixes = "border:1px outset ButtonFace;border-radius:4px;";
            }
            if (newRgba.textShadow) {
              // Sometimes we want to darken, so we create a tiny text shadow of the same color as the text
              textShadow = createTextShadowRule(newRgba.textShadow, newValue);
            }
            styleSheetText += selector + "{" + createRule(prop, newValue, important) + formFixes + textShadow + "}\n";
          }
        });
        return styleSheetText;
      }
      /**
   * Deal with Chrome bugs where scrolled-off content doesn't get new background color
   * Necessary on at least youtube.com and https://www.arlington.k12.ma.us/stratton/
   */
      function repaintPage() {
        if (isPanelExpanded) {
          isRepaintNeeded = true;
        } else {
          inlineStyle.override(document.documentElement, [ "transform", "translateY(0.01px)" ]);
          nativeGlobal.setTimeout(function() {
            inlineStyle.restore(document.documentElement, "transform");
          }, REPAINT_MS);
        }
      }
      /**
   * The CSS background property is shorthand for applying many CSS background- related properties at once.
   * This function extracts the color fro the background property.
   * @param bgShorthand The background property value
   * @returns {string}
   */
      function extractColorFromBgShorthand(bgShorthand) {
        var lastIndexRgb = bgShorthand.lastIndexOf("rgb(");
        if (lastIndexRgb < 0) {
          bgShorthand.lastIndexOf("rgba(");
        }
        if (lastIndexRgb < 0) {
          // Color is not rgb() or rgba() -- may be a color name such as 'white'.
          // In most browsers, color name will be last.
          // In Firefox, the color comes first
          var possibleColors = bgShorthand.split(" ");
          return possibleColors[false ? 0 : possibleColors.length - 1];
        }
        // Format = rgb(x,x,x) or rgba(x,x,x,x)
        return bgShorthand.substr(lastIndexRgb).split(")")[0] + ")";
      }
      function getSignificantBgImageProperties(cssStyleDecl) {
        var imageUrl, gradient, bgImagePropVal = cssStyleDecl["background-image"], cssText = cssStyleDecl.cssText;
        if (cssText.indexOf("background") < 0) {
          return;
        }
        imageUrl = getCssUrl(bgImagePropVal);
        gradient = !imageUrl && getBackgroundGradient(bgImagePropVal);
        if (gradient) {
          return {
            prop: "-sc-gradient",
            important: "important" === cssStyleDecl.getPropertyPriority("background-image"),
            gradientType: gradient && gradient[1],
            gradientVal: gradient && gradient[2]
          };
        }
        function getBackgroundGradient(propVal) {
          if (propVal.indexOf("gradient") >= 0) {
            return propVal.match(GRADIENT_REGEXP);
          }
        }
        if (imageUrl) {
          return {
            prop: "background-image",
            important: "important" === cssStyleDecl.getPropertyPriority("background-image"),
            imageUrl: imageUrl,
            backgroundColor: cssStyleDecl.backgroundColor
          };
        }
      }
      function getCssUrl(propVal) {
        if (propVal.indexOf("url(") >= 0) {
          var match = propVal.match(URL_REGEXP);
          return match && match[1];
        }
      }
      function isButtonRule(selector) {
        if (selector && (selector.lastIndexOf("button") >= 0 || selector.lastIndexOf("input") >= 0)) {
          return selector.match(BUTTON_REGEXP);
        }
      }
      /**
   * Retrieve information about background colors if we care about them
   * We don't care about transparent colors.
   * @param cssStyleDecl
   * @returns {{prop: string, parsedVal: object }}
   */
      function getSignificantBgColor(cssStyleDecl, selector) {
        var bgStyle = cssStyleDecl.background, colorString = extractColorFromBgShorthand(bgStyle) || cssStyleDecl.backgroundColor, rgba = colorString && colorUtil.getRgba(colorString);
        if (rgba) {
          return {
            prop: "background-color",
            selector: selector,
            parsedVal: rgba,
            important: "important" === cssStyleDecl.getPropertyPriority("background-color")
          };
        }
      }
      /**
   * Retrieve rgba information about foreground colors
   * @param cssStyleDecl
   * @returns {{prop: string, parsedVal: *}}
   */
      function getFgColor(cssStyleDecl, selector) {
        var fgStyle = cssStyleDecl.color;
        if (fgStyle && "inherit" !== fgStyle) {
          return {
            prop: "color",
            selector: selector,
            parsedVal: colorUtil.getRgba(fgStyle),
            important: "important" === cssStyleDecl.getPropertyPriority("color"),
            contrastEnhancementDirection: function() {
              var fgLuminosity = colorUtil.getLuminanceFromColorName(fgStyle);
              if (fgLuminosity < .05) {
                return -1;
              }
              if (fgLuminosity > .95) {
                return 1;
              }
              // If we're directly on a dark background, we know the text must get lighter
              var bgRgba = colorUtil.getRgba(cssStyleDecl.backgroundColor);
              if (bgRgba && bgRgba.a > .2) {
                return colorUtil.getLuminanceFromColorName(bgRgba) < .5 ? 1 : -1;
              }
            }()
          };
        }
      }
      // Theme name must exist in colorChoices
      // Except for null, which means no theme
      function getSanitizedThemeName(name) {
        return name in colorChoices ? name : null;
      }
      // Theme power must be 0 - 1
      function getSanitizedThemePower(power) {
        if (power >= 0) {
          return Math.min(power, 1);
        }
        return 1;
      }
      // If user specifies > 1 use white
      function getSanitizedHue(hue) {
        if (!hue || hue < 0 || hue > MAX_USER_SPECIFIED_HUE) {
          return MAX_USER_SPECIFIED_HUE;
        }
        return hue;
      }
      function init(isPanelOpen) {
        if (isPanelOpen) {
          isPanelExpanded = true;
        }
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        originalBodyBackgroundColor = colorUtil.getDocumentBackgroundColor();
        // TODO remove when no longer necessary
        shouldRepaintToEnsureFullCoverage = true && platform.browser.version < 48;
        pref.defineHandler("themeName", getSanitizedThemeName);
        pref.defineHandler("themePower", getSanitizedThemePower);
        pref.defineHandler("themeTextHue", getSanitizedHue);
        pref.bindListener("themeName", onThemeChange);
        pref.bindListener("themePower", onThemeChange);
        pref.bindListener("themeTextHue", onThemeChange);
        if ("undefined" === typeof pref.get("themePower")) {
          pref.set("themePower", DEFAULT_INTENSITY);
        }
        if ("undefined" === typeof pref.get("themeTextHue")) {
          pref.set("themeTextHue", MAX_USER_SPECIFIED_HUE);
        }
        customTheme.init();
        function onPanelExpand() {
          isPanelExpanded = true;
        }
        function onPanelShrink() {
          isPanelExpanded = false;
          if (isRepaintNeeded) {
            repaintPage();
            isRepaintNeeded = false;
          }
        }
        events.on("bp/did-expand", onPanelExpand);
        events.on("bp/did-shrink", onPanelShrink);
      }
      return {
        init: init
      };
    }($, Promise, run_conf_preferences, page_style_service_style_service, run_platform, theme_color_choices, page_util_color, theme_custom_site_theme, run_events, mini_core_native_global, run_inline_style_inline_style);
    audio_constant = function() {
      // TODO add more trigger types, e.g. shift+arrow, shift+space
      var TRIGGER_TYPES = {
        LENS: "space",
        HIGHLIGHT: "shift",
        SELECTION: "selection"
      }, speechStrategy = {
        AUTO: "auto",
        // Currently same as PREFER_NETWORK
        LOCAL: "local",
        NETWORK: "network",
        PREFER_LOCAL: "preferLocal",
        PREFER_NETWORK: "preferNetwork"
      };
      return {
        TRIGGER_TYPES: TRIGGER_TYPES,
        REROUTE_NETWORK_SPEECH_KEY: "-sc-reroute-network-tts-",
        AVAILABLE_CUES: {
          ar: 1,
          de: 1,
          en: 1,
          es: 1,
          fr: 1,
          pl: 1,
          sv: 1
        },
        speechStrategy: speechStrategy,
        // jshint -W117
        autoStrategy: "local"
      };
    }();
    audio_speech_builder = function($, urls) {
      var textBuffer = "", TEXT_NODE = 3, ELEMENT_NODE = 1;
      /**
   * Get all the text to be spoken for a given selector, taking into account line breaks, form values and alternative text
   * @access public
   * @param selector Element or jQuery object with nodes to get speakable text for
   * @returns {*}
   */
      function getText(selector) {
        textBuffer = "";
        $(selector).each(function() {
          if (textBuffer) {
            appendBlockSeparator();
          }
          appendAccessibleTextFromSubtree(this);
        });
        // Replace multiple whitespace chars with a single space so that GET request is not too large
        textBuffer = textBuffer.replace(/\s\s+/g, " ");
        // Remove any space at beginning or end of string
        return textBuffer.trim();
      }
      function appendText(text) {
        textBuffer += text;
      }
      function findElement(id, isMap) {
        return document.querySelector(isMap ? 'map[name="' + id.replace("#", "") + '"]' : "#" + id);
      }
      function appendFromIdListAttribute($node, attrName) {
        var ids, id, idCount, target, idList = $node.attr(attrName), isMap = "usemap" === attrName;
        if (idList) {
          ids = idList.split(" ");
          for (idCount = 0; idCount < ids.length; idCount++) {
            id = ids[idCount];
            target = findElement(id, isMap);
            if (target) {
              appendText(" ");
              appendAccessibleTextFromSubtree(target, true);
              appendText(" ");
            }
          }
        }
      }
      /**
   * Add " . " between blocks if the previous block did not end the sentence, to avoid combining 2 sentences into 1.
   * Or, if the sentence already ended, add " " between blocks to ensure words are not jammed together into one word.
   * This string is magical, at least in Ivona.
   * We tried '. ' but it caused abbreviations to be expanded (e.g. "No." is spoken as "Number").
   * Also tried "; " and "! " but these caused the block of text to be read with a slightly rising pitch at the end.
   * The ' . ' seems to do a good job of ending the sentence without causing abbreviation expansion or pitch changes.
   * (If this ends up causing 'dot' to be spoken we can try ';. ' which also seemed to work but was weirder).
   * @param {string} original text
   */
      function appendBlockSeparator() {
        if (!textBuffer) {
          return;
        }
        var lastChar = textBuffer.slice(-1), IS_LETTER_REGEX = /[\w\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]/;
        // Shortest way to test if char is a letter
        if (lastChar.match(IS_LETTER_REGEX)) {
          appendText(" . ");
        } else {
          appendText(" ");
        }
      }
      /**
   * Append text and additional spaces, if necessary, to separate it from other text
   * @param text  The new text that will be appended
   */
      function appendWithWordSeparation(text) {
        var lastChar = textBuffer.slice(-1), IS_WHITESPACE_REGEX = /[ \r\n\t]/;
        if (lastChar && text && !lastChar.match(IS_WHITESPACE_REGEX)) {
          appendText(" ");
        }
        appendText(text.trim() + " ");
      }
      function isSelectedOption(index, option) {
        return option.selected;
      }
      function hasMatchingTag(tags, element) {
        return tags.hasOwnProperty(element.localName);
      }
      /**
   * Checks if the element has media contents which can be rendered.
   * TODO Use element-classifier.isVisualMedia()
   */
      var VISUAL_MEDIA_ELEMENTS = {
        img: 1,
        picture: 1,
        canvas: 1,
        video: 1,
        embed: 1,
        object: 1,
        iframe: 1,
        frame: 1,
        audio: 1
      };
      function isVisualMedia(element) {
        return hasMatchingTag(VISUAL_MEDIA_ELEMENTS, element);
      }
      function getImageText(node) {
        return node.getAttribute("alt") || node.getAttribute("title") || "";
      }
      function isImage($node) {
        return isVisualMedia($node[0]) || $node.is('input[type="image"]');
      }
      function appendNonLabelText($node, styles) {
        // CSS display: none -- hides entire subtree
        if ("none" === styles.display) {
          return;
        }
        // CSS visibility -- child elements might still be visible, need to check each one
        var doWalkChildren, isHidden = "visible" !== styles.visibility;
        if (isHidden) {
          $node.children().each(function() {
            appendAccessibleTextFromSubtree(this);
          });
          return;
        }
        doWalkChildren = true;
        if ($node.attr("aria-labelledby")) {
          // Check for label pointed to but only if not already in the middle of doing that
          appendFromIdListAttribute($node, "aria-labelledby");
          doWalkChildren = false;
        } else {
          if ($node.is("img")) {
            // If it has @usemap, add any alternative text from within the map
            appendFromIdListAttribute($node, "usemap");
          }
        }
        // Append description
        appendFromIdListAttribute($node, "aria-describedby");
        return doWalkChildren;
      }
      function getInputLabelAttributeText(node) {
        return node.getAttribute("placeholder") || node.getAttribute("title") || "";
      }
      function appendTextEquivAndValue(node, $node, doWalkChildren) {
        // Process 'text equivalents' which are attributes that contain additional descriptive text
        // Note: unlike most text equivalent attributes, aria-label is supported on any element. It is different from
        // aria-labelledby in that it directly contains the necessary text rather than point to an element by id.
        var value, ariaLabel = node.getAttribute("aria-label"), textEquiv = ariaLabel;
        // alt or title on any image or visual media
        if (isImage($node)) {
          textEquiv = textEquiv || getImageText(node);
        } else {
          if ($node.is("select")) {
            textEquiv = node.getAttribute("title") || "";
            value = $node.children().filter(isSelectedOption).text();
            doWalkChildren = false;
          } else {
            if ($node.is("input[type=radio],input[type=checkbox],button")) {
              // value, and title on these form controls
              textEquiv = textEquiv || node.getAttribute("title") || "";
            } else {
              if ($node.is('input:not([type="password"]),textarea')) {
                // value, placeholder and title on these form controls
                textEquiv = textEquiv || getInputLabelAttributeText(node);
                value = node.value;
              }
            }
          }
        }
        if (ariaLabel) {
          // ARIA markup defined an accessible name, which overrides other labels.
          // No need to keep adding to the accessible name via descendants or other attributes
          textEquiv = ariaLabel;
          doWalkChildren = false;
        }
        if (null !== textEquiv) {
          appendWithWordSeparation(textEquiv);
        }
        if (value) {
          appendWithWordSeparation(value);
        }
        return doWalkChildren;
      }
      // Add all the accessible text from the pointed-to subtree of elements
      // isLabel prevents infinite recursion when getting label from elsewhere in document, potentially overlapping
      function appendAccessibleTextFromSubtree(node, isLabel) {
        var styles, hasNewline, hasExtraSpace, $node = $(node), doWalkChildren = true;
        node = $node[0];
        if (node.nodeType === TEXT_NODE) {
          // Text node: we append the text contents
          appendText(node.nodeValue);
          return;
        }
        if (node.nodeType !== ELEMENT_NODE) {
          return;
        }
        // Element -- check for special requirements based on element markup
        styles = window.getComputedStyle(node);
        // Non-label processing:
        // 1) Visibility checks -- we don't do this for labels because even invisible labels should be spoken, it's a
        //    common technique to hide labels but have useful text for screen readers
        // 2) ARIA labels and descriptions: don't use if already inside a label, in order to avoid infinite recursion
        //    since labels could ultimately point in a circle.
        if (!isLabel && !appendNonLabelText($node, styles)) {
          return;
        }
        // Add characters to break up paragraphs (before block)
        hasNewline = "inline" !== styles.display;
        if (hasNewline) {
          textBuffer = textBuffer.trim();
          appendBlockSeparator();
        } else {
          hasExtraSpace = parseFloat(styles.paddingRight) || parseFloat(styles.marginRight);
        }
        doWalkChildren = appendTextEquivAndValue(node, $node, doWalkChildren);
        if ("iframe" === node.localName && node.src && urls.isCrossOrigin(node.src)) {
          // Don't try to access the nested document of cross origin iframes
          return;
        }
        if (doWalkChildren) {
          // Recursively add text from children (both elements and text nodes)
          $node.contents().each(function() {
            appendAccessibleTextFromSubtree(this, isLabel);
          });
        }
        if (hasNewline) {
          textBuffer = textBuffer.trim();
          appendBlockSeparator();
        } else {
          if (hasExtraSpace) {
            appendText(" ");
          }
        }
      }
      return {
        getText: getText
      };
    }($, run_conf_urls);
    audio_text_select = function($, events, constant, nativeGlobal) {
      var wasOn = false;
      // Speaking on a delay after mouseup avoids speaking the same thing twice
      function speakSelectedTextOnDelay(event) {
        if (!isInPanel(event.target)) {
          nativeGlobal.setTimeout(speakSelectedText, 0);
        }
      }
      function isInPanel(element) {
        return $(element).closest("#sitecues-badge,#scp-bp-container").length > 0;
      }
      function speakSelectedText() {
        // TODO get the selected nodes and concat all the text ourselves, so that we speak markup correctly, switch locales, etc.
        // TODO this would also allow us to speak whole words (SC-3192)
        var selection = window.getSelection(), selectedText = selection.toString(), focusNode = selection.focusNode;
        !function(audio) {
          // No need to init audio, because we're a dependency of it -- it inits us
          // Anything currently being spoken will be interrupted and the new text will be spoken instead.
          // This means that if an empty string is sent, speech will simply shut up.
          // As a result, clicking somewhere new in the page will quiet the current speech.
          audio.speakText(selectedText || "", focusNode, constant.TRIGGER_TYPES.SELECTION);
        }(audio_audio);
      }
      function refresh(isOn) {
        if (wasOn === isOn) {
          return;
        }
        wasOn = isOn;
        if (isOn) {
          document.addEventListener("mouseup", speakSelectedTextOnDelay);
        } else {
          document.removeEventListener("mouseup", speakSelectedTextOnDelay);
        }
      }
      function init() {
        refresh(true);
        // We only get init'd if TTS is turned on, so assume it's on
        events.on("speech/did-change", refresh);
      }
      return {
        init: init
      };
    }($, run_events, audio_constant, mini_core_native_global);
    audio_local_player = function(Promise, nativeGlobal) {
      var speechSynthesis = window.speechSynthesis, SpeechSynthesisUtterance = window.SpeechSynthesisUtterance;
      function getVoices() {
        var errMessage = {
          NO_VOICES: "Sitecues cannot find voices to speak with.",
          TIMEOUT: "Timed out getting voices. The system may not have any."
        };
        // Promise handler for when loading voices is asynchronous.
        function waitForVoices(resolve, reject) {
          // Handle timeouts so we don't wait forever in any case where
          // the voiceschanged event never fires.
          function onTimeout() {
            reject(new Error(errMessage.TIMEOUT));
          }
          // Don't wait forever for a voice.
          var voicesTimeout = nativeGlobal.setTimeout(onTimeout, 3e3);
          // At least one voice has loaded asynchronously. We don't know if/when
          // any more will come in, so it is best to consider the job done here.
          function onVoicesChanged(event) {
            clearTimeout(voicesTimeout);
            // Give the available voices as the result.
            resolve(speechSynthesis.getVoices());
            // Remove thyself.
            event.currentTarget.removeEventListener(event.type, onVoicesChanged, true);
          }
          speechSynthesis.addEventListener("voiceschanged", onVoicesChanged, true);
        }
        // Tickle the browser with a feather to get it to actually load voices.
        // In some environments this happens synchronously and we can use the
        // result right away. In others, it returns an empty array and we will
        // take care of that during the voiceschanged event.
        var voices = speechSynthesis.getVoices();
        // If the browser has voices available right now, return those.
        // Safari gets voices synchronously, so will be true there.
        if (voices.length > 0) {
          return Promise.resolve(voices);
        } else {
          if ("function" === typeof speechSynthesis.addEventListener) {
            return new Promise(waitForVoices);
          }
        }
        // In theory, a platform could support the synthesis API but not have any
        // voices available. Or all the voices could suddenly be uninstalled.
        // We have not encountered that, but we try to take care of it here.
        return Promise.reject(new Error(errMessage.NO_VOICES));
      }
      // Based on a given set of voices and locale restrictions, get sitecues'
      // favorite voice. We want to sound the best.
      function getBestVoice(option) {
        var voices = option.voices, locale = option.locale, lang = locale.split("-")[0];
        var acceptableVoices = voices.filter(function(voice) {
          var voiceLocale = voice.lang;
          // Allow universal speech engines, which exist on Windows. These can
          // speak just about any language.
          if (!voiceLocale) {
            return true;
          }
          return voiceLocale === lang || voiceLocale.startsWith(lang + "-");
        }).filter(function(voice) {
          return false || voice.localService;
        });
        if (acceptableVoices.length > 0) {
          return acceptableVoices.sort(compareVoices)[0];
        }
        throw new Error("No local voice available for " + locale);
        function compareVoices(a, b) {
          var aLocale = a.lang, bLocale = b.lang;
          // Prefer voices with the perfect accent (or lack thereof).
          if (aLocale === locale && bLocale !== locale) {
            return -1;
          }
          if (bLocale === locale && aLocale !== locale) {
            return 1;
          }
          // Prefer to respect the user's default voices.
          if (a.default && !b.default) {
            return -1;
          }
          if (b.default && !a.default) {
            return 1;
          }
          // Prefer voices without an accent, to avoid mapping one accent to
          // another if at all possible.
          if (aLocale === lang && bLocale !== lang) {
            return -1;
          }
          if (bLocale === lang && aLocale !== lang) {
            return 1;
          }
        }
      }
      // Stop speech. This method is idempotent. It does not matter if we are
      // currently playing or not.
      function stop() {
        speechSynthesis.cancel();
      }
      // Turn text into speech.
      function speak(option) {
        var // TODO: Replace this poor excuse for a speech dictionary.
        text = option.text.replace(/sitecues/gi, "sightcues").trim(), locale = option.locale;
        var voice = option.voice, prom = Promise.resolve();
        if (!text) {
          return prom;
        }
        if (!voice) {
          prom = getVoices().then(function(voices) {
            return getBestVoice({
              voices: voices,
              locale: locale
            });
          }).then(function(bestVoice) {
            voice = bestVoice;
          });
        }
        // By default, the Web Speech API queues up synthesis requests.
        // But this is typically not what is desired by sitecues.
        if (!option.polite) {
          // Immediately discontinue any currently playing speech.
          stop();
        }
        // When and if we have a voice to use, finish setting up
        // and then play speech.
        prom = prom.then(function() {
          return new Promise(function(resolve, reject) {
            var speech = new SpeechSynthesisUtterance(text);
            speech.voice = voice;
            // Note: Some voices do not support altering these settings and will break silently!
            speech.lang = locale;
            // speech.voiceURI = 'native';
            // speech.volume = 1;  // float from 0 to 1, default is 1
            // speech.rate   = 1;  // float from 0 to 10, default is 1
            // speech.pitch  = 1;  // float from 0 to 2, default is 1
            // Event listeners...
            var onStart = option.onStart;
            if (onStart) {
              speech.addEventListener("start", onStart);
            }
            function removeListeners() {
              if (onStart) {
                speech.removeEventListener("start", onStart);
              }
              speech.removeEventListener("end", onSpeechEnd);
              speech.removeEventListener("error", onSpeechError);
            }
            function onSpeechEnd() {
              if (true) {
                console.log("Finished in " + event.elapsedTime + " seconds.");
              }
              removeListeners();
              resolve();
            }
            function onSpeechError(event) {
              removeListeners();
              reject(event.error);
            }
            speech.addEventListener("end", onSpeechEnd);
            speech.addEventListener("error", onSpeechError);
            // Examples of other things we could do:
            // speech.addEventListener('resume', function onSpeechResume(event) {
            //     console.log('Speech has resumed from a paused state.');
            // });
            // speech.addEventListener('boundary', function onSpeechBoundary(event) {
            //     console.log('Encountered a word or sentence boundary.');
            // });
            // speech.addEventListener('mark', function onSpeechMark(event) {
            //     console.log('Encountered an SSML mark tag.');
            // });
            speechSynthesis.speak(speech);
          });
        });
        return prom;
      }
      // "Polite" mode means wait your turn and let others finish speaking.
      // It adds speech to the queue and does not play it immediately.
      function speakPolitely(option) {
        option = Object.create(option);
        option.polite = true;
        speak(option);
      }
      // NOTE: This method will be fooled by another app besides sitecues speaking.
      //       Prefer to keep track of state based on the promise from speak().
      function isBusy() {
        return speechSynthesis.pending || speechSynthesis.speaking;
      }
      return {
        stop: stop,
        speak: speak,
        speakPolitely: speakPolitely,
        isBusy: isBusy
      };
    }(Promise, mini_core_native_global);
    audio_network_player = function($, urls, site, Promise) {
      var audioElementsToPlay = [], ERR_NO_NETWORK_TTS = "Sitecues network speech is not available on this website.";
      /**
   * Retrieve and play audio from a URL.
   * @param option, settings such as source of audio to play
   */
      function play(option) {
        var url = option.url, onStart = option.onStart, audioElement = new Audio(), isSpeech = option.isSpeech;
        audioElementsToPlay.push(audioElement);
        if (!isSpeech) {
          // No need to check network speech config for playing earcons
          return new Promise(beginRequest);
        }
        return new Promise(function(resolve, reject) {
          getNetworkSpeechConfig(function(speechConfig, error) {
            if (speechConfig.ttsAvailable) {
              beginRequest(resolve, reject);
            } else {
              // Fetched site config disallowed network speech
              // This is a network setting as opposed to a client strategy
              releaseAudioElement(audioElement);
              reject(new Error(error || ERR_NO_NETWORK_TTS));
            }
          });
        });
        function beginRequest(resolve, reject) {
          if (onStart) {
            $(audioElement).one("playing", onStart);
          }
          // TODO: Can we remove this? Test across browsers.
          audioElement.src = "";
          // Clean up
          $(audioElement).one("canplay", onCanPlay);
          $(audioElement).one("error", function(event) {
            onEnded(event);
            reject(event);
          });
          $(audioElement).one("ended", function(event) {
            onEnded(event);
            resolve();
          });
          $(audioElement).one("pause", function(event) {
            onEnded(event);
            resolve();
          });
          audioElement.src = url;
        }
        function onCanPlay(event) {
          var audioElement = event.target;
          if (audioElementsToPlay.indexOf(audioElement) >= 0) {
            // Still in list of <audio> elements to play -- has not been stopped
            audioElement.play();
          }
        }
        function releaseAudioElement() {
          var index = audioElementsToPlay.indexOf(audioElement);
          if (index >= 0) {
            audioElementsToPlay.splice(index, 1);
          }
        }
        function onEnded(event) {
          var audioElement = event.target;
          removeListeners(audioElement);
          releaseAudioElement(audioElement);
        }
      }
      // Busy when 1) pending network request, or 2) currently playing audio
      function isBusy() {
        return audioElementsToPlay.length > 0;
      }
      function removeListeners(audioElement) {
        var $audioElement = $(audioElement);
        $audioElement.off("canplay");
        // Don't fire notification to play if we haven't played yet
        $audioElement.off("error");
        $audioElement.off("ended");
        $audioElement.off("pause");
      }
      /**
   * Stop any currently playing audio and abort the request
   */
      function stop() {
        audioElementsToPlay.forEach(function(audioElement) {
          audioElement.pause();
        });
        audioElementsToPlay.length = 0;
      }
      function getNetworkSpeechConfig(callbackFn) {
        if (getNetworkSpeechConfig.cached) {
          // Already retrieved
          callbackFn(getNetworkSpeechConfig.cached);
          return;
        }
        if (getNetworkSpeechConfig.isRetrieving) {
          // Currently retrieving -- this is a weird case -- as if network speech was requested again before the config was fetched
          callbackFn({});
          return;
        }
        getNetworkSpeechConfig.isRetrieving = true;
        fetchNetworkSpeechConfig(function(speechConfig, error) {
          getNetworkSpeechConfig.isRetrieving = false;
          getNetworkSpeechConfig.cached = speechConfig;
          callbackFn(speechConfig, error);
        });
      }
      function fetchNetworkSpeechConfig(callbackFn) {
        !function(xhr) {
          xhr.getJSON({
            // The 'provided.siteId' parameter must exist, or else core would have aborted the loading of modules.
            url: urls.getApiUrl("2/site/" + site.getSiteId() + "/config"),
            success: function(data) {
              var currentSetting, origSettings = data.settings, i = 0;
              // Map the incoming format
              // From:
              //   [ { key: foo, value: bar}, { key: foo2, value: bar2} ... ] to
              // To:
              //   { key: bar, key2: bar2 }
              // Copy the fetched key/value pairs into the speechConfig
              var speechConfig = {};
              for (;i < origSettings.length; i++) {
                currentSetting = origSettings[i];
                speechConfig[currentSetting.key] = currentSetting.value;
              }
              callbackFn(speechConfig);
            },
            error: function(error) {
              callbackFn({}, error);
            }
          });
        }(run_util_xhr);
      }
      return {
        play: play,
        stop: stop,
        isBusy: isBusy
      };
    }($, run_conf_urls, run_conf_site, Promise);
    audio_audio = function(constant, pref, site, $, xhr, builder, locale, metric, urls, textSelect, events, localPlayer, networkPlayer) {
      var lastPlayer, isInitialized, ttsOn = false, AUDIO_BUSY_EVENT = "audio/did-toggle", speechStrategy = constant.speechStrategy;
      function onLensOpened(lensContent, fromHighlight) {
        if (ttsOn) {
          speakContentImpl(fromHighlight.picked, constant.TRIGGER_TYPES.LENS);
        }
      }
      function isBusy() {
        return lastPlayer && lastPlayer.isBusy();
      }
      function speakContent(content, doAvoidInterruptions) {
        if (doAvoidInterruptions && isBusy()) {
          return;
        }
        if (!content) {
          return;
        }
        speakContentImpl(content, constant.TRIGGER_TYPES.HIGHLIGHT);
      }
      function speakContentImpl($content, triggerType) {
        stopAudio();
        var text = builder.getText($content);
        if (text) {
          speakText(text, $content[0], triggerType);
        }
      }
      // text and triggerType are optional
      // @rootNode is root node of the text to be spoken, if available -- it will be used to get the locale
      function speakText(text, rootNode, triggerType) {
        stopAudio();
        // Stop any currently playing audio and halt keydown listener until we're playing again
        if (!text.trim()) {
          return;
        }
        var startRequestTime = Date.now(), textLocale = getAudioLocale(rootNode);
        addStopAudioHandlers();
        function onSpeechPlaying(isLocal) {
          var timeElapsed = Date.now() - startRequestTime;
          new metric.TtsRequest({
            requestTime: timeElapsed,
            audioFormat: isLocal ? null : getMediaTypeForNetworkAudio(),
            charCount: text.length,
            trigger: triggerType,
            isLocalTTS: isLocal
          }).send();
        }
        function speakLocally(onUnavailable) {
          var onUnavailableFn = onUnavailable || fireNotBusyEvent;
          if (isLocalSpeechAllowed()) {
            lastPlayer = localPlayer;
            fireBusyEvent();
            return localPlayer.speak({
              text: text,
              locale: textLocale,
              onStart: function() {
                onSpeechPlaying(true);
              }
            }).then(fireNotBusyEvent).catch(function() {
              onUnavailableFn();
            });
          } else {
            onUnavailableFn();
          }
        }
        function speakViaNetwork(onUnavailable) {
          var onUnavailableFn = onUnavailable || fireNotBusyEvent;
          if (isNetworkSpeechAllowed(textLocale)) {
            lastPlayer = networkPlayer;
            fireBusyEvent();
            var ttsUrl = getTTSUrl(text, textLocale);
            networkPlayer.play({
              url: ttsUrl,
              onStart: function() {
                onSpeechPlaying(false);
              }
            }).then(fireNotBusyEvent).catch(function() {
              rerouteNetworkSpeechLang(textLocale);
              onUnavailableFn();
            });
          } else {
            onUnavailableFn();
          }
        }
        var speakViaNetworkFn = true ? fireNotBusyEvent : speakViaNetwork;
        // Helps the minifier
        if (isLocalSpeechPreferred()) {
          speakLocally(speakViaNetworkFn);
        } else {
          speakViaNetworkFn(speakLocally);
        }
      }
      function addStopAudioHandlers() {
        // Stop speech on any key down.
        // Wait a moment, in case it was a keystroke that just got us here,
        // for example down arrow to read next Lens or a hotkey to toggle speech
        removeBlurHandler();
        $(window).one("blur", stopAudio);
      }
      // Remove handler that stops speech on any key down.
      function removeBlurHandler() {
        $(window).off("blur", stopAudio);
      }
      /*
   * Stops the player that is attached to a highlight box.
   * This is safe to call if the player has not been initialized
   * or is not playing.
   */
      function stopAudio() {
        if (isBusy()) {
          lastPlayer.stop();
          removeBlurHandler();
        }
      }
      function fireBusyEvent() {
        if (isBusy()) {
          // Already fired
          return;
        }
        events.emit(AUDIO_BUSY_EVENT, true);
      }
      function fireNotBusyEvent() {
        if (isBusy()) {
          // Still has other audio to play -- one of the players is still busy
          return;
        }
        events.emit(AUDIO_BUSY_EVENT, false);
      }
      // Get language that applies to node (optional param), otherwise the document body
      // If no locale found, falls back on document and then browser default language
      // Returns a full country-affected language, like en-CA when the browser's language matches the site's language prefix.
      // For example, if an fr-CA browser visits an fr-FR website, then fr-CA is returned instead of the page code,
      // because that is the preferred accent for French.
      // However, if the fr-CA browser visits an en-US or en-UK page, the page's code is returned because the
      // user's preferred English accent in unknown
      function getAudioLocale(optionalStartNode) {
        function toPreferredRegion(contentLocale) {
          return locale.swapToPreferredRegion(contentLocale);
        }
        // Get this first, because Google translate overwrites all text in the document, but not lang attributes
        var translationLocale = locale.getTranslationLocale();
        if (translationLocale) {
          return toPreferredRegion(translationLocale);
        }
        var node = optionalStartNode || document.body;
        if (node.nodeType !== node.ELEMENT_NODE) {
          // May have started on text node
          node = node.parentElement;
        }
        while (node) {
          var nodeLocale = node.getAttribute("lang") || node.getAttribute("xml:lang");
          if (nodeLocale && locale.isValidLocale(nodeLocale)) {
            return toPreferredRegion(nodeLocale);
          }
          node = node.parentElement;
        }
        return toPreferredRegion(locale.getPageLocale());
      }
      function getCueText(cueName, cueTextLocale, callback) {
        var cache = getCueText.cache;
        if (!cache) {
          getCueText.cache = cache = {};
        }
        if ("string" === typeof cache[cueName]) {
          callback(cache[cueName]);
          return;
        }
        var cueFileName = urls.resolveResourceUrl("cue/" + cueTextLocale + "/" + cueTextLocale + ".json");
        // TODO what about Chrome extension?
        xhr.getJSON({
          url: cueFileName,
          success: function(data) {
            cache[cueName] = data[cueName] || "";
            callback(cache[cueName]);
          }
        });
      }
      function toCueTextLocale(cueAudioLocale) {
        var locale = cueAudioLocale.toLowerCase(), lang = locale.split("-")[0];
        function useIfAvailable(tryLocale) {
          return constant.AVAILABLE_CUES[tryLocale] && tryLocale;
        }
        return useIfAvailable(locale) || useIfAvailable(lang);
      }
      // Puts in delimiters on both sides of the parameter -- ? before and & after
      // locale is a required parameter
      function getLocaleParameter(locale) {
        return "?l=" + locale + "&";
      }
      function getCueUrl(name, locale) {
        return urls.resolveResourceUrl("cue/" + locale + "/" + name + "." + getMediaTypeForNetworkAudio());
      }
      /**
   * Get URL for speaking text
   * @param text  Text to be spoken
   * @param locale  required locale parameter
   * @returns {string} url
   */
      function getTTSUrl(text, locale) {
        var restOfUrl = "tts/site/" + site.getSiteId() + "/tts." + getMediaTypeForNetworkAudio() + getLocaleParameter(locale) + "t=" + encodeURIComponent(text);
        return urls.getApiUrl(restOfUrl);
      }
      /**
   * Turn speech on or off
   * @param isOn Whether to turn speech on or off
   */
      function setSpeechState(isOn, doSuppressAudioCue) {
        if (ttsOn !== isOn) {
          ttsOn = isOn;
          pref.set("ttsOn", ttsOn);
          events.emit("speech/did-change", ttsOn);
          if (!doSuppressAudioCue) {
            !function(audioCues) {
              audioCues.playSpeechCue(ttsOn);
            }(audio_cues_audio_cues);
          }
        }
      }
      function toggleSpeech() {
        setSpeechState(!ttsOn);
      }
      /*
   * Uses a provisional player to play back audio by cue name, used for audio cues.
   */
      function speakCueByName(name) {
        stopAudio();
        // Stop any currently playing audio
        var cueAudioLocale = getAudioLocale();
        // Use document language for cue voice, e.g. en-US or en
        addStopAudioHandlers();
        function speakLocally(onUnavailable) {
          var onUnavailableFn = onUnavailable || fireNotBusyEvent, cueTextLocale = toCueTextLocale(cueAudioLocale);
          // Locale for text (likely just the 2-letter lang prefix)
          if (cueTextLocale && isLocalSpeechAllowed()) {
            lastPlayer = localPlayer;
            fireBusyEvent();
            getCueText(name, cueTextLocale, function(cueText) {
              if (cueText) {
                localPlayer.speak({
                  text: cueText,
                  locale: cueAudioLocale
                }).then(fireNotBusyEvent).catch(function() {
                  onUnavailableFn();
                });
              }
            });
          } else {
            onUnavailableFn();
          }
        }
        function speakViaNetwork(onUnavailable) {
          var onUnavailableFn = onUnavailable || fireNotBusyEvent;
          if (isNetworkSpeechAllowed(cueAudioLocale)) {
            lastPlayer = networkPlayer;
            fireBusyEvent();
            var url = getCueUrl(name, cueAudioLocale);
            networkPlayer.play({
              isSpeech: true,
              url: url
            }).then(fireNotBusyEvent).catch(function() {
              onUnavailableFn();
            });
          } else {
            onUnavailableFn();
          }
        }
        var speakViaNetworkFn = true ? fireNotBusyEvent : speakViaNetwork;
        if (isLocalSpeechPreferred()) {
          speakLocally(speakViaNetworkFn);
        } else {
          speakViaNetworkFn(speakLocally);
        }
      }
      function playEarcon(earconName) {
        if (false) {
          // TODO can we play earcons in the extension without the heavyweight network player?
          stopAudio();
          var url = urls.resolveResourceUrl("earcons/" + earconName + "." + getMediaTypeForNetworkAudio());
          networkPlayer.play({
            url: url
          });
        }
      }
      function getBrowserSupportedTypeFromList(listOfAvailableExtensions) {
        var audioApi, index = 0, MEDIA_TYPES = {
          ogg: "audio/ogg",
          mp3: "audio/mpeg"
        };
        try {
          audioApi = new Audio();
        } catch (e) {}
        if (audioApi) {
          for (;index < listOfAvailableExtensions.length; index++) {
            var extension = listOfAvailableExtensions[index];
            if (audioApi.canPlayType(MEDIA_TYPES[extension])) {
              return extension;
            }
          }
        }
        // Must be Safari version <= 6, because we don't support other browsers without Audio() support
        return listOfAvailableExtensions.indexOf("aac") >= 0 ? "aac" : "mp3";
      }
      // What audio format will we use for prerecorded audio?
      function getMediaTypeForNetworkAudio() {
        if (!getMediaTypeForNetworkAudio.cached) {
          getMediaTypeForNetworkAudio.cached = getBrowserSupportedTypeFromList([ "ogg", "mp3" ]);
        }
        return getMediaTypeForNetworkAudio.cached;
      }
      /**
   * Returns if TTS is enabled or not.  Always returns true or false.
   */
      function isSpeechEnabled() {
        // Flag indicating that this site is enabled for TTS.
        return ttsOn;
      }
      // Get the client's preferred speech strategy.
      // This may not be the ultimate speech strategy used, because
      // 1) network speech will not play if ttsAvailable = false in served site preferences
      function getClientSpeechStrategy() {
        if (true) {
          return speechStrategy.LOCAL;
        }
        if (!getClientSpeechStrategy.cached) {
          getClientSpeechStrategy.cached = (site.get("speech") || {}).strategy || speechStrategy.AUTO;
          if (getClientSpeechStrategy.cached === speechStrategy.AUTO) {
            getClientSpeechStrategy.cached = constant.autoStrategy;
          }
        }
        return getClientSpeechStrategy.cached;
      }
      function isLocalSpeechAllowed() {
        return getClientSpeechStrategy() !== speechStrategy.NETWORK && window.speechSynthesis;
      }
      function isLocalSpeechPreferred() {
        var clientSpeechStrategy = getClientSpeechStrategy();
        return clientSpeechStrategy === speechStrategy.LOCAL || clientSpeechStrategy === speechStrategy.PREFER_LOCAL;
      }
      function getRerouteNetworkSpeechLangKey(lang) {
        return constant.REROUTE_NETWORK_SPEECH_KEY + lang;
      }
      function isNetworkSpeechAllowed(lang) {
        return getClientSpeechStrategy() !== speechStrategy.LOCAL && !window.sessionStorage.getItem(getRerouteNetworkSpeechLangKey(lang));
      }
      // This language failed on the network -- disallow it for this tab (uses sessionStorage)
      function rerouteNetworkSpeechLang(lang) {
        // Set to any value to reroute this language to local speech
        try {
          window.sessionStorage.setItem(getRerouteNetworkSpeechLangKey(lang), true);
        } catch (ex) {}
      }
      function init() {
        if (isInitialized) {
          return;
        }
        isInitialized = true;
        // Speak on text selection
        textSelect.init();
        /*
     * Speak whenever the lens is opened, if speech is on, etc.
     * Use a later speech fetch if local speech is preferred, because it makes the lens expansion animation janky.
     * TODO: It would be better to always listen for 'hlb/did-create' here so that
     *      speech synthesis happens during the opening animation.
     *      Unfortunately, this currently causes browsers to choke
     *      on the animation when using local speech. But that
     *      may improve in time.
     */
        var SPEECH_BEGIN_EVENT = isLocalSpeechPreferred() ? "hlb/ready" : "hlb/did-create";
        events.on(SPEECH_BEGIN_EVENT, onLensOpened);
        /*
     * A highlight box was closed.  Stop/abort/dispose of the player
     * attached to it.
     */
        events.on("hlb/closed", stopAudio);
        if (true) {
          // For debugging purposes
          // Takes one of the strategies from audio/constant.js
          sitecues.setSpeechStrategy = function(newStrategy) {
            getClientSpeechStrategy.cached = newStrategy;
          };
        }
        ttsOn = pref.get("ttsOn");
      }
      return {
        stopAudio: stopAudio,
        setSpeechState: setSpeechState,
        toggleSpeech: toggleSpeech,
        isSpeechEnabled: isSpeechEnabled,
        speakCueByName: speakCueByName,
        speakContent: speakContent,
        speakText: speakText,
        playEarcon: playEarcon,
        getTTSUrl: getTTSUrl,
        init: init
      };
    }(audio_constant, run_conf_preferences, run_conf_site, $, run_util_xhr, audio_speech_builder, run_locale, run_metric_metric, run_conf_urls, audio_text_select, run_events, audio_local_player, audio_network_player);
    audio_cues_audio_cues = function(pref, audio) {
      // The high zoom threshold for the zoom-based verbal cue
      var HIGH_ZOOM_THRESHOLD = 1.6, // Tracks the last time the user has heard the "descriptive high zoom" cue.
      DESCRIPTIVE_HIGH_ZOOM_PARAM = "firstHighZoom", // Time in millis after which cues should replay.
      CUE_RESET_MS = 6048e5, // 7 days
      // Tracks the last time the user has heard the longer, more descriptive "speech on" cue.
      DESCRIPTIVE_SPEECH_ON_PARAM = "firstSpeechOn", VERBAL_CUE_SPEECH_ON = "verbalCueSpeechOn", VERBAL_CUE_SPEECH_ON_DESCRIPTIVE = "verbalCueSpeechOnFirst", VERBAL_CUE_SPEECH_OFF = "verbalCueSpeechOff";
      /**
   * Returns true if the "descriptive speech on" cue should be played.
   * @return {boolean}
   */
      function shouldPlayDescriptiveSpeechOnCue() {
        var firstSpeechOn = pref.get(DESCRIPTIVE_SPEECH_ON_PARAM);
        return !firstSpeechOn || firstSpeechOn + CUE_RESET_MS < Date.now();
      }
      /**
   * Returns true if the description of one-touch-read should be played after a zoom change
   */
      function shouldPlayDescriptiveHighZoomCue(zoom) {
        // If zoom isn't high enough, or hasn't increased beyond initial setting, don't play cue
        if (zoom >= HIGH_ZOOM_THRESHOLD) {
          var lastDescriptiveZoomCueTime = parseInt(pref.get(DESCRIPTIVE_HIGH_ZOOM_PARAM));
          return !lastDescriptiveZoomCueTime || Date.now() - lastDescriptiveZoomCueTime > CUE_RESET_MS;
        }
      }
      /*
   * Play speech on cue if necessary
   */
      function playSpeechCue(isEnabled) {
        if (!isEnabled) {
          // *** Speech off cue ***
          audio.speakCueByName(VERBAL_CUE_SPEECH_OFF);
          return;
        }
        // EQ-996 - As a user, I want multiple chances to learn about the
        // spacebar command so that I can benefit from One Touch Read
        //---------------------------------------------------------------------------------------------------//
        // 1) For the TTS-spacebar hint (currently given when TTS is turned on the first time):
        // Give the hint max three times, or until the user successfully uses the spacebar once with TTS on.
        if (!shouldPlayDescriptiveSpeechOnCue()) {
          audio.speakCueByName(VERBAL_CUE_SPEECH_ON);
        } else {
          audio.speakCueByName(VERBAL_CUE_SPEECH_ON_DESCRIPTIVE);
          // Signals that the "descriptive speech on" cue has played
          pref.set(DESCRIPTIVE_SPEECH_ON_PARAM, Date.now());
        }
      }
      function playZoomCue(zoom) {
        // If highlighting is enabled, zoom is large enough, zoom is larger
        // than we started, and we haven't already cued, then play an audio
        // cue to explain highlighting
        if (shouldPlayDescriptiveHighZoomCue(zoom)) {
          audio.speakCueByName("verbalCueHighZoom");
          // Signals that the "descriptive high zoom" cue has played.
          pref.set(DESCRIPTIVE_HIGH_ZOOM_PARAM, Date.now());
        }
      }
      return {
        playSpeechCue: playSpeechCue,
        playZoomCue: playZoomCue
      };
    }(run_conf_preferences, audio_audio);
    status_status = function(urls, xhr, pref, site, nativeGlobal) {
      function format(object) {
        // Helper to turn objects into string representations for logging.
        var INDENTATION = "    ", result = object;
        if (nativeGlobal.JSON && nativeGlobal.JSON.stringify) {
          result = nativeGlobal.JSON.stringify(object, null, INDENTATION);
        }
        return result;
      }
      function consoleCallback(status) {
        // The default status reporter, logs all data to the console.
        // Make sure we are not running from a file (unit testing in node)...
        if ("http:" === location.protocol || "https:" === location.protocol) {
          // We only support the native console for now, so make sure it exists...
          if (console && console.log) {
            // Make it clear where to begin copying...
            console.log("\n-----BEGIN SITECUES STATUS-----\n");
            // Log with pretty-print, if possible...
            console.log(format(status));
            // Make it clear where to end copying...
            console.log("\n-----END SITECUES STATUS-----\n");
          }
        }
      }
      function status(callback) {
        var coordinates, setting, state, info, html = document.documentElement, prefData = pref.get(), ajaxUrls = {
          // Set the server URLs for retrieving the status of our services (version info, etc.)
          ws: urls.getApiUrl("util/status")
        };
        callback = callback || consoleCallback;
        info = {
          time: Date.now(),
          currentUrl: location.href,
          userAgent: navigator.userAgent,
          version: {
            js: sitecues.version,
            ws: null
          },
          config: site.getSiteConfig()
        };
        // Measurements useful for reproducing bugs, because their state affects
        // the behavior of our CSS, animations, etc.
        coordinates = {
          document: {
            clientWidth: html.clientWidth,
            clientHeight: html.clientHeight,
            clientLeft: html.clientLeft,
            clientTop: html.clientTop
          },
          window: {
            pageXOffset: pageXOffset,
            pageYOffset: pageYOffset,
            innerWidth: innerWidth,
            innerHeight: innerHeight,
            outerWidth: outerWidth,
            outerHeight: outerHeight,
            screenX: screenX,
            screenY: screenY
          },
          screen: {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            availLeft: screen.availLeft,
            availTop: screen.availTop
          }
        };
        // Add current settings (zoom level, etc) to the log.
        for (setting in prefData) {
          if (prefData.hasOwnProperty(setting)) {
            info[setting] = prefData[setting];
          }
        }
        // Add all measurements for bug reproduction to the log.
        for (state in coordinates) {
          if (coordinates.hasOwnProperty(state)) {
            info[state] = coordinates[state];
          }
        }
        // Defer the ajax calls so we can respond when both are complete.
        function readyCheck() {
          var ready = "string" === typeof info.version.ws;
          if (ready) {
            // Publish the status for later retrieval.
            sitecues.status.latest = info;
            callback(info);
          }
        }
        if (true) {
          callback(info);
        } else {
          xhr.getJSON({
            type: "GET",
            url: ajaxUrls.ws,
            success: function(response) {
              // Set the version based on the AJAX response object
              info.version.ws = response.version;
              readyCheck();
            },
            error: function() {
              // Set an error message if the AJAX object did not return
              info.version.ws = "Error fetching WS version from service URL";
              readyCheck();
            }
          });
        }
        return "Fetching Sitecues status...";
      }
      return status;
    }(run_conf_urls, run_util_xhr, run_conf_preferences, run_conf_site, mini_core_native_global);
    info_info = function($, site, urls, dimmer, platform, locale, colorUtil, events, ids, nativeGlobal, inlineStyle) {
      var addCloseButtonTimer, $iframe = $(), $closeButton = $(), MAX_ZINDEX = 2147483647, INITIAL_CSS = {
        position: "fixed",
        left: "15%",
        top: "10%",
        width: "70%",
        height: "80%",
        transform: "scale3d(.7,.7,1)",
        willChange: "transform",
        backgroundColor: "#fff",
        borderRadius: "8px",
        transition: "opacity .9s, transform 1s",
        opacity: 0,
        zIndex: MAX_ZINDEX
      }, ENLARGED_CSS = {
        opacity: 1,
        transform: "scale(1)"
      }, BUTTON_SIZE = 60, CLOSE_BUTTON_CSS = {
        cursor: "pointer",
        border: "3px solid #ccc",
        borderRadius: "48px",
        background: "#222",
        fontSize: "54px",
        fontFamily: "Verdana",
        display: "block",
        lineHeight: "0px",
        position: "fixed",
        zIndex: MAX_ZINDEX,
        margin: "8px",
        width: BUTTON_SIZE + "px",
        height: BUTTON_SIZE + "px",
        opacity: 0,
        transition: "opacity 200ms"
      }, INITIAL_DELAY = 100, INFLATION_SPEED = 1e3, DIMMER_SPEED = 500, isModalOpen = false;
      function getBorderCss() {
        // Use adaptive border that is visible on any background
        return colorUtil.isOnDarkBackground(document.body) ? "7px solid #fff" : "20px solid #000";
      }
      function close() {
        inlineStyle.set($iframe[0], INITIAL_CSS);
        nativeGlobal.setTimeout(function() {
          $iframe.remove();
          $iframe = $();
          isModalOpen = false;
        }, INFLATION_SPEED);
        $(window).off("focus", close);
        window.removeEventListener("message", checkCloseMessage);
        enableScrolling(true);
        enableWebPagePointerEvents(true);
        dimmer.undimBackgroundContent(DIMMER_SPEED);
        removeCloseButton();
      }
      function onload() {
        // Try to focus iframe
        nativeGlobal.setTimeout(function() {
          var iframe = $iframe[0];
          try {
            iframe.contentWindow.focus();
          } catch (ex) {}
          $(window).one("focus", close);
          window.addEventListener("message", checkCloseMessage);
        }, 0);
      }
      function showModal(pageName, anchor) {
        if (isModalOpen) {
          return;
        }
        var localizedPageName = pageName + "-" + locale.getUiLocale(), sitecuesJsUrl = urls.getRawScriptUrl(), hostUrl = window.location, pageUrl = urls.resolveResourceUrl("html/help/" + localizedPageName + ".html", {
          scUrl: sitecuesJsUrl,
          siteId: site.getSiteId(),
          siteUrl: hostUrl.protocol + "//" + hostUrl.hostname + ":" + hostUrl.port,
          sessionId: ids.sessionId,
          pageViewId: ids.pageViewId,
          prefs: window.localStorage.sitecues,
          appUrl: site.get("appUrl")
        });
        events.emit("info/did-show");
        $iframe = $("<iframe>").attr("src", pageUrl + anchor);
        inlineStyle.set($iframe[0], INITIAL_CSS);
        inlineStyle($iframe[0]).border = getBorderCss();
        $iframe.one("load", onload).appendTo("html");
        // Prevent panning in background content
        enableWebPagePointerEvents(false);
        enableScrolling(false);
        dimmer.dimBackgroundContent(DIMMER_SPEED, $iframe);
        nativeGlobal.setTimeout(function() {
          inlineStyle.set($iframe[0], ENLARGED_CSS);
          var iframeEl = $iframe[0];
          if (iframeEl.contentWindow) {
            iframeEl.contentWindow.focus();
          } else {
            iframeEl.focus();
          }
        }, INITIAL_DELAY);
        // Waiting helps animation performance
        addCloseButtonTimer = nativeGlobal.setTimeout(addCloseButton, INITIAL_DELAY + INFLATION_SPEED + 100);
        isModalOpen = true;
      }
      function checkCloseMessage(evt) {
        if ("sc-close-iframe" === evt.data) {
          close();
        }
      }
      function addCloseButton() {
        var helpRect = $iframe[0].getBoundingClientRect(), offsetLeft = platform.browser.isMS ? -30 : -17, // Deal with big scrollbars on Windows
        offsetTop = platform.browser.isMS ? -6 : -1;
        $closeButton = $('<scx style="display:block" class="scp-hand-cursor"><scx style="position:relative;left:14px;top:23px;color:#ccc">x</scx></scx>');
        inlineStyle.set($closeButton[0], CLOSE_BUTTON_CSS);
        inlineStyle.set($closeButton[0], {
          left: helpRect.right - BUTTON_SIZE / 2 + offsetLeft + "px",
          // Subtracts border width as well
          top: helpRect.top - BUTTON_SIZE / 2 + offsetTop + "px"
        });
        $closeButton.appendTo("html").one("click", close);
        addCloseButtonTimer = nativeGlobal.setTimeout(function() {
          inlineStyle($closeButton[0]).opacity = "1";
        }, 100);
      }
      function removeCloseButton() {
        $closeButton.remove();
        if (addCloseButtonTimer) {
          clearTimeout(addCloseButtonTimer);
        }
        addCloseButtonTimer = 0;
      }
      function enableWebPagePointerEvents(doEnable) {
        var collection = $("body,#scp-bp-container");
        inlineStyle.override(collection.get(), {
          pointerEvents: doEnable ? "" : "none"
        });
      }
      function enableScrolling(doEnable) {
        var docElem = document.documentElement;
        if (doEnable) {
          inlineStyle.restoreLast(docElem, [ "overflow-x", "overflow-y" ]);
        } else {
          inlineStyle.override(docElem, {
            overflowX: "hidden",
            overflowY: "hidden"
          });
        }
      }
      // jumpTo can be to a named anchor or id in the document, e.g. #keyboard
      function showHelp(jumpToAnchor) {
        showModal("help", jumpToAnchor || "");
      }
      return {
        showHelp: showHelp
      };
    }($, run_conf_site, run_conf_urls, hlb_dimmer, run_platform, run_locale, page_util_color, run_events, run_conf_id, mini_core_native_global, run_inline_style_inline_style);
    pick_debug_pick_debug = function() {
      var DEBUG_LABEL_STYLE = "font-weight: normal; color: purple";
      // -------- Logging section ---------
      function scoreFactorCompare(sf1, sf2) {
        return Math.abs(sf2.impact) - Math.abs(sf1.impact);
      }
      function isFactor(item) {
        return 0 !== item.impact;
      }
      function isNonFactor(item) {
        return 0 === item.impact;
      }
      function getScoreFactorString(sf) {
        var value = 1 * sf.value || 0;
        return String("                                       " + sf.about).slice(-45) + ": " + String("                        " + value.toFixed(1)).slice(-21) + "   x " + String("                        " + sf.weight.toFixed(1)).slice(-21) + "   = " + String("                        " + (sf.weight * value).toFixed(0)).slice(-21);
      }
      function logHeuristicResult(scoreObjs, bestScoreIndex, nodes) {
        var index, scoreObj;
        var numUnusableAtTop = 0;
        var startItem = scoreObjs.length - 1;
        scoreObjs.some(function(scoreObj) {
          if (!scoreObj.judgements) {
            ++numUnusableAtTop;
            return false;
          }
          return true;
        });
        if (numUnusableAtTop) {}
        for (index = startItem; index >= 0; index--) {
          scoreObj = scoreObjs[index];
          var headingStyle = "font-weight: bold; font-size: 10pt; " + (index === bestScoreIndex && "background-color: green; color: white;");
          console.group("%c%s    Score = %d", headingStyle, scoreObj.about, scoreObj.score);
          console.log(nodes[index]);
          logObject("Traits", scoreObj.traits);
          logObject("Judgements", scoreObj.judgements);
          if (scoreObj.factors) {
            scoreObj.factors.sort(scoreFactorCompare);
            // Display highest impact score factors first
            logArray("Factors", scoreObj.factors.filter(isFactor).map(getScoreFactorString), true);
            logArray("Non-factors", scoreObj.factors.filter(isNonFactor).map(getScoreFactorString));
          }
        }
        scoreObjs.forEach(function() {
          console.groupEnd();
        });
      }
      function logItem(item) {
        if (console.log.toString().indexOf("[native code]") > 0) {
          console.log(item);
          return;
        }
        // Fallback when they tried to kill off logging
        console.group(item);
        console.groupEnd();
      }
      function logTitle(title, doStartExpanded) {
        if (doStartExpanded) {
          console.group("%c%s", DEBUG_LABEL_STYLE, title);
        } else {
          console.groupCollapsed("%c%s", DEBUG_LABEL_STYLE, title);
        }
      }
      function logArray(title, array, doStartExpanded) {
        if (array) {
          logTitle(title, doStartExpanded);
          array.forEach(logItem);
          console.groupEnd();
        }
      }
      function logStyleObject(sty) {
        var index;
        logTitle("style");
        for (index = 0; index < sty.length; index++) {
          console.log("%c%s: %c%s", DEBUG_LABEL_STYLE, sty[index], "color: #222222", sty[sty[index]]);
        }
        console.groupEnd();
      }
      function logObject(title, obj, doStartExpanded) {
        var index, key, sortedKeys;
        if (obj) {
          sortedKeys = Object.keys(obj).sort();
          logTitle(title, doStartExpanded);
          for (index = 0; index < sortedKeys.length; index++) {
            key = sortedKeys[index];
            if (obj[key] instanceof CSSStyleDeclaration) {
              logStyleObject(obj[key]);
            } else {
              if (obj[key] instanceof Object) {
                logObject(key, obj[key]);
              } else {
                console.log("%c%s: %c%s", DEBUG_LABEL_STYLE, key, "color: #222222", obj[key]);
              }
            }
          }
          console.groupEnd();
        }
      }
      return {
        logHeuristicResult: logHeuristicResult
      };
    }();
    labs_labs = function(pref, $, events) {
      var labSettings = $.extend({}, pref.get("labs"));
      function isEnabled(labName) {
        return labSettings[labName];
      }
      events.on("labs/get", function(labInfo) {
        $.extend(labInfo, labSettings);
      });
      events.on("labs/set", function(labInfo) {
        labSettings = $.extend({}, labInfo);
        pref.set("labs", labSettings);
      });
      return {
        isEnabled: isEnabled
      };
    }(run_conf_preferences, $, run_events);
    inverter_invert_url = function(urls, Promise) {
      // Helper to invert image data, pixel by pixel
      function invertImageData(ctx, width, height) {
        var imageData = ctx.getImageData(0, 0, width, height), data = imageData.data, dataLength = data.length, index = 0;
        for (;index < dataLength; index += 4) {
          // red
          data[index] = 255 - data[index];
          // green
          data[index + 1] = 255 - data[index + 1];
          // blue
          data[index + 2] = 255 - data[index + 2];
        }
        ctx.putImageData(imageData, 0, 0);
      }
      // Temporary image, created so we can find the width/height
      function createTempImage(url) {
        // Create temporary image
        var img = document.createElement("img");
        img.src = url;
        return img;
      }
      // Create an inverted version of a data: image, pixel by pixel
      // Pass in original image if available, otherwise it will create a temporary image
      function getInvertedDataUrl(url, optionalOrigImage) {
        function getLoadedImage() {
          var // Use temp image if orig <img> not available (will have naturalHeight and naturalWidth set)
          doUseOrigImage = optionalOrigImage && "img" === optionalOrigImage.localName, img = doUseOrigImage ? optionalOrigImage : createTempImage(url);
          if (img.complete) {
            return Promise.resolve(img);
          }
          return new Promise(function(resolve) {
            img.addEventListener("load", function() {
              resolve(img);
            });
          });
        }
        return getLoadedImage().then(function(img) {
          var canvas = document.createElement("canvas"), width = canvas.width = img.naturalWidth, height = canvas.height = img.naturalHeight, ctx = canvas.getContext("2d");
          // Draw the image
          ctx.drawImage(img, 0, 0, width, height);
          // Invert it
          invertImageData(ctx, width, height);
          // Return new data url
          return canvas.toDataURL();
        });
      }
      function getInvertUrl(url, origElem) {
        // Data url
        if (0 === url.indexOf("data:")) {
          // The image service can't invert this url, but we can do it in JS.
          // Very useful for example on http://www.gatfl.gatech.edu/tflwiki/index.php?title=Team
          return getInvertedDataUrl(url, origElem);
        }
        var newUrl = urls.getProxyApiUrl("image/invert", url);
        return Promise.resolve(newUrl);
      }
      return {
        getInvertUrl: getInvertUrl
      };
    }(run_conf_urls, Promise);
    inverter_orig_bg_info = function(Promise, colorUtil, styleService) {
      var DARK_HINTS_ID = "sitecues-js-orig-info", FLAG_BG_DARK = '"D"', FLAG_BG_LIGHT = '"L"';
      function getSanitizedSelector(selector) {
        function allowSelector(subSelector) {
          return subSelector.lastIndexOf(":before") < 0 && subSelector.lastIndexOf(":after") < 0;
        }
        // Remove :before, ::before, :after, ::after rules
        var subSelectors = selector.split(","), allowedSubSelectors = subSelectors.filter(allowSelector);
        return allowedSubSelectors.join(",");
      }
      function createDarkHintRule(selector, themeStyle, rgba) {
        var DARK_BG_THRESHOLD = .6, isDark = colorUtil.getFastLuminance(rgba) < DARK_BG_THRESHOLD, important = themeStyle.value.important, contentFlag = isDark ? FLAG_BG_DARK : FLAG_BG_LIGHT;
        // D = dark, L = light
        return selector + "{ content: " + contentFlag + (important ? " !important; " : "; ") + "}\n";
      }
      function createDarkHintCss(styleInfo) {
        var darkHintSheetCss = "";
        styleInfo.forEach(function(themeStyle) {
          if ("background-color" !== themeStyle.value.prop) {
            return;
          }
          var rgba = themeStyle.value.parsedVal, selector = getSanitizedSelector(themeStyle.rule.selectorText);
          if (rgba.a > .5 && selector) {
            // Don't bother if mostly transparent
            // Only use selectors without :before and :after
            darkHintSheetCss += createDarkHintRule(selector, themeStyle, rgba);
          }
        });
        return darkHintSheetCss;
      }
      // Return a promise to the bg hints style sheet
      function init(styleInfo) {
        return new Promise(function(resolve) {
          var darkHintSheetCss = createDarkHintCss(styleInfo), $sheet = styleService.updateSheet(DARK_HINTS_ID, {
            text: darkHintSheetCss
          });
          styleService.getDOMStylesheet($sheet, resolve);
        });
      }
      function wasOnDarkBackground(current) {
        var currentRect, origElement = current, origRect = origElement.getBoundingClientRect();
        while (current) {
          currentRect = current.getBoundingClientRect();
          // Only care about backgrounds where the original element is inside of the background rect
          if (currentRect.right > origRect.left && currentRect.left < origRect.right && currentRect.bottom > origRect.top && currentRect.top < origRect.bottom) {
            var bgHint = window.getComputedStyle(current).content;
            if (bgHint === FLAG_BG_DARK) {
              return true;
            } else {
              if (bgHint === FLAG_BG_LIGHT) {
                return false;
              }
            }
          }
          current = current.parentElement;
        }
        return false;
      }
      return {
        init: init,
        wasOnDarkBackground: wasOnDarkBackground
      };
    }(Promise, page_util_color, page_style_service_style_service);
    inverter_img_classifier = function($, colorUtil, site, urls, invertUrl, origBgInfo, nativeGlobal) {
      var REVERSIBLE_ATTR = "data-sc-reversible", customSelectors = site.get("themes") || {}, SVG_SCORE = 999, JPG_SCORE = -50, isDebuggingOn = true, CLASS_INVERT = "i", CLASS_NORMAL = "n", MAX_SCORE_CHECK_PIXELS = 200, imageScores = {
        ".png": 50,
        ".jpg": JPG_SCORE,
        ".jpeg": JPG_SCORE,
        ".gif": -35,
        ".svg": SVG_SCORE
      };
      function isImageExtension(ext) {
        var imgExts = Object.keys(imageScores);
        return imgExts.indexOf(ext) !== -1;
      }
      function isSVGSource(src) {
        var ext = urls.extname(src);
        return ".svg" === ext;
      }
      // Get <img> that can have its pixel data read --
      // 1. Must be completely loaded
      // 2. We have permission (either we're in the extension, the img is not cross-origin, or we can load it through the proxy)
      // Either pass img or src, but not both
      function getReadableImage(img, src, onReadableImageAvailable, onReadableImageError) {
        // Unsafe cross-origin request
        // - Will run into cross-origin restrictions because URL is from different origin
        // This is not an issue with the extension, because the content script doesn't have cross-origin restrictions
        var safeUrl, url = src || img.getAttribute("src"), isSafeRequest = urls.isSameOrigin(url);
        function returnImageWhenComplete(loadableImg, isInverted) {
          if (loadableImg.complete) {
            onReadableImageAvailable(loadableImg, isInverted);
          } else {
            $(loadableImg).on("load", function() {
              onReadableImageAvailable(loadableImg, isInverted);
            }).on("error", onReadableImageError);
          }
        }
        if (isSafeRequest) {
          if (img && "img" === img.localName) {
            returnImageWhenComplete(img);
            // The <img> in the DOM can have its pixels queried
            return;
          }
          // Element we want to read is not an <img> -- for example, <input type="image">
          // Create an <img> with the same url so we can apply it to the canvas
          safeUrl = url;
          returnImageWhenComplete(createSafeImage(safeUrl));
        }
        // Uses inverted image for analysis so that if we need to display it, it's already in users cache.
        // The inverted image will show the same number of brightness values in the histogram so this won't effect classification
        invertUrl.getInvertUrl(url, img).then(function(newUrl) {
          returnImageWhenComplete(createSafeImage(newUrl, true));
        });
      }
      function createSafeImage(url) {
        var $safeImg = $("<img>").attr("crossorigin", "anonymous").attr("src", url);
        return $safeImg[0];
      }
      // Either pass img or src, but not both
      function getImageData(img, src, rect, processImageData) {
        var ctx, imageData, canvas = document.createElement("canvas"), top = rect.top || 0, left = rect.left || 0, width = rect.width, height = rect.height;
        canvas.width = width;
        canvas.height = height;
        function onReadableImageAvailable(readableImg, isInverted) {
          ctx = canvas.getContext("2d");
          try {
            ctx.drawImage(readableImg, top, left, width, height);
          } catch (ex) {
            processImageData();
            // No data -- probably a broken image
            return;
          }
          imageData = ctx.getImageData(0, 0, width, height).data;
          processImageData(imageData, isInverted);
        }
        function onImageError() {
          processImageData();
        }
        getReadableImage(img, src, onReadableImageAvailable, onImageError);
      }
      // Either pass img or src, but not both
      function getPixelInfo(img, src, rect, processPixelInfo) {
        getImageData(img, src, rect, function(data, isInverted) {
          processPixelInfo(data && getPixelInfoImpl(data, rect.width, rect.height, isInverted));
        });
      }
      function getPixelInfoImpl(data, width, height, isInverted) {
        //
        // Compute Image Features (if we can...)
        // We may not be able to if the image is not from the same origin.
        //
        var grayscaleVal, hueIndex, numWithSameGrayscale, histogramIndex, grayscaleHistogram = [], GRAYSCALE_HISTOGRAM_SIZE = 500, hueHistogram = [], HUE_HISTOGRAM_SIZE = 100, byteIndex = 0, hasTransparentPixels = false, DWORD_SIZE = 4, numBytes = width * height * DWORD_SIZE, numDifferentGrayscaleVals = 0, numMultiUseGrayscaleVals = 0, numDifferentHues = 0, maxSameGrayscale = 0, MAX_PIXELS_TO_TEST = 523, area = height * width, stepSize = Math.floor(area / Math.min(area, MAX_PIXELS_TO_TEST)), MIN_TRANSPARENCY_FOR_VALID_PIXEL = .3, numPixelsToCheck = Math.floor(area / stepSize), // Greater of: 6 pixels or 5% of total pixels checked
        numSameBeforeConsideredMultiUse = Math.max(Math.ceil(.05 * numPixelsToCheck), 6), numPixelsChecked = 0, luminanceTotal = 0, maxLuminance = 0;
        for (;byteIndex < numBytes; byteIndex += DWORD_SIZE * stepSize) {
          var rgba = {
            r: data[byteIndex],
            g: data[byteIndex + 1],
            b: data[byteIndex + 2],
            a: data[byteIndex + 3]
          }, isSemiTransparent = rgba.a < 255;
          if (isSemiTransparent) {
            // Alpha channel
            hasTransparentPixels = true;
            if (rgba.a < MIN_TRANSPARENCY_FOR_VALID_PIXEL) {
              continue;
            }
          }
          ++numPixelsChecked;
          if (isInverted) {
            // Used inverted image to get around cross-origin issues
            // We use this instead of passthrough option because it puts the image into the cache in case we need it
            // However, we need to evaluate the brightness as if it's not inverted
            rgba.r = 255 - rgba.r;
            rgba.g = 255 - rgba.g;
            rgba.b = 255 - rgba.b;
          }
          grayscaleVal = colorUtil.getFastLuminance(rgba);
          luminanceTotal += grayscaleVal;
          if (grayscaleVal > maxLuminance) {
            maxLuminance = grayscaleVal;
          }
          histogramIndex = Math.floor(grayscaleVal * GRAYSCALE_HISTOGRAM_SIZE);
          if (grayscaleHistogram[histogramIndex] > 0) {
            numWithSameGrayscale = ++grayscaleHistogram[histogramIndex];
            if (numWithSameGrayscale === numSameBeforeConsideredMultiUse) {
              ++numMultiUseGrayscaleVals;
            }
            if (numWithSameGrayscale > maxSameGrayscale) {
              maxSameGrayscale = numWithSameGrayscale;
            }
          } else {
            grayscaleHistogram[histogramIndex] = 1;
            ++numDifferentGrayscaleVals;
          }
          hueIndex = Math.floor(colorUtil.rgbToHsl(rgba.r, rgba.g, rgba.b).h * HUE_HISTOGRAM_SIZE);
          if (hueHistogram[hueIndex] > 0) {
            ++hueHistogram[hueIndex];
          } else {
            hueHistogram[hueIndex] = 1;
            ++numDifferentHues;
          }
        }
        return {
          hasTransparentPixels: hasTransparentPixels,
          numDifferentGrayscaleVals: numDifferentGrayscaleVals,
          numMultiUseGrayscaleVals: numMultiUseGrayscaleVals,
          percentWithSameGrayscale: numPixelsChecked ? maxSameGrayscale / numPixelsChecked : .5,
          numDifferentHues: numDifferentHues,
          averageLuminance: numPixelsChecked ? luminanceTotal / numPixelsChecked : .5,
          maxLuminance: maxLuminance
        };
      }
      function getImageSize(img) {
        return {
          // Sometimes naturalWidth, naturalHeight are not available, especially in the case of <input type="image">
          width: img.naturalWidth || img.width,
          height: img.naturalHeight || img.height
        };
      }
      // These come from the original machine-learned algorithms
      function getSizeScore(height, width) {
        if (width <= 1 || height <= 1) {
          return 0;
        }
        var score = 0, aspectRatio = width / height;
        // No color information
        if (height < 26) {
          score += 100;
        } else {
          if (height < 37) {
            score += 50;
          }
        }
        if (height > 180) {
          score += 180 - height;
        } else {
          if (1 === aspectRatio) {
            score *= 2;
          } else {
            if (aspectRatio > 4) {
              score += 100;
            } else {
              if (aspectRatio > 3) {
                score += 50;
              }
            }
          }
        }
        if (height < 400) {
          if (aspectRatio < .7) {
            score -= 50;
          } else {
            if (aspectRatio > 1.4 && aspectRatio < 1.9) {
              score -= 70;
              // Typical photo
              if (aspectRatio > 1.49 && aspectRatio < 1.51) {
                score -= 30;
              }
              if (height > 130) {
                score += 130 - height;
              }
            }
          }
        }
        return Math.max(score, -150);
      }
      function getExtensionScore(imageExt) {
        var defaultValue = -70;
        return "number" === typeof imageScores[imageExt] ? imageScores[imageExt] : defaultValue;
      }
      // Either pass img or src, but not both
      function getPixelInfoScore(img, src, rect, onPixelScoreAvailable) {
        if (rect.width <= 1 || rect.height <= 1) {
          onPixelScoreAvailable(0);
          // It's possible that image simply isn't loaded yet, scroll down in brewhoop.com
          return;
        }
        // The magic values in here are taken from the original machine-learned algorithms
        // from Jeff Bigham's work, and have been tweaked a bit.
        getPixelInfo(img, src, rect, function(pixelInfo) {
          if (!pixelInfo) {
            if (true && isDebuggingOn && img) {
              $(img).attr("data-sc-pixel-score", "invalid");
            }
            onPixelScoreAvailable(0, true);
            // true -> this was an expensive operation so we should cache the result
            return;
          }
          var score, BASE_SCORE = 130, DARK_LUMINANCE_THRESHOLD = .4, DARK_LUMINANCE_MAX_THRESHOLD = .35, BRIGHT_LUMINANCE_THRESHOLD = .6, analysis = {
            manyValuesScore: 0,
            manyReusedValuesScore: 0,
            oneValueReusedOftenScore: 0,
            numHuesScore: 0,
            transparentPixelsScore: 0,
            darkNonTransparencyScore: 0,
            brightWithTransparencyScore: 0
          };
          // Low score -> NO invert (probably photo)
          // High score -> YES invert (probably logo, icon or image of text)
          // Transparent pixels -> more likely icon that needs inversion
          // No transparent pixels -> rectangular shape that usually won't be problematic over any background
          analysis.transparentPixelsScore = 100 * pixelInfo.hasTransparentPixels;
          // More values -> more likely to be photo
          analysis.manyValuesScore = -1.5 * Math.min(200, pixelInfo.numDifferentGrayscaleVals);
          // Values reused -> less likely to be a photo
          analysis.manyReusedValuesScore = 15 * Math.min(20, pixelInfo.numMultiUseGrayscaleVals);
          // One large swath of color -> less likely to be a photo. For example 30% -> +60 points
          analysis.oneValueReusedOftenScore = Math.min(50, 200 * pixelInfo.percentWithSameGrayscale);
          if (pixelInfo.hasTransparentPixels) {
            if (pixelInfo.averageLuminance > BRIGHT_LUMINANCE_THRESHOLD) {
              // This is already looks like bright text or a bright icon
              // Don't revert, because it will most likely end up as dark on dark
              analysis.brightWithTransparencyScore = -1500 * (pixelInfo.averageLuminance - BRIGHT_LUMINANCE_THRESHOLD);
            }
          } else {
            if (pixelInfo.averageLuminance < DARK_LUMINANCE_THRESHOLD) {
              // This is already a very dark image, so inverting it will make it bright -- unlikely the right thing to do
              // We don't do this for images with transparent pixels, because it is likely a dark drawing on a light background,
              // which needs to be inverted
              analysis.darkNonTransparencyScore = -1e3 * (DARK_LUMINANCE_THRESHOLD - pixelInfo.averageLuminance) - 50;
              if (pixelInfo.maxLuminance < DARK_LUMINANCE_MAX_THRESHOLD) {
                analysis.darkNonTransparencyScore *= 2;
              }
            }
          }
          // Many hues -> more likely to be a photo -- experimentation showed that 8 hues seemed to work as a threshold
          if (pixelInfo.numDifferentHues < 8) {
            // Few hues: probably not a photo -- YES invert
            analysis.numHuesScore = 1.5 * Math.pow(pixelInfo.numDifferentHues - 8, 2);
          } else {
            if (pixelInfo.numDifferentHues > 35) {
              // Many hues: probably a photo -- NO invert
              analysis.numHuesScore = pixelInfo.numDifferentHues * -2;
            }
          }
          score = BASE_SCORE + analysis.transparentPixelsScore + analysis.manyValuesScore + analysis.manyReusedValuesScore + analysis.oneValueReusedOftenScore + analysis.brightWithTransparencyScore + analysis.darkNonTransparencyScore + analysis.numHuesScore;
          // Image has full color information
          if (true && isDebuggingOn && img) {
            $(img).attr("data-sc-pixel-info", nativeGlobal.JSON.stringify(pixelInfo));
            $(img).attr("data-sc-pixel-score-breakdown", nativeGlobal.JSON.stringify(analysis));
            $(img).attr("data-sc-pixel-score", score);
          }
          onPixelScoreAvailable(score, true);
        });
      }
      function getElementTypeScore(img) {
        var BUTTON_BONUS = 50;
        switch (img.localName) {
         case "input":
          return BUTTON_BONUS;

         case "svg":
          return SVG_SCORE;

         default:
          return 0;
        }
      }
      // Uses a sitecues prefix to avoid namespace conflicts with underlying page
      // Uses a hash function on the url to reduce the amount of storage required to save results for each url
      function getStorageKey(img) {
        var STORAGE_PREFIX = "-sc-img-";
        // jshint -W016
        function getHashCode(s) {
          // From http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
          // but modified to reduce the number of collisions (by not confining the values to 32 bit)
          // For 294 images on a site, the normal 32 bit hash algorithm has a 1/100,000 chance of collision, and we are better than that.
          // For more info on hash collisions, see http://preshing.com/20110504/hash-collision-probabilities/
          return s.split("").reduce(function(a, b) {
            return (a << 5) - a + b.charCodeAt(0);
          }, 0).toString(36);
        }
        return STORAGE_PREFIX + getHashCode(img.getAttribute("src"));
      }
      // Classify an image that is loaded/loading from a src
      function classifyLoadableImage(img, onShouldReverseImage) {
        var storageKey = getStorageKey(img), cachedResult = sessionStorage.getItem(storageKey);
        function classifyLoadedImage() {
          shouldInvertElement(img, function(isReversible, didAnalyzePixels) {
            if (didAnalyzePixels) {
              // Only cache for expensive operations, in order to save on storage space
              var imageClass = isReversible ? CLASS_INVERT : CLASS_NORMAL;
              // Use session storage instead of local storage so that we don't pollute too much
              try {
                sessionStorage.setItem(storageKey, imageClass);
              } catch (ex) {}
            }
            onImageClassified(img, isReversible, onShouldReverseImage);
          });
        }
        function imageLoadError() {
          onImageClassified(img, false);
        }
        if (false) {
          // Use cached result if available
          onImageClassified(img, cachedResult === CLASS_INVERT, onShouldReverseImage);
        } else {
          if (img.complete) {
            //Image is loaded and ready for processing -- after slight delay
            nativeGlobal.setTimeout(classifyLoadedImage, 0);
          } else {
            // Too early to tell anything
            // Wait until image loaded
            $(img).on("load", classifyLoadedImage).on("error", imageLoadError);
          }
        }
      }
      /**
   * Classifier function for images without missing features.
   * This formula came from a machine learning algorithm with the help of Jeffrey Bigham
   * @param img
   * @returns {*}
   */
      function classifyImage(img, onShouldReverseImage) {
        var isReversible, $img = $(img);
        if ($img.is(customSelectors.reversible)) {
          isReversible = true;
        } else {
          if ($img.is(customSelectors.nonReversible)) {
            isReversible = false;
          } else {
            if (origBgInfo.wasOnDarkBackground(img)) {
              isReversible = false;
            } else {
              if ("svg" === img.localName) {
                isReversible = true;
              } else {
                if (!img.src) {
                  isReversible = false;
                } else {
                  classifyLoadableImage(img, onShouldReverseImage);
                  return;
                }
              }
            }
          }
        }
        onImageClassified(img, isReversible, onShouldReverseImage);
      }
      function onImageClassified(img, isReversible, onShouldReverseImage) {
        img.setAttribute(REVERSIBLE_ATTR, isReversible);
        if (isReversible) {
          onShouldReverseImage(img);
        }
      }
      function getSource(img) {
        var srcSet, src = img.getAttribute("src");
        if (!src) {
          srcSet = img.getAttribute("srcset");
          if (srcSet) {
            src = srcSet.split("/, /")[0];
          }
        }
        return src;
      }
      function shouldInvertElement(img, onInversionDecision) {
        var src = getSource(img);
        if (!src) {
          return false;
        }
        var imageExt = urls.extname(src);
        if (!isImageExtension(imageExt)) {
          return false;
        }
        var size = getImageSize(img), sizeScore = getSizeScore(size.height, size.width), elementTypeScore = getElementTypeScore(img), extensionScore = getExtensionScore(imageExt), finalScore = sizeScore + elementTypeScore + extensionScore;
        if (finalScore < -MAX_SCORE_CHECK_PIXELS || finalScore > MAX_SCORE_CHECK_PIXELS) {
          // Early return
          onInversionDecision(finalScore > 0);
          return;
        }
        // Pixel info takes longer to get: only do it if necessary
        getPixelInfoScore(img, null, size, function(pixelInfoScore, didAnalyzePixels) {
          finalScore += pixelInfoScore;
          if (true && isDebuggingOn) {
            $(img).attr("score", sizeScore + " (size) + " + (elementTypeScore ? elementTypeScore + " (button) + " : "") + extensionScore + " (ext) + " + pixelInfoScore + " (pixels) = " + finalScore);
          }
          onInversionDecision(finalScore > 0, didAnalyzePixels);
        });
      }
      function classify(root, onShouldReverseImage) {
        var NOT_CLASSIFIED = ":not([" + REVERSIBLE_ATTR + "])", selector = "img[src]" + NOT_CLASSIFIED + ",picture[srcset]" + NOT_CLASSIFIED + ',input[type="image"]' + NOT_CLASSIFIED + ",svg" + NOT_CLASSIFIED, $root = $(root);
        if ($root.is(selector)) {
          // Single image
          classifyImage(root, onShouldReverseImage);
        } else {
          // Subtree of potential images
          $(root).find(selector).each(function() {
            classifyImage(this, onShouldReverseImage);
          });
        }
      }
      if (true) {
        sitecues.debugImageClassifier = function() {
          isDebuggingOn = true;
          if ("complete" === document.readyState) {
            classify();
          } else {
            $(window).on("load", classify);
          }
        };
      }
      return {
        classify: classify,
        getSizeScore: getSizeScore,
        getExtensionScore: getExtensionScore,
        getPixelInfoScore: getPixelInfoScore,
        isImageExtension: isImageExtension,
        isSVGSource: isSVGSource
      };
    }($, page_util_color, run_conf_site, run_conf_urls, inverter_invert_url, inverter_orig_bg_info, mini_core_native_global);
    inverter_bg_image_classifier = function(urls, origBgInfo, imgClassifier) {
      var BG_IMAGE_BONUS = 40, MAX_SCORE_CHECK_PIXELS = 200;
      function shouldInvertBackgroundImage(src, size, onInversionDecision) {
        var imageExt = urls.extname(src);
        if (!imgClassifier.isImageExtension(imageExt)) {
          onInversionDecision(false);
          // Not a normal image extension -- don't invert
          return;
        }
        var sizeScore = imgClassifier.getSizeScore(size.height, size.width), extensionScore = imgClassifier.getExtensionScore(imageExt), finalScore = BG_IMAGE_BONUS + sizeScore + extensionScore;
        if (finalScore < -MAX_SCORE_CHECK_PIXELS || finalScore > MAX_SCORE_CHECK_PIXELS) {
          onInversionDecision(finalScore > 0);
          return;
        }
        // Pixel info takes longer to get: only do it if necessary
        imgClassifier.getPixelInfoScore(null, src, size, function(pixelInfoScore) {
          finalScore += pixelInfoScore;
          onInversionDecision(finalScore > 0);
        });
      }
      function getSampleElement(selector) {
        var elem, rect, index, REMOVE_PSEUDO_CLASSES_AND_ELEMENTS = /::?[^ ,:.]+/g, elems = [], DEFAULT_RECT = {
          x: 0,
          y: 0,
          width: 20,
          height: 20
        };
        try {
          elems = document.querySelectorAll(selector.replace(REMOVE_PSEUDO_CLASSES_AND_ELEMENTS, ""));
        } catch (ex) {}
        // Get first visible sample element if available
        index = elems.length;
        while (index--) {
          elem = elems[index];
          rect = elem.getBoundingClientRect();
          if (0 === index || rect.width && rect.height) {
            return {
              elem: elem,
              rect: {
                x: 0,
                y: 0,
                width: rect.width,
                height: rect.height
              },
              css: getComputedStyle(elem)
            };
          }
        }
        return {
          css: {},
          rect: DEFAULT_RECT
        };
      }
      function isPlacedBeforeText(cssStyleDecl, sampleElementCss) {
        // Content with text-indent is using inner text as alternative text but placing it offscreen
        var paddingLeft = cssStyleDecl.paddingLeft || sampleElementCss.paddingLeft;
        return parseFloat(paddingLeft) > 0;
      }
      // Does it appear that the background element has hidden text?
      // If so, this is usually a technique to give a sprite alternative text
      function containsHiddenText(cssStyleDecl, sampleElementCss) {
        return cssStyleDecl.textIndent || parseInt(sampleElementCss.textIndent) < 0 || 0 === parseInt(cssStyleDecl.fontSize) || 0 === parseInt(sampleElementCss.fontSize);
      }
      // Check for CSS repeat rules which usually indicate the image is a texture/pattern
      function hasRepeat(cssStyleDecl, sampleElementCss) {
        // Look for repeat rule on the style declaration itself
        var cssDeclRepeat = cssStyleDecl.backgroundRepeat;
        if (cssDeclRepeat && cssDeclRepeat.indexOf("no-repeat") < 0) {
          return true;
        }
        // Look for repeat rule on the computed style, but don't trust 'repeat' -- it's the default
        var computedRepeat = sampleElementCss.backgroundRepeat;
        if ("repeat-x" === computedRepeat || "repeat-y" === computedRepeat) {
          return true;
        }
      }
      function classifyBackgroundImage(bgStyle, callbackFn) {
        var sampleElement, bgInfo = bgStyle.value, imageUrl = bgInfo.imageUrl, cssStyleDecl = bgStyle.rule, selector = bgStyle.rule.selectorText;
        function onImageProcessed(doReverse) {
          bgInfo.doReverse = doReverse;
          callbackFn();
        }
        sampleElement = getSampleElement(selector);
        if (hasRepeat(cssStyleDecl, sampleElement.css)) {
          // Repeating pattern such as a texture or line
          onImageProcessed(true);
          return;
        }
        if ("100%" !== cssStyleDecl.width) {
          // Spread across the page -- could be photo-like, so it's not safe to reverse unless we check the pixels
          // Make sure it's dark so that text can be visible on top of it
          // TODO should we check for visible text on top?
          if (containsHiddenText(cssStyleDecl, sampleElement.css) || isPlacedBeforeText(cssStyleDecl, sampleElement.css) || cssStyleDecl.backgroundPosition && cssStyleDecl.backgroundPosition.indexOf("%") < 0) {
            // Clearly a sprite -- reverse it so that it shows on the newly reversed background
            onImageProcessed(true);
            return;
          }
          if (sampleElement.elem) {
            if (origBgInfo.wasOnDarkBackground(sampleElement.elem)) {
              // Already designed to show on a dark background
              onImageProcessed(false);
              return;
            }
          }
        }
        shouldInvertBackgroundImage(imageUrl, sampleElement.rect, onImageProcessed);
      }
      return {
        classifyBackgroundImage: classifyBackgroundImage
      };
    }(run_conf_urls, inverter_orig_bg_info, inverter_img_classifier);
    inverter_inverter = function($, Promise, platform, styleService, invertUrl, bgImgClassifier, imgClassifier, origBgInfo, inlineStyle) {
      var mutationObserver, filterProperty, // Use proxy in IE and Safari, because: no css invert in IE, and it's extremely slow in Safari
      SHOULD_USE_PROXY, inverseSpriteSheet, $allReversibleElems = $(), INVERSE_SPRITE_STYLESHEET_ID = "sitecues-js-invert-sprites", isCurrentlyInverting = false;
      // This method is called when the site goes from dark to light or light to dark. When it goes to dark,
      // it will analyze images if they haven't been analyzed before, and start a mutation observer so that
      // new incoming images are also analyzed.
      function toggle(doInversions) {
        if (isCurrentlyInverting === doInversions) {
          return;
        }
        isCurrentlyInverting = doInversions;
        if (doInversions) {
          start();
        } else {
          stop();
        }
        toggleSheet(inverseSpriteSheet, !doInversions);
      }
      function stop() {
        reverseElems($allReversibleElems, false);
        $allReversibleElems = $();
        if (mutationObserver) {
          mutationObserver.disconnect();
          mutationObserver = null;
        }
      }
      function start() {
        refresh(document.body);
        if (!mutationObserver) {
          mutationObserver = new MutationObserver(onMutation);
          mutationObserver.observe(document.body, {
            childList: true,
            subtree: true
          });
        }
      }
      function onMutation(mutationRecords) {
        mutationRecords.forEach(function(mutationRecord) {
          var addedNodes = mutationRecord.addedNodes, index = addedNodes.length;
          while (index--) {
            refresh(addedNodes[index]);
          }
        });
      }
      function refresh(root) {
        function onClassifiedAsReversible(elem) {
          $allReversibleElems.add(elem);
          reverseElems($(elem), true);
        }
        classifyIframes(root, onClassifiedAsReversible);
        imgClassifier.classify(root, onClassifiedAsReversible);
      }
      // Invert image or element via CSS filter: invert(1)
      function reverseElemCss($img, doReverse) {
        var savedFilter = $img.attr("data-sc-filter"), styles = {};
        if (doReverse) {
          // Add filter
          if (null === savedFilter) {
            $img.attr("data-sc-filter", $img.css(filterProperty));
          }
          styles[filterProperty] = "invert(1)";
        } else {
          // Clear filter
          styles[filterProperty] = savedFilter || "";
        }
        inlineStyle.override($img.get(), styles);
      }
      // Invert image via our reversal proxy web service
      function reverseElemProxy($img, doReverse, currentSrc) {
        var savedSrc = $img.attr("data-sc-src");
        if (doReverse) {
          // Add proxied src
          if (!savedSrc) {
            // First time
            currentSrc = $img.attr("src");
            $img.attr("data-sc-src", currentSrc);
            savedSrc = currentSrc;
          }
          invertUrl.getInvertUrl(savedSrc).then(function(newUrl) {
            $img.attr("src", newUrl);
          });
        } else {
          // Clear proxied src
          $img.attr("src", savedSrc || "");
        }
      }
      function reverseElems($elems, doReverse) {
        $elems.each(function() {
          var src = this.getAttribute("src") || "", // The image proxy can't handle svg images
          isSVG = imgClassifier.isSVGSource(src), reverseElem = src && !isSVG && SHOULD_USE_PROXY ? reverseElemProxy : reverseElemCss;
          reverseElem($(this), doReverse, src);
        });
      }
      function classifyIframes(root, reverseCallbackFn) {
        var $iframes, $root = $(root), //NOT_REVERSIBLE_FRAME_REGEX = /.*youtube|.*\.vine\.|\.eplayer/,
        REVERSIBLE_FRAME_REGEX = /twitter/;
        function isReversibleFilter(index, elem) {
          return "true" === elem.getAttribute("data-sc-reversible") || "true" === elem.getAttribute("allowtransparency") || elem.src && elem.src.match(REVERSIBLE_FRAME_REGEX);
        }
        $iframes = $root.find("iframe").filter(isReversibleFilter);
        if ("iframe" === root.localName && isReversibleFilter(0, root)) {
          $iframes.add(root);
        }
        $iframes.each(function() {
          reverseCallbackFn(this);
        });
      }
      function isReversibleBg(style) {
        // Return a promise to a CSS text for reversed sprites
        return style.value.doReverse;
      }
      // Reverse background images
      function getCssForOneSprite(style) {
        var imageUrl = style.value.imageUrl, selector = style.rule.selectorText;
        return invertUrl.getInvertUrl(imageUrl).then(function(newUrl) {
          return selector + "{\nbackground-image: url(" + newUrl + ") !important;\n}\n";
        });
      }
      // No longer needed once we kill off Chrome <= 52 and Safari <= 9.2
      // At that point it will only be 'filter'
      function getFilterProperty() {
        var div = document.createElement("div"), divStyle = inlineStyle(div);
        divStyle.filter = "invert(1)";
        return divStyle.filter ? "filter" : platform.cssPrefix + "filter";
      }
      function toggleSheet(sheet, isDisabled) {
        sheet.disabled = isDisabled;
      }
      // Return a promise that inversions are ready to use
      function init(themeStyles) {
        // Already initialized?
        if (inverseSpriteSheet) {
          return Promise.resolve();
        }
        // Not initialized yet
        // The filter value doesn't work in IE, and is *extremely* slow in Safari
        // It does work well in Edge, Chrome and Firefox
        SHOULD_USE_PROXY = false;
        filterProperty = getFilterProperty();
        function classifyBgImages() {
          return new Promise(function(resolve) {
            // Update theme styles with bg info
            var bgImageStyles = themeStyles.filter(isBgImageStyle), numImagesRemainingToClassify = bgImageStyles.length;
            function isBgImageStyle(info) {
              return "background-image" === info.value.prop;
            }
            function nextImage() {
              if (0 === numImagesRemainingToClassify--) {
                resolve();
              }
            }
            nextImage();
            // In case we started with zero images
            bgImageStyles.forEach(function(bgImageInfo) {
              bgImgClassifier.classifyBackgroundImage(bgImageInfo, nextImage);
            });
          });
        }
        function getReverseSpriteCssText() {
          var reversibleBgStyles = themeStyles.filter(isReversibleBg);
          return Promise.all(reversibleBgStyles.map(getCssForOneSprite)).then(function(allCss) {
            return allCss.join("\n");
          });
        }
        // Create inverseSpriteSheet only once
        return origBgInfo.init(themeStyles).then(classifyBgImages).then(getReverseSpriteCssText).then(function(inverseSpriteCss) {
          inverseSpriteCss = "@media screen {\n" + inverseSpriteCss + "\n}";
          // Do not use in print!
          var $sheet = styleService.updateSheet(INVERSE_SPRITE_STYLESHEET_ID, {
            text: inverseSpriteCss
          });
          return new Promise(function(resolve) {
            styleService.getDOMStylesheet($sheet, resolve);
          });
        }).then(function(domStyleSheet) {
          inverseSpriteSheet = domStyleSheet;
        });
      }
      return {
        init: init,
        toggle: toggle
      };
    }($, Promise, run_platform, page_style_service_style_service, inverter_invert_url, inverter_bg_image_classifier, inverter_img_classifier, inverter_orig_bg_info, run_inline_style_inline_style);
  })();
}